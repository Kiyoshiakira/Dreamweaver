<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dreamweaver</title>
    <!-- Note: Tailwind CDN is used for development convenience. For production deployment, 
         consider using Tailwind CLI or PostCSS plugin: https://tailwindcss.com/docs/installation -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,400;0,700;1,400&family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <script src="https://sdk.scdn.co/spotify-player.js"></script>
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, addDoc, getDocs, query, where, onSnapshot, deleteDoc, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firebase configuration - optional, only initialize if config is provided
        let auth = null;
        let db = null;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'narrative-engine-infinite';
        
        try {
            if (typeof __firebase_config !== 'undefined') {
                const firebaseConfig = JSON.parse(__firebase_config);
                const app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
            } else {
                console.log('Firebase configuration not provided - running without Firebase backend');
            }
        } catch (error) {
            console.warn('Firebase initialization failed - running without Firebase backend:', error.message);
        }

        window.fb = { auth, db, appId };

        // Spotify Configuration
        // IMPORTANT: Replace SPOTIFY_CLIENT_ID with your actual Spotify Client ID from https://developer.spotify.com/dashboard
        // This is a placeholder value and must be updated for Spotify integration to work
        const SPOTIFY_CLIENT_ID = '5c1a5a8a8f4d4f1f9c3e9e5c0c3e0c3e'; // Replace with your Spotify Client ID
        const SPOTIFY_REDIRECT_URI = window.location.origin + window.location.pathname;
        const SPOTIFY_SCOPES = 'streaming user-read-email user-read-private user-modify-playback-state user-read-playback-state';
        
        window.spotify = {
            clientId: SPOTIFY_CLIENT_ID,
            redirectUri: SPOTIFY_REDIRECT_URI,
            scopes: SPOTIFY_SCOPES
        };
        
        // Define Spotify Web Playback SDK callback
        // This function is called when the Spotify SDK is ready
        window.onSpotifyWebPlaybackSDKReady = () => {
            console.log('Spotify Web Playback SDK is ready');
            // Player initialization will be handled when user logs in
        };
    </script>

    <style>
        :root { --bg-deep: #020617; --accent: #6366f1; --text-main: #e2e8f0; }
        body { background-color: var(--bg-deep); color: var(--text-main); font-family: 'Inter', sans-serif; overflow-x: hidden; }
        .novel-font { font-family: 'Crimson Pro', serif; }
        .glass { background: rgba(15, 23, 42, 0.8); backdrop-filter: blur(16px); border: 1px solid rgba(255,255,255,0.08); }
        .tab-active { background: var(--accent); color: white; }
        
        .sentence-span { transition: opacity 0.3s ease; opacity: 0.3; cursor: pointer; display: inline; }
        .sentence-active { opacity: 1 !important; color: #1a1a1a !important; font-weight: 500; }
        
        .word-token { display: inline; padding: 0; transition: all 0.15s ease; }
        .word-active { background-color: #3b82f6 !important; color: white !important; padding: 2px 4px; border-radius: 4px; }

        .image-container { 
            position: sticky; top: 2rem; width: 100%; aspect-ratio: 1/1; 
            border-radius: 2rem; overflow: hidden; background: #0f172a; 
            border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }
        .image-container img { width: 100%; height: 100%; object-fit: cover; transition: opacity 1.5s ease; }
        
        .timer-glow { text-shadow: 0 0 10px rgba(99, 102, 241, 0.5); }
    </style>
</head>
<body class="selection:bg-indigo-500/30">
    <div id="app" class="relative z-10 min-h-screen flex flex-col">
        <nav class="flex items-center justify-between p-6 max-w-7xl mx-auto w-full">
            <div class="flex items-center gap-3">
                <div class="w-10 h-10 bg-indigo-600 rounded-xl flex items-center justify-center shadow-lg shadow-indigo-500/20">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg>
                </div>
                <h1 class="text-xl font-black tracking-tighter uppercase">Dream<span class="text-indigo-500">weaver</span></h1>
            </div>
            
            <div id="session-timer" class="hidden glass px-6 py-2 rounded-full border border-indigo-500/30 font-mono text-indigo-400 font-bold timer-glow">
                00:00:00
            </div>
        </nav>

        <!-- Setup Screen -->
        <main id="view-home" class="flex-1 max-w-3xl mx-auto px-6 py-12 w-full">
            <div class="glass rounded-[2.5rem] p-10 space-y-10 shadow-2xl border border-white/5">
                <div class="space-y-4">
                    <h2 class="text-4xl font-black tracking-tight">Welcome to Dreamweaver</h2>
                    <p class="text-slate-400 text-sm">Tell me what story you'd like to hear, and I'll weave it for you.</p>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                    <!-- Narrator Selection -->
                    <div class="space-y-2">
                        <label class="text-indigo-400 text-[11px] font-black uppercase tracking-widest ml-1">Narrator Voice</label>
                        <select id="voice-select" class="w-full bg-slate-900 border border-white/10 rounded-2xl p-4 text-white appearance-none cursor-pointer hover:bg-slate-800 transition-colors"></select>
                    </div>

                    <!-- Session Length (Restored & Enhanced) -->
                    <div class="space-y-2">
                        <label class="text-indigo-400 text-[11px] font-black uppercase tracking-widest ml-1">Session Duration</label>
                        <select id="length-select" class="w-full bg-slate-900 border border-white/10 rounded-2xl p-4 text-white appearance-none cursor-pointer">
                            <option value="5">5 Minutes</option>
                            <option value="30">30 Minutes</option>
                            <option value="60">1 Hour</option>
                            <option value="120">2 Hours</option>
                        </select>
                    </div>

                    <div class="space-y-2">
                        <label class="text-indigo-400 text-[11px] font-black uppercase tracking-widest ml-1">Narrative Genre</label>
                        <select id="genre-select" class="w-full bg-slate-900 border border-white/10 rounded-2xl p-4 text-white appearance-none cursor-pointer">
                            <option value="Fantasy">Fantasy</option>
                            <option value="Sci-Fi">Sci-Fi</option>
                            <option value="Mystery">Mystery</option>
                            <option value="Horror">Horror</option>
                            <option value="Drama">Historical Drama</option>
                        </select>
                    </div>

                    <!-- Intelligent Score -->
                    <div class="space-y-2">
                        <label class="text-indigo-400 text-[11px] font-black uppercase tracking-widest ml-1">Score Dynamics</label>
                        <div class="flex items-center gap-4 bg-slate-900 border border-white/10 rounded-2xl p-4">
                            <span class="text-[10px] text-slate-500 uppercase font-bold">Static</span>
                            <input type="range" id="score-sensitivity" class="flex-1 accent-indigo-500" min="1" max="5" value="3">
                            <span class="text-[10px] text-slate-500 uppercase font-bold">Fluid</span>
                        </div>
                    </div>
                </div>
                
                <!-- Spotify Integration Section -->
                <div class="space-y-2 p-6 bg-slate-900/50 border border-indigo-500/20 rounded-2xl">
                    <div class="flex items-center justify-between">
                        <div class="space-y-1">
                            <label class="text-indigo-400 text-[11px] font-black uppercase tracking-widest">Music Source</label>
                            <p class="text-slate-400 text-xs">Connect Spotify for personalized music selection</p>
                        </div>
                        <div id="spotify-status" class="flex items-center gap-2">
                            <button id="spotify-login-btn" onclick="loginSpotify()" class="px-5 py-2 bg-green-600 hover:bg-green-500 rounded-xl font-bold text-sm transition-all active:scale-95 flex items-center gap-2">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z"/></svg>
                                Connect Spotify
                            </button>
                            <div id="spotify-user-info" class="hidden flex items-center gap-3 bg-slate-800 border border-white/10 rounded-xl px-4 py-2">
                                <div class="flex items-center gap-2">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="#1DB954"><path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z"/></svg>
                                    <span id="spotify-username" class="text-sm font-bold text-white">User</span>
                                </div>
                                <button onclick="logoutSpotify()" class="text-xs text-slate-400 hover:text-white transition-colors">Disconnect</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="space-y-2">
                    <label class="text-indigo-400 text-[11px] font-black uppercase tracking-widest ml-1">Story Prompt</label>
                    <textarea id="prompt-input" class="w-full bg-slate-900 border border-white/10 rounded-3xl p-6 text-white h-40 focus:ring-2 ring-indigo-500 outline-none resize-none text-lg leading-relaxed" placeholder="What story would you like to hear? Describe your characters, setting, or adventure..."></textarea>
                </div>

                <button id="start-btn" onclick="initiateSession()" class="w-full py-6 bg-indigo-600 rounded-2xl font-black text-xl shadow-xl hover:bg-indigo-500 transition-all active:scale-[0.98] uppercase tracking-widest">
                    Begin Story
                </button>
            </div>
        </main>

        <!-- Reader Screen -->
        <main id="view-reader" class="hidden flex-1 max-w-7xl mx-auto px-4 py-6 w-full pb-48">
            <div class="grid grid-cols-1 lg:grid-cols-12 gap-10">
                <div class="lg:col-span-7 bg-[#fafaf9] text-[#1c1917] novel-font rounded-[3rem] shadow-2xl flex flex-col min-h-[85vh] border border-stone-200 overflow-hidden">
                    <div id="scroll-target" class="p-12 md:p-20 flex-1 overflow-y-auto">
                        <div id="vibe-badge" class="inline-block px-4 py-1 rounded-full bg-indigo-100 text-indigo-700 text-[10px] font-black uppercase tracking-widest mb-6 transition-all opacity-0">...</div>
                        <h1 id="reader-title" class="text-5xl font-bold mb-10 tracking-tight text-stone-900 italic">Initializing...</h1>
                        <div id="reader-content" class="text-[24px] md:text-[28px] leading-[1.7] text-stone-700 space-y-8"></div>
                    </div>
                </div>

                <div class="lg:col-span-5 space-y-8">
                    <div class="image-container">
                        <div id="img-overlay" class="absolute inset-0 bg-black/60 flex flex-col items-center justify-center opacity-0 transition-opacity z-10 backdrop-blur-sm">
                            <div class="w-10 h-10 border-2 border-white/20 border-t-white rounded-full animate-spin mb-3"></div>
                            <span class="text-[10px] font-bold text-white uppercase tracking-widest">Generating Scene</span>
                        </div>
                        <img id="scene-image" src="" class="opacity-0">
                    </div>
                    
                    <div class="glass p-8 rounded-[2.5rem] space-y-6">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center gap-4">
                                <div class="w-12 h-12 bg-indigo-500/20 rounded-2xl flex items-center justify-center text-indigo-400">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle></svg>
                                </div>
                                <div>
                                    <p class="text-white font-black text-sm uppercase tracking-wider">Dynamic Score</p>
                                    <p id="music-status" class="text-indigo-300 text-xs">Analyzing Prose...</p>
                                </div>
                            </div>
                            <div id="genre-icon" class="text-2xl">âœ¨</div>
                        </div>
                        <input type="range" id="music-vol" min="0" max="0.5" step="0.01" value="0.15" class="w-full accent-indigo-500">
                        
                        <!-- Change Song Button -->
                        <button id="change-song-btn" onclick="changeSong()" class="w-full py-3 bg-slate-700 hover:bg-slate-600 rounded-2xl font-bold text-sm transition-all active:scale-95 flex items-center justify-center gap-2">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 4v6h6M23 20v-6h-6"></path><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path></svg>
                            Change Song
                        </button>
                    </div>
                </div>
            </div>
        </main>

        <div id="control-panel" class="hidden fixed bottom-10 left-1/2 -translate-x-1/2 w-[90%] max-w-4xl glass rounded-[2.5rem] p-5 shadow-2xl z-50 border border-white/10">
            <div class="flex flex-col sm:flex-row items-center gap-4">
                <!-- Playback Controls -->
                <div class="flex items-center gap-3">
                    <button onclick="restartPlayback()" class="w-12 h-12 bg-slate-700 rounded-2xl flex items-center justify-center text-white shadow-lg hover:bg-slate-600 active:scale-95 transition-all" title="Restart from beginning">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"></path></svg>
                    </button>
                    <button onclick="togglePlayback()" class="w-16 h-16 bg-white rounded-3xl flex items-center justify-center text-indigo-900 shadow-xl hover:scale-105 active:scale-95 transition-all">
                        <svg id="icon-play" width="32" height="32" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"></path></svg>
                        <svg id="icon-pause" class="hidden" width="32" height="32" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg>
                    </button>
                    <button onclick="stopPlayback()" class="w-12 h-12 bg-slate-700 rounded-2xl flex items-center justify-center text-white shadow-lg hover:bg-slate-600 active:scale-95 transition-all" title="Stop playback">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="6" width="12" height="12"></rect></svg>
                    </button>
                </div>
                
                <!-- Current Word Display -->
                <div class="flex-1 overflow-hidden min-w-0">
                    <div class="text-[10px] font-black text-indigo-400 uppercase tracking-widest mb-1">Live Feed</div>
                    <div id="current-word" class="text-xl font-black text-white truncate italic">...</div>
                </div>
                
                <!-- Voice Selector -->
                <div class="flex items-center gap-3">
                    <div class="text-right">
                        <div class="text-[10px] font-black text-indigo-400 uppercase tracking-widest mb-1">Narrator</div>
                        <select id="voice-select-reader" onchange="changeVoice(this.value)" class="bg-slate-800 border border-white/10 rounded-xl px-4 py-2 text-white text-sm appearance-none cursor-pointer hover:bg-slate-700 transition-colors">
                        </select>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const apiKey = "AIzaSyAn9y0jXqRvoc4jfLUco2cSsQNoN27M7T8";
        const DEFAULT_ACCENT = 'American';
        const MUSIC_SELECTION_MIN_SCORE = 2; // Minimum keyword matches for intelligent music selection
        const IMAGE_QUEUE_DELAY_MS = 1000; // Delay between background image generations to avoid API overload
        const RESTART_PLAYBACK_DELAY_MS = 300; // Delay before starting playback after restart to allow UI updates to complete
        const VOICES = {
            'American - Kore (Firm)': { name: 'Kore', accent: 'American' },
            'American - Zephyr (Bright)': { name: 'Zephyr', accent: 'American' },
            'American - Puck (Upbeat)': { name: 'Puck', accent: 'American' },
            'British - Enceladus (Breathy)': { name: 'Enceladus', accent: 'British' },
            'British - Charon (Informative)': { name: 'Charon', accent: 'British' },
            'Australian - Fenrir (Excitable)': { name: 'Fenrir', accent: 'Australian' },
            'Australian - Despina (Smooth)': { name: 'Despina', accent: 'Australian' },
            'Indian - Algieba (Smooth)': { name: 'Algieba', accent: 'Indian' }
        };
        const SCORE_LIBRARY = {
            whimsical: { name: "Whimsical Fantasy", icon: "ðŸª„", url: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3', keywords: ['magic', 'wonder', 'playful', 'light', 'fantasy', 'enchant', 'fairy', 'charm'] },
            noir: { name: "Noir Mystery", icon: "ðŸ•µï¸", url: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3', keywords: ['mystery', 'detective', 'shadow', 'noir', 'investigate', 'clue', 'secret', 'hidden'] },
            epic: { name: "High Adventure", icon: "âš”ï¸", url: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-8.mp3', keywords: ['battle', 'war', 'hero', 'quest', 'adventure', 'fight', 'warrior', 'epic', 'glory', 'triumph'] },
            horror: { name: "Dark Suspense", icon: "ðŸŒ‘", url: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3', keywords: ['dark', 'fear', 'horror', 'terror', 'dread', 'nightmare', 'shadow', 'death', 'blood', 'scream'] },
            scifi: { name: "Sci-Fi Ambient", icon: "ðŸš€", url: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3', keywords: ['space', 'future', 'technology', 'alien', 'robot', 'cyber', 'quantum', 'science', 'ship', 'galaxy'] },
            dramatic: { name: "Heavy Drama", icon: "ðŸŽ­", url: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3', keywords: ['emotion', 'tragic', 'sorrow', 'loss', 'pain', 'heart', 'tear', 'despair', 'sacrifice'] }
        };

        const state = {
            isPlaying: false,
            sentences: [],
            currentIndex: 0,
            voice: 'Kore',
            accent: 'American',
            timeLeftSeconds: 0,
            genre: '',
            history: [],
            audioBuffer: new Map(),
            currentAudio: new Audio(),
            music: new Audio(),
            isGeneratingChapter: false,
            isGeneratingVisual: false,
            chapterStartIndex: 0,
            // Timing estimates: ~8 seconds per sentence based on TTS speed and natural reading pace
            estimatedSecondsPerSentence: 8,
            // Average chapter length: ~12 sentences (~400 words) for optimal pacing and generation speed
            averageSentencesPerChapter: 12,
            // Minimum time buffer: Require at least half a chapter's duration before generating next chapter
            minTimeBufferRatio: 0.5,
            // Retry delay: Wait 5 seconds before allowing retry after failed generation to avoid rapid retries
            retryDelayMs: 5000,
            nextChapterTriggered: false,
            // Image generation: Track generated images and queue for pre-generation
            imageCache: new Map(),
            imageQueue: [],
            lastImageIndex: -1,
            isProcessingImageQueue: false,
            // Music intelligence: Track current mood and prose content for intelligent selection
            currentMood: null,
            lastProseContent: '',
            // Spotify integration
            spotifyAccessToken: null,
            spotifyRefreshToken: null,
            spotifyTokenExpiry: null,
            spotifyUser: null,
            spotifyPlayer: null,
            spotifyDeviceId: null,
            isUsingSpotify: false,
            currentSpotifyTrack: null,
            availableSpotifyTracks: []
        };

        // Spotify Authentication Functions
        async function loginSpotify() {
            // Check if Spotify config is available
            if (!window.spotify || !window.spotify.clientId) {
                console.error('Spotify configuration not available');
                alert('Spotify integration is not configured. Please add your Spotify Client ID.');
                return;
            }
            
            const codeVerifier = generateCodeVerifier();
            const codeChallenge = await generateCodeChallenge(codeVerifier);
            
            // Store code verifier for later use
            localStorage.setItem('spotify_code_verifier', codeVerifier);
            
            const authUrl = new URL('https://accounts.spotify.com/authorize');
            authUrl.searchParams.append('client_id', window.spotify.clientId);
            authUrl.searchParams.append('response_type', 'code');
            authUrl.searchParams.append('redirect_uri', window.spotify.redirectUri);
            authUrl.searchParams.append('scope', window.spotify.scopes);
            authUrl.searchParams.append('code_challenge_method', 'S256');
            authUrl.searchParams.append('code_challenge', codeChallenge);
            
            window.location.href = authUrl.toString();
        }

        function logoutSpotify() {
            // Clear Spotify state
            state.spotifyAccessToken = null;
            state.spotifyRefreshToken = null;
            state.spotifyTokenExpiry = null;
            state.spotifyUser = null;
            state.isUsingSpotify = false;
            state.currentSpotifyTrack = null;
            state.availableSpotifyTracks = [];
            
            // Clear local storage
            localStorage.removeItem('spotify_access_token');
            localStorage.removeItem('spotify_refresh_token');
            localStorage.removeItem('spotify_token_expiry');
            localStorage.removeItem('spotify_user');
            
            // Update UI
            updateSpotifyUI();
            
            // If currently using Spotify music, switch back to default
            if (state.currentMood) {
                applyScore(state.currentMood);
            }
        }

        function generateCodeVerifier() {
            const array = new Uint8Array(32);
            crypto.getRandomValues(array);
            return base64UrlEncode(array);
        }

        async function generateCodeChallenge(verifier) {
            const encoder = new TextEncoder();
            const data = encoder.encode(verifier);
            const digest = await crypto.subtle.digest('SHA-256', data);
            return base64UrlEncode(new Uint8Array(digest));
        }

        function base64UrlEncode(array) {
            const base64 = btoa(String.fromCharCode.apply(null, array));
            return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
        }

        async function handleSpotifyCallback() {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            
            if (code) {
                const codeVerifier = localStorage.getItem('spotify_code_verifier');
                if (!codeVerifier) {
                    console.error('Code verifier not found');
                    return;
                }
                
                try {
                    const response = await fetch('https://accounts.spotify.com/api/token', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: new URLSearchParams({
                            grant_type: 'authorization_code',
                            code: code,
                            redirect_uri: window.spotify.redirectUri,
                            client_id: window.spotify.clientId,
                            code_verifier: codeVerifier,
                        }),
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    
                    if (data.access_token) {
                        state.spotifyAccessToken = data.access_token;
                        state.spotifyRefreshToken = data.refresh_token;
                        state.spotifyTokenExpiry = Date.now() + (data.expires_in * 1000);
                        
                        // Store in localStorage
                        localStorage.setItem('spotify_access_token', data.access_token);
                        localStorage.setItem('spotify_refresh_token', data.refresh_token);
                        localStorage.setItem('spotify_token_expiry', state.spotifyTokenExpiry);
                        
                        // Get user info
                        await fetchSpotifyUserInfo();
                        
                        // Update UI
                        updateSpotifyUI();
                        
                        // Clear URL parameters
                        window.history.replaceState({}, document.title, window.location.pathname);
                        
                        // Clean up
                        localStorage.removeItem('spotify_code_verifier');
                    }
                } catch (error) {
                    console.error('Error exchanging code for token:', error);
                }
            }
        }

        async function fetchSpotifyUserInfo() {
            if (!state.spotifyAccessToken) return;
            
            try {
                const response = await fetch('https://api.spotify.com/v1/me', {
                    headers: {
                        'Authorization': `Bearer ${state.spotifyAccessToken}`
                    }
                });
                
                const userData = await response.json();
                state.spotifyUser = userData;
                localStorage.setItem('spotify_user', JSON.stringify(userData));
            } catch (error) {
                console.error('Error fetching Spotify user info:', error);
            }
        }

        function updateSpotifyUI() {
            const loginBtn = document.getElementById('spotify-login-btn');
            const userInfo = document.getElementById('spotify-user-info');
            const username = document.getElementById('spotify-username');
            
            if (state.spotifyAccessToken && state.spotifyUser) {
                loginBtn.classList.add('hidden');
                userInfo.classList.remove('hidden');
                username.textContent = state.spotifyUser.display_name || state.spotifyUser.id;
            } else {
                loginBtn.classList.remove('hidden');
                userInfo.classList.add('hidden');
            }
        }

        async function searchSpotifyTracks(mood, genre) {
            if (!state.spotifyAccessToken) {
                console.log('Not logged into Spotify, using default music');
                return null;
            }
            
            // Map moods to Spotify search terms
            const moodKeywords = {
                whimsical: 'whimsical fantasy magical',
                noir: 'noir mystery detective jazz',
                epic: 'epic orchestral cinematic adventure',
                horror: 'dark horror suspense ambient',
                scifi: 'sci-fi electronic ambient futuristic',
                dramatic: 'dramatic emotional orchestral'
            };
            
            const searchQuery = moodKeywords[mood] || mood;
            
            try {
                const response = await fetch(`https://api.spotify.com/v1/search?q=${encodeURIComponent(searchQuery)}&type=track&limit=10`, {
                    headers: {
                        'Authorization': `Bearer ${state.spotifyAccessToken}`
                    }
                });
                
                const data = await response.json();
                
                if (data.tracks && data.tracks.items && data.tracks.items.length > 0) {
                    state.availableSpotifyTracks = data.tracks.items;
                    return data.tracks.items[0]; // Return first track
                }
            } catch (error) {
                console.error('Error searching Spotify tracks:', error);
            }
            
            return null;
        }

        async function playSpotifyTrack(track) {
            if (!state.spotifyAccessToken || !track) return false;
            
            try {
                // Stop current music
                state.music.pause();
                
                // Use Spotify Web Playback SDK or fallback to preview URL
                if (track.preview_url) {
                    state.music.src = track.preview_url;
                    state.music.loop = true;
                    state.currentSpotifyTrack = track;
                    state.isUsingSpotify = true;
                    
                    // Update UI
                    const musicStatus = document.getElementById('music-status');
                    if (musicStatus) {
                        musicStatus.textContent = `${track.name} - ${track.artists[0].name}`;
                    }
                    
                    if (state.isPlaying) {
                        await state.music.play();
                    }
                    
                    return true;
                } else {
                    console.warn('Track has no preview URL available');
                    return false;
                }
            } catch (error) {
                console.error('Error playing Spotify track:', error);
                return false;
            }
        }

        async function changeSong() {
            const btn = document.getElementById('change-song-btn');
            const originalText = btn.innerHTML;
            
            // Show loading state
            btn.innerHTML = '<svg class="animate-spin h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10" stroke-opacity="0.25"></circle><path d="M12 2a10 10 0 0 1 10 10" stroke-opacity="0.75"></path></svg> Searching...';
            btn.disabled = true;
            
            try {
                if (state.spotifyAccessToken && state.currentMood) {
                    // Use Spotify if logged in
                    const track = await searchSpotifyTracks(state.currentMood, state.genre);
                    
                    if (track) {
                        const success = await playSpotifyTrack(track);
                        
                        if (success) {
                            console.log('Changed to Spotify track:', track.name);
                        } else {
                            // Fallback to next track in default library
                            changeToNextDefaultTrack();
                        }
                    } else {
                        // Fallback to default library
                        changeToNextDefaultTrack();
                    }
                } else {
                    // Use default music library
                    changeToNextDefaultTrack();
                }
            } catch (error) {
                console.error('Error changing song:', error);
                changeToNextDefaultTrack();
            } finally {
                // Restore button
                btn.innerHTML = originalText;
                btn.disabled = false;
            }
        }

        function changeToNextDefaultTrack() {
            if (!state.currentMood) return;
            
            // Get all tracks matching the current mood category
            const currentTrackKey = state.currentMood;
            const sameMoodTracks = [];
            
            // Find tracks with similar keywords
            const currentTrack = SCORE_LIBRARY[currentTrackKey];
            if (!currentTrack) return;
            
            for (const [key, track] of Object.entries(SCORE_LIBRARY)) {
                if (key !== currentTrackKey) {
                    // Check if tracks share keywords
                    const sharedKeywords = currentTrack.keywords.filter(k => 
                        track.keywords.includes(k)
                    );
                    if (sharedKeywords.length > 0) {
                        sameMoodTracks.push(key);
                    }
                }
            }
            
            // If no similar tracks, use any other track
            if (sameMoodTracks.length === 0) {
                const allKeys = Object.keys(SCORE_LIBRARY);
                sameMoodTracks.push(...allKeys.filter(k => k !== currentTrackKey));
            }
            
            // Select a random track from similar ones
            if (sameMoodTracks.length > 0) {
                const randomKey = sameMoodTracks[Math.floor(Math.random() * sameMoodTracks.length)];
                state.currentMood = randomKey;
                state.isUsingSpotify = false;
                applyScore(randomKey);
                console.log('Changed to default track:', randomKey);
            }
        }

        // Check for stored Spotify credentials on page load
        function restoreSpotifySession() {
            const accessToken = localStorage.getItem('spotify_access_token');
            const refreshToken = localStorage.getItem('spotify_refresh_token');
            const tokenExpiry = localStorage.getItem('spotify_token_expiry');
            const userStr = localStorage.getItem('spotify_user');
            
            if (accessToken && tokenExpiry && Date.now() < parseInt(tokenExpiry)) {
                state.spotifyAccessToken = accessToken;
                state.spotifyRefreshToken = refreshToken;
                state.spotifyTokenExpiry = parseInt(tokenExpiry);
                
                if (userStr) {
                    try {
                        state.spotifyUser = JSON.parse(userStr);
                    } catch (e) {
                        console.error('Error parsing stored user data:', e);
                    }
                }
                
                updateSpotifyUI();
            } else if (accessToken && refreshToken) {
                // Token expired, try to refresh
                refreshSpotifyToken().catch(err => {
                    console.error('Failed to refresh Spotify token:', err);
                    logoutSpotify();
                });
            }
        }

        async function refreshSpotifyToken() {
            if (!state.spotifyRefreshToken) return;
            
            try {
                const response = await fetch('https://accounts.spotify.com/api/token', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        grant_type: 'refresh_token',
                        refresh_token: state.spotifyRefreshToken,
                        client_id: window.spotify.clientId,
                    }),
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.access_token) {
                    state.spotifyAccessToken = data.access_token;
                    state.spotifyTokenExpiry = Date.now() + (data.expires_in * 1000);
                    
                    localStorage.setItem('spotify_access_token', data.access_token);
                    localStorage.setItem('spotify_token_expiry', state.spotifyTokenExpiry);
                    
                    if (data.refresh_token) {
                        state.spotifyRefreshToken = data.refresh_token;
                        localStorage.setItem('spotify_refresh_token', data.refresh_token);
                    }
                    
                    updateSpotifyUI();
                }
            } catch (error) {
                console.error('Error refreshing Spotify token:', error);
                throw error;
            }
        }


        async function initiateSession() {
            const prompt = document.getElementById('prompt-input').value || "Tell me an interesting story.";
            const selectedVoice = document.getElementById('voice-select').value;
            let voiceConfig = VOICES[selectedVoice];
            
            // Validate voice configuration with fallback
            if (!voiceConfig) {
                console.error('Invalid voice selection:', selectedVoice, '- falling back to default');
                const defaultVoiceKey = Object.keys(VOICES)[0];
                voiceConfig = VOICES[defaultVoiceKey];
            }
            
            state.voice = voiceConfig.name;
            state.accent = voiceConfig.accent;
            state.timeLeftSeconds = parseInt(document.getElementById('length-select').value) * 60;
            state.genre = document.getElementById('genre-select').value;
            
            // Sync reader voice selector with initial selection
            document.getElementById('voice-select-reader').value = selectedVoice;
            
            switchView('reader');
            startTimerDisplay();
            
            // First Chapter
            await generateNextChapter(prompt);
            
            // Preload first 3 sentences for immediate playback in parallel
            const preloadPromises = [];
            for (let i = 0; i < Math.min(3, state.sentences.length); i++) {
                preloadPromises.push(preloadAudio(i));
            }
            await Promise.all(preloadPromises);
            
            togglePlayback();
        }

        async function generateNextChapter(seedPrompt) {
            if (state.isGeneratingChapter) return;
            state.isGeneratingChapter = true;
            
            const sys = `You are a professional novelist writing a ${state.genre} story. 
            The session has ${Math.ceil(state.timeLeftSeconds / 60)} minutes remaining.
            Continue the story based on history. If this is the start, use the prompt.
            Output JSON: { "title": "Chapter Title", "prose": "About 400 words of story", "score_type": "epic/horror/noir/scifi/whimsical/dramatic", "key_visual_moments": ["brief scene description 1", "brief scene description 2"] }
            Include 2-3 key visual moments that represent important scenes in this chapter.`;

            try {
                const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-3-flash-preview:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: `History: ${state.history.join(' ')}\n\nCurrent Focus: ${seedPrompt}` }] }],
                        systemInstruction: { parts: [{ text: sys }] },
                        generationConfig: { responseMimeType: "application/json" }
                    })
                });
                const data = await res.json();
                const result = JSON.parse(data.candidates[0].content.parts[0].text);
                
                state.history.push(result.prose);
                state.lastProseContent = result.prose;
                
                // Append chapter content to the page
                appendChapter(result);
                
                // Intelligently select music based on prose content analysis
                await applyIntelligentScore(result.prose, result.score_type);
                
                // Pre-generate images for this chapter before reading begins
                await preGenerateChapterImages(result);
            } finally {
                state.isGeneratingChapter = false;
            }
        }

        function appendChapter(data) {
            const container = document.getElementById('reader-content');
            const chapterSents = data.prose.match(/[^.!?]+[.!?]+(?=\s|$)/g) || [data.prose];
            const startIdx = state.sentences.length;
            
            // Track where this chapter starts
            state.chapterStartIndex = startIdx;
            // Reset flag for next chapter generation trigger
            state.nextChapterTriggered = false;
            
            document.getElementById('reader-title').innerText = data.title;
            
            chapterSents.forEach((text, i) => {
                const globalIdx = startIdx + i;
                const span = document.createElement('span');
                span.id = `s-${globalIdx}`;
                span.className = 'sentence-span';
                text.split(/\s+/).forEach((word, wi) => {
                    const wSpan = document.createElement('span');
                    wSpan.className = 'word-token';
                    wSpan.id = `s-${globalIdx}-w-${wi}`;
                    wSpan.innerText = word + ' ';
                    span.appendChild(wSpan);
                });
                container.appendChild(span);
                state.sentences.push(text);
            });
        }

        async function playCycle() {
            // Check if we should stop playback
            if (!state.isPlaying || state.currentIndex >= state.sentences.length) {
                if (shouldGenerateNextChapter()) {
                    await generateNextChapter("Continue the narrative smoothly.");
                    await playCycle();
                }
                return;
            }

            // Calculate how many sentences are left in current chapter
            const sentencesLeftInChapter = state.sentences.length - state.currentIndex;
            const sentencesInCurrentChapter = state.sentences.length - state.chapterStartIndex;
            
            // Trigger next chapter generation when halfway through current chapter
            // This allows AI to write while reading
            // Only trigger once per chapter to avoid duplicate generation requests
            // Require at least 2 sentences in chapter to avoid edge cases with very short chapters
            if (!state.nextChapterTriggered && 
                sentencesInCurrentChapter >= 2 && 
                sentencesLeftInChapter > 0 &&
                sentencesLeftInChapter <= Math.floor(sentencesInCurrentChapter / 2)) {
                if (shouldGenerateNextChapter()) {
                    state.nextChapterTriggered = true;
                    // Generate in parallel without awaiting, so reading continues
                    generateNextChapter("Continue the narrative smoothly.").catch(err => {
                        console.error('Failed to generate next chapter in background:', err);
                        console.error('Context: Chapter generation failed mid-reading. System will retry when current chapter completes.');
                        // Note: If generation fails, the system will retry when playCycle reaches end of current chapter
                        // Reset flag after a delay to avoid rapid retries
                        setTimeout(() => { state.nextChapterTriggered = false; }, state.retryDelayMs);
                    });
                }
            }

            // Trigger visual every 4 sentences - use cached images if available
            // Check if current index aligns with image generation points (every 4 sentences from chapter start)
            const sentencesIntoChapter = state.currentIndex - state.chapterStartIndex;
            if (sentencesIntoChapter >= 0 && sentencesIntoChapter % 4 === 0) {
                if (state.imageCache.has(state.currentIndex)) {
                    displayCachedImage(state.currentIndex);
                } else {
                    // Fallback: generate on-the-fly if not cached
                    updateVisual(state.currentIndex).catch(err => console.error('Visual generation error:', err));
                }
            }

            let blob = state.audioBuffer.get(state.currentIndex);
            if (!blob) blob = await fetchTTS(state.sentences[state.currentIndex]);

            // Preload next sentences for seamless playback
            preloadNextSentences(state.currentIndex, 2);

            const audioUrl = URL.createObjectURL(blob);
            state.currentAudio.src = audioUrl;
            
            // Start highlighting and word animation immediately
            highlight(state.currentIndex);
            
            const onMetadataLoaded = () => {
                animateWords(state.currentIndex);
                state.currentAudio.removeEventListener('loadedmetadata', onMetadataLoaded);
            };
            
            const onEnded = () => {
                URL.revokeObjectURL(audioUrl);
                state.currentAudio.removeEventListener('loadedmetadata', onMetadataLoaded);
                state.currentAudio.removeEventListener('ended', onEnded);
                state.currentIndex++;
                playCycle().catch(err => console.error('Playback cycle error:', err));
            };
            
            state.currentAudio.addEventListener('loadedmetadata', onMetadataLoaded);
            state.currentAudio.addEventListener('ended', onEnded);
            
            // Play immediately without delay
            state.currentAudio.play().catch(err => console.error('Audio playback error:', err));
        }
        
        function shouldGenerateNextChapter() {
            // Don't generate if already generating
            if (state.isGeneratingChapter) return false;
            
            // Don't generate if no time left
            if (state.timeLeftSeconds <= 0) return false;
            
            // Estimate time needed for one chapter (avg sentences per chapter * seconds per sentence)
            const estimatedChapterDuration = state.averageSentencesPerChapter * state.estimatedSecondsPerSentence;
            
            // Only generate if we have enough time to read at least minTimeBufferRatio of the next chapter
            // This prevents starting chapters that won't have time to complete
            return state.timeLeftSeconds >= (estimatedChapterDuration * state.minTimeBufferRatio);
        }

        async function fetchTTS(text) {
            const accentPrompt = state.accent !== DEFAULT_ACCENT ? ` Speak with a ${state.accent} accent.` : '';
            const fullText = text + accentPrompt;
            
            const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-3-flash-preview:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: fullText }] }],
                    generationConfig: { 
                        responseModalities: ["AUDIO"], 
                        speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: state.voice } } } 
                    }
                })
            });
            
            const data = await res.json();
            
            // Validate response structure
            if (!data || !data.candidates || !data.candidates[0] || 
                !data.candidates[0].content || !data.candidates[0].content.parts || 
                !data.candidates[0].content.parts[0] || !data.candidates[0].content.parts[0].inlineData) {
                throw new Error('Invalid TTS API response structure: ' + JSON.stringify(data));
            }
            
            return base64ToWav(data.candidates[0].content.parts[0].inlineData.data, 24000);
        }

        function base64ToWav(base64, rate) {
            const bin = atob(base64);
            const buf = new ArrayBuffer(bin.length);
            const view = new Uint8Array(buf);
            for (let i = 0; i < bin.length; i++) view[i] = bin.charCodeAt(i);
            const header = new ArrayBuffer(44);
            const hView = new DataView(header);
            const writeStr = (off, s) => { for (let i = 0; i < s.length; i++) hView.setUint8(off + i, s.charCodeAt(i)); };
            writeStr(0, 'RIFF'); hView.setUint32(4, 36 + buf.byteLength, true); writeStr(8, 'WAVE'); writeStr(12, 'fmt ');
            hView.setUint32(16, 16, true); hView.setUint16(20, 1, true); hView.setUint16(22, 1, true); hView.setUint32(24, rate, true);
            hView.setUint32(28, rate * 2, true); hView.setUint16(32, 2, true); hView.setUint16(34, 16, true); writeStr(36, 'data');
            hView.setUint32(40, buf.byteLength, true);
            return new Blob([header, buf], { type: 'audio/wav' });
        }

        async function updateVisual(idx) {
            if (state.isGeneratingVisual) return;
            state.isGeneratingVisual = true;
            document.getElementById('img-overlay').classList.remove('opacity-0');
            const context = state.sentences.slice(idx, idx+2).join(' ');
            try {
                const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/imagen-4.0-generate-001:predict?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ instances: [{ prompt: `Cinematic professional fantasy art, atmospheric, ${state.genre} style: ${context}` }] })
                });
                const data = await res.json();
                
                // Validate response structure before accessing nested properties
                if (!data || !data.predictions || !data.predictions[0] || !data.predictions[0].bytesBase64Encoded) {
                    throw new Error('Invalid API response structure: missing image data');
                }
                
                const img = document.getElementById('scene-image');
                img.src = `data:image/png;base64,${data.predictions[0].bytesBase64Encoded}`;
                img.onload = () => {
                    img.classList.remove('opacity-0');
                    document.getElementById('img-overlay').classList.add('opacity-0');
                };
            } catch (err) {
                console.error('Visual generation error:', err);
                // Hide overlay on error to avoid blocking the UI
                document.getElementById('img-overlay').classList.add('opacity-0');
            } finally { 
                state.isGeneratingVisual = false; 
            }
        }

        function startTimerDisplay() {
            const el = document.getElementById('session-timer');
            el.classList.remove('hidden');
            const iv = setInterval(() => {
                if (state.timeLeftSeconds <= 0) {
                    clearInterval(iv);
                    // Auto-stop playback when time is up
                    if (state.isPlaying) {
                        state.isPlaying = false;
                        state.currentAudio.pause();
                        state.music.pause();
                        document.getElementById('icon-play').classList.remove('hidden');
                        document.getElementById('icon-pause').classList.add('hidden');
                    }
                    return;
                }
                if (state.isPlaying) state.timeLeftSeconds--;
                const h = Math.floor(state.timeLeftSeconds / 3600);
                const m = Math.floor((state.timeLeftSeconds % 3600) / 60);
                const s = state.timeLeftSeconds % 60;
                el.innerText = `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
            }, 1000);
        }

        function highlight(idx) {
            document.querySelectorAll('.sentence-span').forEach((el, i) => {
                el.classList.toggle('sentence-active', i === idx);
            });
            // Scroll only once at the start, not during reading
            if (idx === 0) {
                const el = document.getElementById(`s-${idx}`);
                if (el) el.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        function animateWords(sIdx) {
            const words = state.sentences[sIdx].split(/\s+/);
            const duration = state.currentAudio.duration || 2;
            const step = (duration * 1000) / words.length;
            let w = 0;
            const iv = setInterval(() => {
                if (!state.isPlaying || w >= words.length) { clearInterval(iv); return; }
                document.querySelectorAll('.word-active').forEach(e => e.classList.remove('word-active'));
                const el = document.getElementById(`s-${sIdx}-w-${w}`);
                if (el) {
                    el.classList.add('word-active');
                    document.getElementById('current-word').innerText = words[w];
                }
                w++;
            }, step);
        }

        function applyScore(type) {
            const track = SCORE_LIBRARY[type] || SCORE_LIBRARY.dramatic;
            if (state.music.src !== track.url) {
                state.music.src = track.url;
                state.music.loop = true;
                state.music.play().catch(err => console.error('Music playback error:', err));
            }
            const badge = document.getElementById('vibe-badge');
            badge.innerText = `Atmosphere: ${track.name}`;
            badge.classList.remove('opacity-0');
            document.getElementById('music-status').innerText = track.name;
            document.getElementById('genre-icon').innerText = track.icon;
        }

        async function applyIntelligentScore(proseText, suggestedType) {
            // Analyze prose content to intelligently select music
            const lowerText = proseText.toLowerCase();
            const scores = {};
            
            // Calculate score for each music type based on keyword matching
            for (const [key, track] of Object.entries(SCORE_LIBRARY)) {
                let score = 0;
                for (const keyword of track.keywords) {
                    // Escape special regex characters to prevent injection
                    const escapedKeyword = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(`\\b${escapedKeyword}\\w*\\b`, 'gi');
                    const matches = lowerText.match(regex);
                    score += matches ? matches.length : 0;
                }
                scores[key] = score;
            }
            
            // Find the music type with highest score
            let bestMatch = suggestedType;
            let highestScore = scores[suggestedType] || 0;
            
            for (const [key, score] of Object.entries(scores)) {
                if (score > highestScore) {
                    highestScore = score;
                    bestMatch = key;
                }
            }
            
            // Only change music if we found a strong match (at least MUSIC_SELECTION_MIN_SCORE keyword occurrences)
            // or if this is the first chapter
            if (highestScore >= MUSIC_SELECTION_MIN_SCORE || state.currentMood === null) {
                state.currentMood = bestMatch;
                
                // Try Spotify first if logged in
                if (state.spotifyAccessToken) {
                    const track = await searchSpotifyTracks(bestMatch, state.genre);
                    if (track) {
                        const success = await playSpotifyTrack(track);
                        if (success) {
                            console.log(`Intelligent music selection (Spotify): ${track.name} for mood ${bestMatch} (score: ${highestScore}, suggested: ${suggestedType})`);
                            return;
                        }
                    }
                }
                
                // Fallback to default music
                applyScore(bestMatch);
                console.log(`Intelligent music selection: ${bestMatch} (score: ${highestScore}, suggested: ${suggestedType})`);
            } else {
                // Fall back to suggested type if analysis is weak
                state.currentMood = suggestedType;
                
                // Try Spotify first if logged in
                if (state.spotifyAccessToken) {
                    const track = await searchSpotifyTracks(suggestedType, state.genre);
                    if (track) {
                        const success = await playSpotifyTrack(track);
                        if (success) {
                            console.log(`Using suggested music (Spotify): ${track.name} for ${suggestedType} (analysis score too low: ${highestScore})`);
                            return;
                        }
                    }
                }
                
                // Fallback to default music
                applyScore(suggestedType);
                console.log(`Using suggested music: ${suggestedType} (analysis score too low: ${highestScore})`);
            }
        }

        async function preGenerateChapterImages(chapterData) {
            // Generate images for key visual moments before chapter reading begins
            const visualMoments = chapterData.key_visual_moments || [];
            
            if (visualMoments.length === 0) {
                // Fallback: generate images based on chapter content
                const sentences = chapterData.prose.match(/[^.!?]+[.!?]+(?=\s|$)/g) || [];
                // Generate images for every 4 sentences
                for (let i = 0; i < sentences.length; i += 4) {
                    const context = sentences.slice(i, Math.min(i + 4, sentences.length)).join(' ');
                    visualMoments.push(context);
                }
            }
            
            // Pre-generate first image immediately for display
            if (visualMoments.length > 0) {
                const startIdx = state.chapterStartIndex;
                await generateAndCacheImage(startIdx, visualMoments[0]);
                
                // Display the first image immediately since chapter will start from here
                if (state.imageCache.has(startIdx)) {
                    displayCachedImage(startIdx);
                }
                
                // Queue remaining images for background generation
                for (let i = 1; i < visualMoments.length; i++) {
                    const sentenceIdx = startIdx + (i * 4);
                    state.imageQueue.push({
                        index: sentenceIdx,
                        prompt: visualMoments[i]
                    });
                }
                
                // Start background image generation (don't await to avoid blocking)
                // Check if queue processing is already running to prevent race conditions
                if (!state.isProcessingImageQueue) {
                    processImageQueue();
                }
            }
        }

        async function generateAndCacheImage(sentenceIdx, promptText) {
            if (state.imageCache.has(sentenceIdx)) return;
            
            try {
                const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/imagen-4.0-generate-001:predict?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        instances: [{ 
                            prompt: `Cinematic professional fantasy art, atmospheric, ${state.genre} style: ${promptText}` 
                        }] 
                    })
                });
                const data = await res.json();
                
                // Validate response structure before accessing nested properties
                if (!data || !data.predictions || !data.predictions[0] || !data.predictions[0].bytesBase64Encoded) {
                    throw new Error('Invalid API response structure: missing image data');
                }
                
                const imageData = `data:image/png;base64,${data.predictions[0].bytesBase64Encoded}`;
                state.imageCache.set(sentenceIdx, imageData);
                console.log(`Pre-generated image for sentence ${sentenceIdx}`);
            } catch (err) {
                console.error(`Failed to pre-generate image for sentence ${sentenceIdx}:`, err);
            }
        }

        async function processImageQueue() {
            // Prevent multiple concurrent queue processing
            if (state.isProcessingImageQueue) return;
            state.isProcessingImageQueue = true;
            
            try {
                // Process queued images in background, one at a time
                while (state.imageQueue.length > 0) {
                    const { index, prompt } = state.imageQueue.shift();
                    await generateAndCacheImage(index, prompt);
                    // Small delay to avoid overwhelming the API
                    await new Promise(resolve => setTimeout(resolve, IMAGE_QUEUE_DELAY_MS));
                }
            } finally {
                state.isProcessingImageQueue = false;
            }
        }

        function displayCachedImage(sentenceIdx) {
            if (!state.imageCache.has(sentenceIdx)) return;
            
            const img = document.getElementById('scene-image');
            const overlay = document.getElementById('img-overlay');
            
            img.src = state.imageCache.get(sentenceIdx);
            img.onload = () => {
                img.classList.remove('opacity-0');
                overlay.classList.add('opacity-0');
            };
            
            state.lastImageIndex = sentenceIdx;
            console.log(`Displayed cached image for sentence ${sentenceIdx}`);
        }

        async function preloadAudio(idx) {
            if (idx >= state.sentences.length || state.audioBuffer.has(idx)) return;
            const b = await fetchTTS(state.sentences[idx]);
            state.audioBuffer.set(idx, b);
        }

        function preloadNextSentences(currentIdx, count) {
            for (let i = 1; i <= count; i++) {
                const nextIdx = currentIdx + i;
                if (!state.audioBuffer.has(nextIdx)) {
                    preloadAudio(nextIdx).catch(err => console.error('Preload error:', err));
                }
            }
        }

        function togglePlayback() {
            state.isPlaying = !state.isPlaying;
            document.getElementById('icon-play').classList.toggle('hidden', state.isPlaying);
            document.getElementById('icon-pause').classList.toggle('hidden', !state.isPlaying);
            if (state.isPlaying) { 
                state.music.play().catch(err => console.error('Music playback error:', err)); 
                playCycle().catch(err => console.error('Playback cycle error:', err)); 
            } 
            else { state.currentAudio.pause(); state.music.pause(); }
        }

        function stopPlayback() {
            // Stop playback
            state.isPlaying = false;
            state.currentAudio.pause();
            state.music.pause();
            
            // Update UI to ensure consistency even if already stopped
            document.getElementById('icon-play').classList.remove('hidden');
            document.getElementById('icon-pause').classList.add('hidden');
            
            // Clear word highlighting
            document.querySelectorAll('.word-active').forEach(e => e.classList.remove('word-active'));
            document.getElementById('current-word').innerText = '...';
        }

        function restartPlayback() {
            // Stop current playback
            stopPlayback();
            
            // Reset to beginning
            state.currentIndex = 0;
            
            // Clear all highlighting
            document.querySelectorAll('.sentence-span').forEach(el => {
                el.classList.remove('sentence-active');
            });
            document.querySelectorAll('.word-active').forEach(e => e.classList.remove('word-active'));
            
            // Scroll to top
            const firstSentence = document.getElementById('s-0');
            if (firstSentence) {
                firstSentence.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
            
            // Start playing from beginning
            setTimeout(() => {
                togglePlayback();
            }, RESTART_PLAYBACK_DELAY_MS);
        }

        async function changeVoice(selectedVoice) {
            const wasPlaying = state.isPlaying;
            const currentPosition = state.currentIndex;
            
            // Pause playback if currently playing
            if (wasPlaying) {
                state.isPlaying = false;
                state.currentAudio.pause();
            }
            
            // Update voice configuration
            const voiceConfig = VOICES[selectedVoice];
            if (!voiceConfig) {
                console.error('Invalid voice selection:', selectedVoice);
                return;
            }
            
            state.voice = voiceConfig.name;
            state.accent = voiceConfig.accent;
            
            // Clear audio buffer to force regeneration with new voice
            state.audioBuffer.clear();
            
            // Update both voice selectors to stay in sync
            document.getElementById('voice-select').value = selectedVoice;
            document.getElementById('voice-select-reader').value = selectedVoice;
            
            // Preload next few sentences with new voice
            const preloadPromises = [];
            for (let i = currentPosition; i < Math.min(currentPosition + 3, state.sentences.length); i++) {
                preloadPromises.push(preloadAudio(i));
            }
            await Promise.all(preloadPromises);
            
            // Resume playback if it was playing before
            if (wasPlaying) {
                state.isPlaying = true;
                playCycle().catch(err => console.error('Playback cycle error:', err));
                state.music.play().catch(err => console.error('Music playback error:', err));
            }
        }

        function switchView(v) {
            document.getElementById('view-home').classList.toggle('hidden', v !== 'home');
            document.getElementById('view-reader').classList.toggle('hidden', v !== 'reader');
            document.getElementById('control-panel').classList.toggle('hidden', v !== 'reader');
        }

        window.onload = () => {
            const vs = document.getElementById('voice-select');
            const vsReader = document.getElementById('voice-select-reader');
            Object.keys(VOICES).forEach(label => {
                const o = document.createElement('option');
                o.value = label;
                o.textContent = label;
                vs.appendChild(o);
                
                // Also populate reader voice selector
                const oReader = document.createElement('option');
                oReader.value = label;
                oReader.textContent = label;
                vsReader.appendChild(oReader);
            });
            
            // Connect music volume control
            const DEFAULT_VOLUME = 0.15;
            const MAX_VOLUME = 0.5;
            const validateVolume = (value) => {
                const vol = parseFloat(value);
                return isNaN(vol) ? DEFAULT_VOLUME : Math.max(0, Math.min(MAX_VOLUME, vol));
            };
            
            const volControl = document.getElementById('music-vol');
            if (volControl) {
                state.music.volume = validateVolume(volControl.value);
                volControl.addEventListener('input', (e) => {
                    state.music.volume = validateVolume(e.target.value);
                });
            } else {
                state.music.volume = DEFAULT_VOLUME;
            }
            
            // Initialize Spotify
            handleSpotifyCallback();
            restoreSpotifySession();
        };
    </script>
</body>

</html>
