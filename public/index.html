<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- Content Security Policy: Allows reCAPTCHA, Firebase, Spotify, and generative AI endpoints.
         IMPORTANT: 'unsafe-eval' required for Spotify SDK. 'unsafe-inline' for inline scripts.
         Update server-side CSP headers to match if deployed with additional security layers. -->
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self';
        script-src 'self' 'unsafe-inline' 'unsafe-eval' 
            https://cdn.tailwindcss.com 
            https://sdk.scdn.co 
            https://www.gstatic.com 
            https://www.google.com 
            https://www.google.com/recaptcha/ 
            https://www.gstatic.com/recaptcha/ 
            https://*.googletagmanager.com 
            https://accounts.scdn.co
            https://www.youtube.com;
        style-src 'self' 'unsafe-inline' 
            https://cdn.tailwindcss.com 
            https://fonts.googleapis.com;
        font-src 'self' 
            https://fonts.gstatic.com;
        img-src 'self' data: https: blob:;
        connect-src 'self' 
            https://accounts.spotify.com 
            https://api.spotify.com 
            https://firebasestorage.googleapis.com 
            https://*.googleapis.com
            https://generativelanguage.googleapis.com
            https://texttospeech.googleapis.com
            https://www.gstatic.com
            https://www.google.com;
        media-src 'self' https: blob:;
        frame-src https://accounts.spotify.com https://sdk.scdn.co https://www.youtube.com https://www.youtube-nocookie.com https://www.google.com https://recaptcha.google.com https://www.google.com/recaptcha/;
    ">
    <title>Dreamweaver</title>
    <!-- Note: Tailwind CDN is used for development convenience. For production deployment,
         consider using Tailwind CLI or PostCSS plugin: https://tailwindcss.com/docs/installation -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,400;0,700;1,400&family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <script src="https://sdk.scdn.co/spotify-player.js"></script>
    
    <script>
       // ========================================================================
       // CONFIGURATION: Firebase & App Check (Client-Side Only)
       // ========================================================================
       // SECURITY NOTE: Never commit real Firebase API keys, reCAPTCHA site keys,
       // or generative API keys to version control.
       //
       // HOW TO CONFIGURE:
       // 1. Get your Firebase config from: Firebase Console > Project Settings > Your apps
       // 2. Get your reCAPTCHA site key from: https://www.google.com/recaptcha/admin
       // 3. Replace the empty strings below with your actual values
       // 4. For the Gemini API key, use: firebase functions:config:set genai.key="YOUR_KEY"
       //
       // See server/README.md for complete deployment instructions.
       
       // Replace with your Firebase project configuration (from Firebase Console)
       window.__firebase_config = JSON.stringify({
             apiKey: "AIzaSyBYfJeUOI-6o2Fc7HLbJsSG5G5oJNIu1YM",
             authDomain: "dreamweaver-10d8e.firebaseapp.com",
             projectId: "dreamweaver-10d8e",
             storageBucket: "dreamweaver-10d8e.firebasestorage.app",
             messagingSenderId: "58607480142",
             appId: "1:58607480142:web:d2502ca74a7b69e2bb021f",
             measurementId: "G-J9V0ZBQCEK"
       });

       // Replace with your reCAPTCHA Enterprise site key (from https://console.cloud.google.com/security/recaptcha)
       // IMPORTANT: This should be set at deploy/build time (e.g., via CI/CD secret replacement)
       // or left empty and provided by your Firebase Console App Check provider settings.
       // DO NOT commit actual secret keys to version control.
       window.__recaptcha_site_key = "";  // Your reCAPTCHA Enterprise site key here
    </script>
    
    <script>
       // ========================================================================
       // Dynamic reCAPTCHA Enterprise Script Loader
       // ========================================================================
       // This script dynamically injects the reCAPTCHA Enterprise script tag at runtime
       // using the key from window.__recaptcha_site_key. This approach:
       // 1. Avoids hard-coding keys in the HTML file
       // 2. Ensures the script is loaded before App Check initialization
       // 3. Provides helpful guidance when the key is missing
       //
       // HOW TO SECURELY PROVIDE THE KEY:
       // Option 1 (Recommended): Use Firebase-managed App Check provider
       //   - Go to Firebase Console > Build > App Check
       //   - Register your app and enable reCAPTCHA Enterprise
       //   - Firebase will manage the provider configuration automatically
       //
       // Option 2: Deploy-time secret replacement
       //   - Store the key as a CI/CD secret (GitHub Secrets, GitLab CI/CD variables, etc.)
       //   - Use a build/deploy script to replace the placeholder value at deploy time
       //   - Example: sed -i "s/YOUR_RECAPTCHA_KEY/${RECAPTCHA_KEY}/" public/index.html
       //
       // Option 3: Environment-specific configuration
       //   - Use different configuration files per environment (dev/staging/prod)
       //   - Load the appropriate config at build/deploy time
       //   - Keep config files out of version control (add to .gitignore)
       //
       // WHERE TO MANAGE THE KEY:
       // - Firebase Console: https://console.firebase.google.com > Project Settings > App Check
       // - Google Cloud Console: https://console.cloud.google.com > Security > reCAPTCHA Enterprise
       // - Enable reCAPTCHA Enterprise API and ensure billing is enabled for your project
       // - Add all your deployment domains (including localhost for testing) to the allowed domains list
       
       (function loadRecaptchaEnterprise() {
           const siteKey = window.__recaptcha_site_key;
           
           // Check if site key is missing or appears to be a placeholder
           const isMissingOrPlaceholder = !siteKey || 
               siteKey.trim() === '' || 
               siteKey === 'YOUR_RECAPTCHA_V3_SITE_KEY' ||
               siteKey === 'YOUR_RECAPTCHA_KEY';
           
           if (isMissingOrPlaceholder) {
               // Log developer guidance to console
               console.warn('‚ö†Ô∏è reCAPTCHA Enterprise site key is missing or invalid.');
               console.warn('');
               console.warn('To configure App Check with reCAPTCHA Enterprise:');
               console.warn('1. Go to Firebase Console > Build > App Check');
               console.warn('2. Register your web app and select "reCAPTCHA Enterprise" as the provider');
               console.warn('3. Follow the setup wizard to create/select a reCAPTCHA Enterprise key');
               console.warn('4. Enable reCAPTCHA Enterprise API in Google Cloud Console');
               console.warn('5. Add your domain(s) to the allowed domains list');
               console.warn('6. Update window.__recaptcha_site_key in index.html with your site key');
               console.warn('');
               console.warn('For secure deployment:');
               console.warn('- Use CI/CD secrets to inject the key at deploy time');
               console.warn('- Or use Firebase-managed App Check provider configuration');
               console.warn('- DO NOT commit secret keys to version control');
               console.warn('');
               console.warn('Learn more: https://firebase.google.com/docs/app-check/web/recaptcha-enterprise-provider');
               
               // Add visible developer debug banner (hidden from screen readers)
               const banner = document.createElement('div');
               banner.setAttribute('aria-hidden', 'true');
               banner.id = 'recaptcha-config-warning';
               banner.className = 'fixed top-4 left-1/2 -translate-x-1/2 max-w-2xl mx-auto z-50 px-4';
               banner.innerHTML = `
                   <div class="bg-orange-900/30 border border-orange-500/50 rounded-2xl p-4 backdrop-blur-sm">
                       <div class="flex items-start gap-3">
                           <svg class="w-6 h-6 text-orange-400 flex-shrink-0 mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                               <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>
                           </svg>
                           <div class="flex-1 min-w-0">
                               <h3 class="text-orange-400 font-bold text-sm mb-1">‚ö†Ô∏è Developer Notice: reCAPTCHA Key Missing</h3>
                               <p class="text-orange-200/80 text-xs leading-relaxed mb-2">
                                   The reCAPTCHA Enterprise site key is not configured. App Check will not function.
                               </p>
                               <div class="bg-slate-900/50 rounded-lg p-2 text-xs text-orange-100 space-y-1">
                                   <div class="font-bold text-orange-300">Setup Instructions:</div>
                                   <div>1. Firebase Console ‚Üí Build ‚Üí App Check</div>
                                   <div>2. Register app with reCAPTCHA Enterprise provider</div>
                                   <div>3. Enable reCAPTCHA Enterprise API & billing in Google Cloud</div>
                                   <div>4. Add deployment domains to allowed domains list</div>
                                   <div>5. Update window.__recaptcha_site_key in index.html</div>
                                   <div class="text-[10px] text-orange-200/60 mt-1">
                                       Check browser console for detailed guidance
                                   </div>
                               </div>
                           </div>
                           <button onclick="document.getElementById('recaptcha-config-warning').remove()" 
                                   class="text-orange-400 hover:text-orange-300 transition-colors p-1" 
                                   title="Dismiss warning">
                               <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                   <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                               </svg>
                           </button>
                       </div>
                   </div>
               `;
               
               // Insert banner after page loads
               if (document.body) {
                   document.body.insertBefore(banner, document.body.firstChild);
               } else {
                   window.addEventListener('DOMContentLoaded', function() {
                       document.body.insertBefore(banner, document.body.firstChild);
                   });
               }
               
               // Auto-dismiss banner after 12 seconds
               const BANNER_DISMISS_DELAY_MS = 12000; // 12 seconds
               setTimeout(function() {
                   if (document.getElementById('recaptcha-config-warning')) {
                       document.getElementById('recaptcha-config-warning').remove();
                   }
               }, BANNER_DISMISS_DELAY_MS);
               
               return; // Don't load the script if key is missing
           }
           
           // Key is present - dynamically inject the reCAPTCHA Enterprise script
           console.log('‚úì Loading reCAPTCHA Enterprise script with provided site key...');
           
           const script = document.createElement('script');
           script.src = `https://www.google.com/recaptcha/enterprise.js?render=${encodeURIComponent(siteKey)}`;
           script.async = true;
           script.defer = true;
           
           script.onload = function() {
               console.log('‚úì reCAPTCHA Enterprise script loaded successfully');
           };
           
           script.onerror = function() {
               console.error('‚ùå Failed to load reCAPTCHA Enterprise script');
               console.error('Possible causes:');
               console.error('  - Invalid site key');
               console.error('  - Domain not authorized in reCAPTCHA Enterprise console');
               console.error('  - Network connectivity issues');
               console.error('  - reCAPTCHA Enterprise API not enabled in Google Cloud');
               console.error('');
               console.error('Verify your configuration at:');
               console.error('  - Google Cloud Console > Security > reCAPTCHA Enterprise');
               console.error('  - Firebase Console > Build > App Check');
           };
           
           // Append to head
           document.head.appendChild(script);
       })();
       
       /**
        * Helper function to wait for reCAPTCHA Enterprise API to be ready
        * Checks for grecaptcha.enterprise.ready, grecaptcha.ready, and grecaptcha.enterprise.execute
        * 
        * @param {number} timeoutMs - Maximum time to wait in milliseconds (default: 10000)
        * @returns {Promise<boolean>} - Resolves to true when ready, false on timeout
        */
       window.__waitForReCaptchaEnterprise = function(timeoutMs) {
           // Configuration constants
           const DEFAULT_TIMEOUT_MS = 10000; // 10 seconds
           const POLL_INTERVAL_MS = 200; // Check every 200ms
           
           // Validate and sanitize timeout parameter
           timeoutMs = (typeof timeoutMs === 'number' && timeoutMs > 0 && isFinite(timeoutMs)) ? timeoutMs : DEFAULT_TIMEOUT_MS;
           const maxAttempts = timeoutMs / POLL_INTERVAL_MS;
           
           return new Promise((resolve) => {
               let attempts = 0;
               let resolved = false; // Flag to prevent multiple resolutions
               let timeoutId = null; // Track timeout to prevent race conditions
               
               const checkReady = () => {
                   // Clear any pending timeout to prevent race conditions
                   if (timeoutId) {
                       clearTimeout(timeoutId);
                       timeoutId = null;
                   }
                   
                   // Check multiple possible API shapes
                   if (typeof grecaptcha !== 'undefined' && typeof grecaptcha.enterprise !== 'undefined') {
                       // Check for grecaptcha.enterprise.ready
                       if (typeof grecaptcha.enterprise.ready === 'function') {
                           try {
                               grecaptcha.enterprise.ready(() => {
                                   if (!resolved) {
                                       resolved = true;
                                       resolve(true);
                                   }
                               });
                           } catch (e) {
                               console.warn('Error calling grecaptcha.enterprise.ready:', e);
                               if (!resolved) {
                                   resolved = true;
                                   resolve(false);
                               }
                           }
                           return;
                       }
                       // Check for grecaptcha.enterprise.execute (API is ready if execute exists)
                       if (typeof grecaptcha.enterprise.execute === 'function') {
                           if (!resolved) {
                               resolved = true;
                               resolve(true);
                           }
                           return;
                       }
                   }
                   
                   // Check for standard grecaptcha.ready as fallback
                   if (typeof grecaptcha !== 'undefined' && typeof grecaptcha.ready === 'function') {
                       try {
                           grecaptcha.ready(() => {
                               if (!resolved) {
                                   resolved = true;
                                   resolve(true);
                               }
                           });
                       } catch (e) {
                           console.warn('Error calling grecaptcha.ready:', e);
                           if (!resolved) {
                               resolved = true;
                               resolve(false);
                           }
                       }
                       return;
                   }
                   
                   // Not ready yet, try again if we haven't exceeded max attempts
                   attempts++;
                   if (attempts < maxAttempts) {
                       timeoutId = setTimeout(checkReady, POLL_INTERVAL_MS);
                   } else {
                       // Timeout - resolve false
                       if (!resolved) {
                           resolved = true;
                           resolve(false);
                       }
                   }
               };
               
               checkReady();
           });
       };
    </script>
    
    <!-- Firebase + App Check initialization module -->
    <script src="/init-firebase.js" type="module"></script>
    
    <script>
        // Spotify Configuration
        // IMPORTANT: Replace SPOTIFY_CLIENT_ID with your actual Spotify Client ID from https://developer.spotify.com/dashboard
        // This is a placeholder value and must be updated for Spotify integration to work
        const SPOTIFY_CLIENT_ID = '5c1a5a8a8f4d4f1f9c3e9e5c0c3e0c3e'; // Replace with your Spotify Client ID
        const SPOTIFY_REDIRECT_URI = window.location.origin + window.location.pathname;
        const SPOTIFY_SCOPES = 'streaming user-read-email user-read-private user-modify-playback-state user-read-playback-state';
        
        window.spotify = {
            clientId: SPOTIFY_CLIENT_ID,
            redirectUri: SPOTIFY_REDIRECT_URI,
            scopes: SPOTIFY_SCOPES
        };
        
        // Define Spotify Web Playback SDK callback
        // This function is called when the Spotify SDK is ready
        window.onSpotifyWebPlaybackSDKReady = () => {
            console.log('Spotify Web Playback SDK is ready');
            // Player initialization will be handled when user logs in
        };
    </script>

    <style>
        :root { --bg-deep: #020617; --accent: #6366f1; --text-main: #e2e8f0; }
        body { background-color: var(--bg-deep); color: var(--text-main); font-family: 'Inter', sans-serif; overflow-x: hidden; position: relative; }
        .novel-font { font-family: 'Crimson Pro', serif; }
        .glass { background: rgba(15, 23, 42, 0.8); backdrop-filter: blur(16px); border: 1px solid rgba(255,255,255,0.08); }
        .tab-active { background: var(--accent); color: white; }
        
        .sentence-span { transition: opacity 0.3s ease; opacity: 0.3; cursor: pointer; display: inline; }
        .sentence-active { opacity: 1 !important; color: #1a1a1a !important; font-weight: 500; }
        
        .word-token { display: inline; padding: 0; transition: all 0.15s ease; }
        .word-active { background-color: #3b82f6 !important; color: white !important; padding: 2px 4px; border-radius: 4px; }

        .image-container { 
            position: sticky; top: 2rem; width: 100%; aspect-ratio: 1/1; 
            border-radius: 2rem; overflow: hidden; background: #0f172a; 
            border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }
        .image-container img { width: 100%; height: 100%; object-fit: cover; transition: opacity 1.5s ease; }
        
        .timer-glow { text-shadow: 0 0 10px rgba(99, 102, 241, 0.5); }
        
        /* Sleepy starfield background */
        .starfield {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            background: linear-gradient(to bottom, #020617 0%, #0f172a 50%, #1e1b4b 100%);
            overflow: hidden;
        }
        
        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle linear infinite;
        }
        
        @keyframes twinkle {
            0%, 100% { opacity: 0.2; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }
        
        /* Predefined animation classes for better performance */
        .star-slow { animation-duration: 8s; }
        .star-medium { animation-duration: 5s; }
        .star-fast { animation-duration: 3s; }
        .star-delay-1 { animation-delay: 0s; }
        .star-delay-2 { animation-delay: 1s; }
        .star-delay-3 { animation-delay: 2s; }
        .star-delay-4 { animation-delay: 3s; }
        .star-size-small { width: 1px; height: 1px; }
        .star-size-medium { width: 2px; height: 2px; }
        .star-size-large { width: 3px; height: 3px; }
        
        .shoot-slow { animation-duration: 5s; }
        .shoot-medium { animation-duration: 3.5s; }
        .shoot-fast { animation-duration: 2s; }
        .shoot-delay-1 { animation-delay: 0s; }
        .shoot-delay-2 { animation-delay: 3s; }
        .shoot-delay-3 { animation-delay: 6s; }
        .shoot-delay-4 { animation-delay: 9s; }
        .shoot-delay-5 { animation-delay: 12s; }
        .shoot-width-small { width: 50px; }
        .shoot-width-medium { width: 100px; }
        .shoot-width-large { width: 150px; }
        
        .shooting-star {
            position: absolute;
            height: 2px;
            background: linear-gradient(to right, rgba(255, 255, 255, 0), rgba(255, 255, 255, 1), rgba(255, 255, 255, 0));
            animation: shoot linear infinite;
            opacity: 0;
        }
        
        @keyframes shoot {
            0% { opacity: 0; transform: translateX(-10vw) translateY(-10vh); }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { opacity: 0; transform: translateX(100vw) translateY(100vh); }
        }
        
        .moon {
            position: fixed;
            top: 5%;
            right: 5%;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: linear-gradient(135deg, #fef9e7 0%, #f7dc6f 50%, #f4d03f 100%);
            box-shadow: 0 0 60px rgba(247, 220, 111, 0.6), 
                        inset -20px -20px 40px rgba(0, 0, 0, 0.1);
            z-index: 5;
            animation: moon-glow 4s ease-in-out infinite;
        }
        
        @keyframes moon-glow {
            0%, 100% { box-shadow: 0 0 60px rgba(247, 220, 111, 0.6), inset -20px -20px 40px rgba(0, 0, 0, 0.1); }
            50% { box-shadow: 0 0 80px rgba(247, 220, 111, 0.8), inset -20px -20px 40px rgba(0, 0, 0, 0.1); }
        }
        
        /* Ensure content stays above background */
        #app {
            position: relative;
            z-index: 10;
        }
    </style>
</head>
<body class="selection:bg-indigo-500/30">
    <!-- Starfield background -->
    <div class="starfield" id="starfield"></div>
    <div class="moon"></div>
    
    <div id="app" class="relative z-10 min-h-screen flex flex-col">
        <nav class="flex items-center justify-between p-6 max-w-7xl mx-auto w-full">
            <div class="flex items-center gap-3">
                <div class="w-10 h-10 bg-indigo-600 rounded-xl flex items-center justify-center shadow-lg shadow-indigo-500/20">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg>
                </div>
                <h1 class="text-xl font-black tracking-tighter uppercase">Dream<span class="text-indigo-500">weaver</span></h1>
            </div>
            
            <div class="flex items-center gap-4">
                <!-- Debug Mode Indicator (visible when debug=true in URL) -->
                <a id="debug-link" href="debug.html" class="hidden glass px-4 py-2 rounded-full border border-yellow-500/30 text-yellow-400 text-xs font-bold hover:bg-yellow-500/10 transition-colors" title="Access debug and testing area">
                    üîß Debug
                </a>
                
                <div id="session-timer" class="hidden glass px-6 py-2 rounded-full border border-indigo-500/30 font-mono text-indigo-400 font-bold timer-glow" title="Time remaining in your story session. Story generation stops when timer reaches zero">
                    00:00:00
                </div>
            </div>
        </nav>

        <!-- File Protocol Warning Banner -->
        <div id="file-protocol-warning" class="hidden mx-auto max-w-7xl px-6 mb-4">
            <div class="bg-yellow-900/30 border border-yellow-500/50 rounded-2xl p-4 backdrop-blur-sm">
                <div class="flex items-start gap-3">
                    <svg class="w-6 h-6 text-yellow-400 flex-shrink-0 mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>
                    </svg>
                    <div class="flex-1 min-w-0">
                        <h3 class="text-yellow-400 font-bold text-sm mb-1">‚ö†Ô∏è Running from file:// protocol</h3>
                        <p class="text-yellow-200/80 text-xs leading-relaxed mb-2">
                            You're opening this app directly from your filesystem. This can cause issues with:
                            Spotify SDK postMessage origins, YouTube IFrame API, API CORS restrictions, and OAuth redirects.
                        </p>
                        <div class="bg-slate-900/50 rounded-lg p-2 font-mono text-xs text-yellow-100">
                            <div class="text-yellow-400 font-bold mb-1">Recommended: Serve over HTTP</div>
                            <div class="text-slate-300">python -m http.server 8000</div>
                            <div class="text-slate-400 text-[10px] mt-1">Then visit: http://localhost:8000/index.html</div>
                        </div>
                    </div>
                    <button onclick="document.getElementById('file-protocol-warning').classList.add('hidden')" 
                            class="text-yellow-400 hover:text-yellow-300 transition-colors p-1" 
                            title="Dismiss warning">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                        </svg>
                    </button>
                </div>
            </div>
        </div>

        <!-- Setup Screen -->
        <main id="view-home" class="flex-1 max-w-3xl mx-auto px-6 py-12 w-full">
            <div class="glass rounded-[2.5rem] p-10 space-y-10 shadow-2xl border border-white/5">
                <div class="space-y-4">
                    <h2 class="text-4xl font-black tracking-tight">Welcome to Dreamweaver</h2>
                    <p class="text-slate-400 text-sm">Tell me what story you'd like to hear, and I'll weave it for you.</p>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                    <!-- Narrator Selection -->
                    <div class="space-y-2">
                        <label class="text-indigo-400 text-[11px] font-black uppercase tracking-widest ml-1">Narrator Voice</label>
                        <select id="voice-select" class="w-full bg-slate-900 border border-white/10 rounded-2xl p-4 text-white appearance-none cursor-pointer hover:bg-slate-800 transition-colors" title="Choose from 8 different voice personas with varied accents to narrate your story"></select>
                    </div>

                    <!-- Session Length (Restored & Enhanced) -->
                    <div class="space-y-2">
                        <label class="text-indigo-400 text-[11px] font-black uppercase tracking-widest ml-1">Session Duration</label>
                        <select id="length-select" class="w-full bg-slate-900 border border-white/10 rounded-2xl p-4 text-white appearance-none cursor-pointer" title="Set how long you want the story to continue (AI will generate chapters to fill this time)">
                            <option value="5">5 Minutes</option>
                            <option value="30">30 Minutes</option>
                            <option value="60">1 Hour</option>
                            <option value="120">2 Hours</option>
                        </select>
                    </div>

                    <div class="space-y-2">
                        <label class="text-indigo-400 text-[11px] font-black uppercase tracking-widest ml-1">Narrative Genre</label>
                        <select id="genre-select" class="w-full bg-slate-900 border border-white/10 rounded-2xl p-4 text-white appearance-none cursor-pointer" title="Select the genre that will shape the story's theme, style, and atmosphere">
                            <option value="Fantasy">Fantasy</option>
                            <option value="Sci-Fi">Sci-Fi</option>
                            <option value="Mystery">Mystery</option>
                            <option value="Horror">Horror</option>
                            <option value="Drama">Historical Drama</option>
                        </select>
                    </div>

                    <!-- Intelligent Score -->
                    <div class="space-y-2">
                        <label class="text-indigo-400 text-[11px] font-black uppercase tracking-widest ml-1">Score Dynamics</label>
                        <div class="flex items-center gap-4 bg-slate-900 border border-white/10 rounded-2xl p-4">
                            <span class="text-[10px] text-slate-500 uppercase font-bold">Static</span>
                            <input type="range" id="score-sensitivity" class="flex-1 accent-indigo-500" min="1" max="5" value="3" title="Control how dynamically the background music changes. Static = same music throughout, Fluid = music adapts to story mood">
                            <span class="text-[10px] text-slate-500 uppercase font-bold">Fluid</span>
                        </div>
                    </div>
                </div>
                
                <!-- Spotify Integration Section -->
                <div class="space-y-2 p-6 bg-slate-900/50 border border-indigo-500/20 rounded-2xl">
                    <div class="flex items-center justify-between">
                        <div class="space-y-1">
                            <label class="text-indigo-400 text-[11px] font-black uppercase tracking-widest">Music Source</label>
                            <p class="text-slate-400 text-xs">Connect Spotify for personalized music selection</p>
                        </div>
                        <div id="spotify-status" class="flex items-center gap-2">
                            <button id="spotify-login-btn" onclick="loginSpotify()" class="px-5 py-2 bg-green-600 hover:bg-green-500 rounded-xl font-bold text-sm transition-all active:scale-95 flex items-center gap-2" title="Log in with your Spotify account to access millions of songs for intelligent music selection based on story mood">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z"/></svg>
                                Connect Spotify
                            </button>
                            <div id="spotify-user-info" class="hidden flex items-center gap-3 bg-slate-800 border border-white/10 rounded-xl px-4 py-2">
                                <div class="flex items-center gap-2">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="#1DB954"><path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z"/></svg>
                                    <span id="spotify-username" class="text-sm font-bold text-white">User</span>
                                </div>
                                <button onclick="logoutSpotify()" class="text-xs text-slate-400 hover:text-white transition-colors" title="Disconnect your Spotify account and return to default music library">Disconnect</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Music Player Controls -->
                <div id="music-source-controls" class="space-y-2 p-6 bg-slate-900/50 border border-indigo-500/20 rounded-2xl">
                    <div class="space-y-3">
                        <label class="text-indigo-400 text-[11px] font-black uppercase tracking-widest">Background Music Player</label>
                        <div class="flex flex-wrap items-center gap-3">
                            <select id="music-source-select" aria-label="Music Source" class="bg-slate-900 border border-white/10 rounded-xl px-4 py-2 text-white text-sm appearance-none cursor-pointer hover:bg-slate-800 transition-colors" title="Choose where your background music comes from: Spotify (default library or connected account), Local Files (upload from your device), or YouTube (play audio from videos)">
                                <option value="spotify">Spotify</option>
                                <option value="local">Local Files</option>
                                <option value="youtube">YouTube</option>
                            </select>

                            <input id="local-files-input" type="file" accept="audio/*" multiple style="display:none;" class="text-sm text-slate-400 file:mr-4 file:py-2 file:px-4 file:rounded-xl file:border-0 file:text-sm file:font-semibold file:bg-indigo-600 file:text-white hover:file:bg-indigo-500" title="Upload audio files from your computer (MP3, OGG, etc.). Files play in sequence and are not saved across sessions" />
                            
                            <input id="youtube-url-input" type="text" placeholder="Paste YouTube URL or ID" style="display:none;" class="bg-slate-900 border border-white/10 rounded-xl px-4 py-2 text-white text-sm flex-1 min-w-[280px]" title="Paste a YouTube video URL or video ID to play its audio in the background. Note: YouTube may show ads and requires user interaction for autoplay" />
                            
                            <button id="youtube-load-btn" style="display:none;" class="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded-xl font-bold text-sm transition-all active:scale-95" title="Load the YouTube video for audio playback">Load</button>
                        </div>

                        <!-- Spotify Selected Display -->
                        <div id="spotify-track-info" style="display:none;" class="mt-3 p-3 bg-slate-800 border border-green-500/30 rounded-xl text-sm text-slate-300">
                            <div class="flex items-center gap-2 mb-1">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="#1DB954"><path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z"/></svg>
                                <span class="font-bold text-white">Spotify Selected</span>
                            </div>
                            <div class="text-xs text-slate-400">Default music library will be used (or connect Spotify for personalized selection)</div>
                        </div>

                        <!-- Local Files Display -->
                        <div id="local-track-list" class="space-y-1 text-sm text-slate-300"></div>
                        
                        <!-- YouTube Track Display -->
                        <div id="youtube-track-info" style="display:none;" class="mt-3 p-3 bg-slate-800 border border-red-500/30 rounded-xl text-sm text-slate-300">
                            <div class="flex items-center gap-2 mb-1">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="#FF0000"><path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/></svg>
                                <span class="font-bold text-white">YouTube Selected</span>
                            </div>
                            <div id="youtube-track-name" class="text-xs text-slate-400">No video loaded yet. Paste a YouTube URL above and click Load.</div>
                        </div>
                    </div>
                </div>
                
                <!-- Playlist Management Section -->
                <div id="playlist-controls" class="space-y-2 p-6 bg-slate-900/50 border border-indigo-500/20 rounded-2xl">
                    <div class="space-y-3">
                        <!-- Enhanced Header with Tally -->
                        <div class="flex items-center justify-between mb-2">
                            <div class="flex items-center gap-3">
                                <div class="w-10 h-10 bg-indigo-500/20 rounded-xl flex items-center justify-center text-indigo-400">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                                        <path d="M9 18V5l12-2v13"></path>
                                        <circle cx="6" cy="18" r="3"></circle>
                                        <circle cx="18" cy="16" r="3"></circle>
                                    </svg>
                                </div>
                                <div>
                                    <label class="text-white font-black text-sm uppercase tracking-wider block">Playlist Manager</label>
                                    <p class="text-indigo-300 text-[10px]">Organize your music collection</p>
                                </div>
                            </div>
                            <button id="toggle-tally-btn" onclick="toggleTallyDisplay()" class="px-3 py-1 bg-slate-700 hover:bg-slate-600 rounded-lg font-bold text-xs transition-all active:scale-95 flex items-center gap-1" title="Toggle tally view to see collection statistics" aria-label="Toggle tally display">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                                    <path d="M3 3v18h18"></path>
                                    <path d="M18 17V9"></path>
                                    <path d="M13 17V5"></path>
                                    <path d="M8 17v-3"></path>
                                </svg>
                                <span id="tally-btn-text">Show Tally</span>
                            </button>
                        </div>
                        
                        <!-- Tally Display (hidden by default) -->
                        <div id="tally-display" class="hidden p-4 bg-gradient-to-r from-indigo-900/50 to-purple-900/50 border border-indigo-500/30 rounded-xl" role="region" aria-label="Playlist Statistics">
                            <div class="grid grid-cols-3 gap-4">
                                <div class="text-center">
                                    <div class="text-2xl font-black text-indigo-300" id="tally-total-playlists" aria-label="Total playlists">0</div>
                                    <div class="text-[10px] text-slate-400 uppercase tracking-wider mt-1">Playlists</div>
                                </div>
                                <div class="text-center">
                                    <div class="text-2xl font-black text-green-300" id="tally-total-items" aria-label="Total tracks across all playlists">0</div>
                                    <div class="text-[10px] text-slate-400 uppercase tracking-wider mt-1">Total Tracks</div>
                                </div>
                                <div class="text-center">
                                    <div class="text-2xl font-black text-purple-300" id="tally-current-items" aria-label="Items in current playlist">0</div>
                                    <div class="text-[10px] text-slate-400 uppercase tracking-wider mt-1">Current List</div>
                                </div>
                            </div>
                        </div>
                        
                        <p class="text-slate-400 text-xs">Create playlists to organize your music from Spotify, YouTube, and local files. Playlists are saved across sessions.</p>
                        
                        <div class="flex flex-wrap items-center gap-3">
                            <select id="playlist-select" class="bg-slate-900 border border-white/10 rounded-xl px-4 py-2 text-white text-sm appearance-none cursor-pointer hover:bg-slate-800 transition-colors flex-1 min-w-[200px]" title="Select a playlist to view and manage">
                                <option value="">Select a playlist...</option>
                            </select>
                            
                            <button id="create-playlist-btn" class="px-4 py-2 bg-green-600 hover:bg-green-500 rounded-xl font-bold text-sm transition-all active:scale-95 flex items-center gap-2" title="Create a new playlist">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                                New Playlist
                            </button>
                            
                            <button id="delete-playlist-btn" class="px-4 py-2 bg-red-600 hover:bg-red-500 rounded-xl font-bold text-sm transition-all active:scale-95" title="Delete the selected playlist" onclick="deleteCurrentPlaylist()">
                                Delete
                            </button>
                        </div>
                        
                        <!-- Add Current Track to Playlist -->
                        <div class="flex items-center gap-2 p-3 bg-slate-800/50 rounded-xl">
                            <span class="text-xs text-slate-400 flex-1">Add current track to playlist:</span>
                            <button id="add-current-to-playlist-btn" class="px-3 py-1 bg-indigo-600 hover:bg-indigo-500 rounded-lg font-bold text-xs transition-all active:scale-95" title="Add the current music source (Spotify track, YouTube video, or local file) to the selected playlist" onclick="addCurrentTrackToPlaylist()">
                                Add to Playlist
                            </button>
                        </div>
                        
                        <!-- Playlist Items Display -->
                        <div class="mt-3 p-3 bg-slate-800 border border-indigo-500/30 rounded-xl">
                            <div class="flex items-center justify-between mb-2">
                                <span class="text-xs font-bold text-white uppercase tracking-wider">Playlist Items</span>
                            </div>
                            <div id="playlist-items-container" class="space-y-1 max-h-[200px] overflow-y-auto">
                                <div class="text-xs text-slate-400">Select a playlist to view items</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="space-y-2">
                    <label class="text-indigo-400 text-[11px] font-black uppercase tracking-widest ml-1">Story Prompt</label>
                    <textarea id="prompt-input" class="w-full bg-slate-900 border border-white/10 rounded-3xl p-6 text-white h-40 focus:ring-2 ring-indigo-500 outline-none resize-none text-lg leading-relaxed" placeholder="What story would you like to hear? Describe your characters, setting, or adventure..." title="Describe the story you want to experience. AI will generate a narrative based on your prompt, continuing for the selected duration"></textarea>
                </div>

                <button id="start-btn" onclick="initiateSession()" class="w-full py-6 bg-indigo-600 rounded-2xl font-black text-xl shadow-xl hover:bg-indigo-500 transition-all active:scale-[0.98] uppercase tracking-widest" title="Start your AI-generated story experience with narration, images, and music">
                    Begin Story
                </button>
            </div>
        </main>

        <!-- Reader Screen -->
        <main id="view-reader" class="hidden flex-1 max-w-7xl mx-auto px-4 py-6 w-full pb-48">
            <div class="grid grid-cols-1 lg:grid-cols-12 gap-10">
                <div class="lg:col-span-7 bg-[#fafaf9] text-[#1c1917] novel-font rounded-[3rem] shadow-2xl flex flex-col min-h-[85vh] border border-stone-200 overflow-hidden">
                    <div id="scroll-target" class="p-12 md:p-20 flex-1 overflow-y-auto">
                        <div id="vibe-badge" class="inline-block px-4 py-1 rounded-full bg-indigo-100 text-indigo-700 text-[10px] font-black uppercase tracking-widest mb-6 transition-all opacity-0">...</div>
                        <h1 id="reader-title" class="text-5xl font-bold mb-10 tracking-tight text-stone-900 italic">Initializing...</h1>
                        <div id="reader-content" class="text-[24px] md:text-[28px] leading-[1.7] text-stone-700 space-y-8"></div>
                    </div>
                </div>

                <div class="lg:col-span-5 space-y-8">
                    <div class="image-container">
                        <div id="img-overlay" class="absolute inset-0 bg-black/60 flex flex-col items-center justify-center opacity-0 transition-opacity z-10 backdrop-blur-sm">
                            <div class="w-10 h-10 border-2 border-white/20 border-t-white rounded-full animate-spin mb-3"></div>
                            <span class="text-[10px] font-bold text-white uppercase tracking-widest">Generating Scene</span>
                        </div>
                        <img id="scene-image" src="" class="opacity-0">
                    </div>
                    
                    <!-- Session Settings Summary -->
                    <div class="glass p-6 rounded-[2.5rem] space-y-4">
                        <div class="flex items-center justify-between mb-2">
                            <div class="flex items-center gap-3">
                                <div class="w-10 h-10 bg-indigo-500/20 rounded-xl flex items-center justify-center text-indigo-400">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <circle cx="12" cy="12" r="3"></circle>
                                        <path d="M12 1v6m0 6v6m-5.2-13A9 9 0 0 0 3 12c0 2.3.8 4.4 2.2 6M18.8 6A9 9 0 0 1 21 12c0 2.3-.8 4.4-2.2 6M3.3 17A9 9 0 0 0 12 21a9 9 0 0 0 8.7-4"></path>
                                    </svg>
                                </div>
                                <div>
                                    <p class="text-white font-black text-sm uppercase tracking-wider">Session Settings</p>
                                    <p class="text-slate-400 text-[10px]">Active configuration</p>
                                </div>
                            </div>
                            <button onclick="openSettingsModal()" class="w-8 h-8 bg-slate-700 hover:bg-slate-600 rounded-lg flex items-center justify-center transition-colors" title="Open full settings">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M9 18l6-6-6-6"></path>
                                </svg>
                            </button>
                        </div>
                        
                        <div class="grid grid-cols-2 gap-3">
                            <!-- Genre -->
                            <div class="bg-slate-800/50 rounded-xl p-3">
                                <label class="text-indigo-400 text-[9px] font-bold uppercase tracking-wider block mb-1">Genre</label>
                                <p id="display-genre" class="text-white text-sm font-bold truncate">Fantasy</p>
                            </div>
                            
                            <!-- Session Duration -->
                            <div class="bg-slate-800/50 rounded-xl p-3">
                                <label class="text-indigo-400 text-[9px] font-bold uppercase tracking-wider block mb-1">Duration</label>
                                <p id="display-duration" class="text-white text-sm font-bold truncate">30 Minutes</p>
                            </div>
                            
                            <!-- Score Dynamics -->
                            <div class="bg-slate-800/50 rounded-xl p-3">
                                <label class="text-indigo-400 text-[9px] font-bold uppercase tracking-wider block mb-1">Score Dynamics</label>
                                <div class="flex items-center gap-2">
                                    <div class="flex-1 flex gap-0.5">
                                        <div id="dynamics-bar-1" class="flex-1 h-2 rounded-sm bg-indigo-500"></div>
                                        <div id="dynamics-bar-2" class="flex-1 h-2 rounded-sm bg-indigo-500"></div>
                                        <div id="dynamics-bar-3" class="flex-1 h-2 rounded-sm bg-indigo-500"></div>
                                        <div id="dynamics-bar-4" class="flex-1 h-2 rounded-sm bg-slate-600"></div>
                                        <div id="dynamics-bar-5" class="flex-1 h-2 rounded-sm bg-slate-600"></div>
                                    </div>
                                    <span id="display-dynamics" class="text-white text-xs font-bold">3/5</span>
                                </div>
                            </div>
                            
                            <!-- Music Source -->
                            <div class="bg-slate-800/50 rounded-xl p-3">
                                <label class="text-indigo-400 text-[9px] font-bold uppercase tracking-wider block mb-1">Music Source</label>
                                <p id="display-music-source" class="text-white text-sm font-bold truncate">Spotify</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="glass p-8 rounded-[2.5rem] space-y-6">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center gap-4">
                                <div class="w-12 h-12 bg-indigo-500/20 rounded-2xl flex items-center justify-center text-indigo-400">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle></svg>
                                </div>
                                <div class="flex-1 min-w-0">
                                    <p class="text-white font-black text-sm uppercase tracking-wider">Dynamic Score</p>
                                    <p id="music-status" class="text-indigo-300 text-xs truncate">Analyzing Prose...</p>
                                    <p id="music-source-display" class="text-slate-400 text-[10px] mt-1">Source: Default</p>
                                </div>
                            </div>
                            <div id="genre-icon" class="text-2xl">‚ú®</div>
                        </div>
                        <div class="space-y-2">
                            <label class="text-indigo-400 text-[10px] font-bold uppercase tracking-wider">Music Volume</label>
                            <input type="range" id="music-vol" min="0" max="0.5" step="0.01" value="0.15" class="w-full accent-indigo-500" title="Adjust the volume of the background music independently from the narrator">
                        </div>
                        
                        <div class="space-y-2">
                            <label class="text-indigo-400 text-[10px] font-bold uppercase tracking-wider">Narrator Volume</label>
                            <input type="range" id="narrator-vol" min="0" max="1" step="0.05" value="1" class="w-full accent-indigo-500" title="Adjust the volume of the narrator's voice independently from the music">
                        </div>
                        
                        <!-- Change Song Button -->
                        <button id="change-song-btn" onclick="changeSong()" class="w-full py-3 bg-slate-700 hover:bg-slate-600 rounded-2xl font-bold text-sm transition-all active:scale-95 flex items-center justify-center gap-2" title="Switch to a different track while maintaining the same mood and genre (uses Spotify when connected, otherwise cycles through default library)">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 4v6h6M23 20v-6h-6"></path><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path></svg>
                            Change Song
                        </button>
                        
                        <!-- Music Playback Controls -->
                        <div class="grid grid-cols-3 gap-2 mt-3">
                            <button onclick="musicPrev()" class="py-2 bg-slate-700 hover:bg-slate-600 rounded-xl font-bold text-xs transition-all active:scale-95 flex items-center justify-center gap-1" title="Previous track in playlist or queue">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"></path></svg>
                                Prev
                            </button>
                            <button onclick="musicReplay()" class="py-2 bg-slate-700 hover:bg-slate-600 rounded-xl font-bold text-xs transition-all active:scale-95 flex items-center justify-center gap-1" title="Replay current track from the beginning">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"></path></svg>
                                Replay
                            </button>
                            <button onclick="musicNext()" class="py-2 bg-slate-700 hover:bg-slate-600 rounded-xl font-bold text-xs transition-all active:scale-95 flex items-center justify-center gap-1" title="Next track in playlist or queue">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M16 18h2V6h-2zm-11-7l8.5-6v12z"></path></svg>
                                Next
                            </button>
                        </div>
                        
                        <!-- Active Playlist Display -->
                        <div id="reader-playlist-section" class="mt-4 space-y-2">
                            <div class="flex items-center justify-between">
                                <label class="text-indigo-400 text-[10px] font-bold uppercase tracking-wider">Active Playlist</label>
                                <button onclick="toggleReaderPlaylist()" class="text-indigo-400 hover:text-indigo-300 text-xs transition-colors" title="Show/hide playlist">
                                    <span id="playlist-toggle-icon">‚ñº</span>
                                </button>
                            </div>
                            <select id="reader-playlist-select" onchange="switchReaderPlaylist(this.value)" class="w-full bg-slate-800 border border-white/10 rounded-xl px-3 py-2 text-white text-xs appearance-none cursor-pointer hover:bg-slate-700 transition-colors" title="Select a playlist to play from">
                                <option value="">No Playlist (Manual Control)</option>
                            </select>
                            <div id="reader-playlist-items" class="hidden space-y-1 max-h-[200px] overflow-y-auto bg-slate-800/50 rounded-xl p-2">
                                <div class="text-xs text-slate-400 text-center py-2">No playlist selected</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <div id="control-panel" class="hidden fixed bottom-10 left-1/2 -translate-x-1/2 w-[90%] max-w-4xl glass rounded-[2.5rem] p-5 shadow-2xl z-50 border border-white/10">
            <div class="flex flex-col sm:flex-row items-center gap-4">
                <!-- Playback Controls -->
                <div class="flex items-center gap-3">
                    <button onclick="restartPlayback()" class="w-12 h-12 bg-slate-700 rounded-2xl flex items-center justify-center text-white shadow-lg hover:bg-slate-600 active:scale-95 transition-all" title="Restart story from the beginning">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"></path></svg>
                    </button>
                    <button onclick="togglePlayback()" class="w-16 h-16 bg-white rounded-3xl flex items-center justify-center text-indigo-900 shadow-xl hover:scale-105 active:scale-95 transition-all" title="Play or pause the story narration and music">
                        <svg id="icon-play" width="32" height="32" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"></path></svg>
                        <svg id="icon-pause" class="hidden" width="32" height="32" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg>
                    </button>
                    <button onclick="stopPlayback()" class="w-12 h-12 bg-slate-700 rounded-2xl flex items-center justify-center text-white shadow-lg hover:bg-slate-600 active:scale-95 transition-all" title="Stop playback and clear current progress">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="6" width="12" height="12"></rect></svg>
                    </button>
                </div>
                
                <!-- Current Word Display -->
                <div class="flex-1 overflow-hidden min-w-0">
                    <div class="text-[10px] font-black text-indigo-400 uppercase tracking-widest mb-1">Live Feed</div>
                    <div id="current-word" class="text-xl font-black text-white truncate italic">...</div>
                </div>
                
                <!-- Voice Selector -->
                <div class="flex items-center gap-3">
                    <div class="text-right">
                        <div class="text-[10px] font-black text-indigo-400 uppercase tracking-widest mb-1">Narrator</div>
                        <select id="voice-select-reader" onchange="changeVoice(this.value)" class="bg-slate-800 border border-white/10 rounded-xl px-4 py-2 text-white text-sm appearance-none cursor-pointer hover:bg-slate-700 transition-colors" title="Change the narrator's voice during playback. Audio will be regenerated with the new voice">
                        </select>
                    </div>
                    
                    <!-- Settings Button -->
                    <button onclick="openSettingsModal()" class="w-12 h-12 bg-slate-700 rounded-2xl flex items-center justify-center text-white shadow-lg hover:bg-slate-600 active:scale-95 transition-all" title="Open settings and options">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="3"></circle>
                            <path d="M12 1v6m0 6v6m-5.2-13A9 9 0 0 0 3 12c0 2.3.8 4.4 2.2 6M18.8 6A9 9 0 0 1 21 12c0 2.3-.8 4.4-2.2 6M3.3 17A9 9 0 0 0 12 21a9 9 0 0 0 8.7-4"></path>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Settings Modal -->
        <div id="settings-modal" class="hidden fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/70 backdrop-blur-sm">
            <div class="bg-slate-900 rounded-3xl shadow-2xl border border-white/10 max-w-4xl w-full max-h-[90vh] overflow-hidden flex flex-col">
                <!-- Modal Header -->
                <div class="flex items-center justify-between p-6 border-b border-white/10">
                    <h2 class="text-2xl font-black text-white">Settings & Options</h2>
                    <button onclick="closeSettingsModal()" class="w-10 h-10 rounded-xl bg-slate-800 hover:bg-slate-700 flex items-center justify-center transition-colors">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M18 6L6 18M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                
                <!-- Modal Content with Tabs -->
                <div class="flex-1 overflow-y-auto p-6">
                    <!-- Tab Navigation -->
                    <div class="flex gap-2 mb-6 border-b border-white/10 pb-2">
                        <button onclick="switchSettingsTab('general')" id="tab-general" class="px-4 py-2 rounded-xl font-bold text-sm transition-all bg-indigo-600 text-white">
                            General
                        </button>
                        <button onclick="switchSettingsTab('audio')" id="tab-audio" class="px-4 py-2 rounded-xl font-bold text-sm transition-all text-slate-400 hover:text-white">
                            Audio & Recording
                        </button>
                        <button onclick="switchSettingsTab('presets')" id="tab-presets" class="px-4 py-2 rounded-xl font-bold text-sm transition-all text-slate-400 hover:text-white">
                            Presets
                        </button>
                    </div>
                    
                    <!-- General Settings Tab -->
                    <div id="settings-general" class="space-y-6">
                        <h3 class="text-lg font-bold text-white mb-4">Session Settings</h3>
                        
                        <!-- Sleep Mode Toggle -->
                        <div class="space-y-2 p-4 bg-slate-800 rounded-2xl">
                            <div class="flex items-center justify-between">
                                <div>
                                    <label class="text-indigo-400 text-sm font-bold uppercase tracking-wider">Sleep Mode</label>
                                    <p class="text-slate-400 text-xs mt-1">Unlimited story length with no timer</p>
                                </div>
                                <label class="relative inline-flex items-center cursor-pointer">
                                    <input type="checkbox" id="sleep-mode-toggle" onchange="toggleSleepMode(this.checked)" class="sr-only peer">
                                    <div class="w-14 h-7 bg-slate-700 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-indigo-500 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-6 after:w-6 after:transition-all peer-checked:bg-indigo-600"></div>
                                </label>
                            </div>
                        </div>
                        
                        <!-- Session Duration (hidden in sleep mode) -->
                        <div id="session-duration-setting" class="space-y-2 p-4 bg-slate-800 rounded-2xl">
                            <label class="text-indigo-400 text-sm font-bold uppercase tracking-wider">Session Duration</label>
                            <select id="length-select-reader" onchange="updateSessionDuration(this.value)" class="w-full bg-slate-900 border border-white/10 rounded-xl p-3 text-white appearance-none cursor-pointer">
                                <option value="5">5 Minutes</option>
                                <option value="30">30 Minutes</option>
                                <option value="60">1 Hour</option>
                                <option value="120">2 Hours</option>
                            </select>
                        </div>
                        
                        <!-- Auto-Save Story -->
                        <div class="space-y-2 p-4 bg-slate-800 rounded-2xl">
                            <div class="flex items-center justify-between mb-3">
                                <div>
                                    <label class="text-indigo-400 text-sm font-bold uppercase tracking-wider">Auto-Save Story</label>
                                    <p class="text-slate-400 text-xs mt-1">Automatically save story content to browser storage</p>
                                </div>
                                <label class="relative inline-flex items-center cursor-pointer">
                                    <input type="checkbox" id="auto-save-toggle" onchange="toggleAutoSave(this.checked)" class="sr-only peer">
                                    <div class="w-14 h-7 bg-slate-700 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-indigo-500 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-6 after:w-6 after:transition-all peer-checked:bg-indigo-600"></div>
                                </label>
                            </div>
                            <div class="space-y-2">
                                <label class="text-slate-400 text-xs">Max Story Size (KB)</label>
                                <input type="number" id="max-story-size" value="500" min="100" max="5000" step="100" class="w-full bg-slate-900 border border-white/10 rounded-xl p-2 text-white text-sm">
                            </div>
                        </div>
                        
                        <!-- Export Story Button -->
                        <button onclick="exportStory()" class="w-full py-3 bg-indigo-600 hover:bg-indigo-500 rounded-2xl font-bold text-sm transition-all active:scale-95 flex items-center justify-center gap-2">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="7 10 12 15 17 10"></polyline>
                                <line x1="12" y1="15" x2="12" y2="3"></line>
                            </svg>
                            Export Story to File
                        </button>
                    </div>
                    
                    <!-- Audio & Recording Tab -->
                    <div id="settings-audio" class="hidden space-y-6">
                        <h3 class="text-lg font-bold text-white mb-4">Audio Recording</h3>
                        
                        <!-- Recording Toggle -->
                        <div class="space-y-2 p-4 bg-slate-800 rounded-2xl">
                            <div class="flex items-center justify-between">
                                <div>
                                    <label class="text-indigo-400 text-sm font-bold uppercase tracking-wider">Record Audio</label>
                                    <p class="text-slate-400 text-xs mt-1">Save narration audio to download later</p>
                                </div>
                                <label class="relative inline-flex items-center cursor-pointer">
                                    <input type="checkbox" id="audio-recording-toggle" onchange="toggleAudioRecording(this.checked)" class="sr-only peer">
                                    <div class="w-14 h-7 bg-slate-700 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-indigo-500 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-6 after:w-6 after:transition-all peer-checked:bg-indigo-600"></div>
                                </label>
                            </div>
                        </div>
                        
                        <!-- Recording Status -->
                        <div id="recording-status" class="hidden space-y-2 p-4 bg-slate-800 rounded-2xl border-2 border-red-500/50">
                            <div class="flex items-center gap-2 mb-2">
                                <div class="w-3 h-3 bg-red-500 rounded-full animate-pulse"></div>
                                <span class="text-red-400 text-sm font-bold">RECORDING</span>
                            </div>
                            <div class="text-slate-400 text-xs">
                                <span id="recording-duration">0:00</span> ‚Ä¢ 
                                <span id="recording-size">0 KB</span>
                            </div>
                        </div>
                        
                        <!-- Download Recording -->
                        <button id="download-recording-btn" onclick="downloadRecording()" disabled class="w-full py-3 bg-slate-700 rounded-2xl font-bold text-sm transition-all flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-600 active:scale-95">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="7 10 12 15 17 10"></polyline>
                                <line x1="12" y1="15" x2="12" y2="3"></line>
                            </svg>
                            Download Recording
                        </button>
                    </div>
                    
                    <!-- Presets Tab -->
                    <div id="settings-presets" class="hidden space-y-6">
                        <h3 class="text-lg font-bold text-white mb-4">Configuration Presets</h3>
                        
                        <!-- Save New Preset -->
                        <div class="space-y-2 p-4 bg-slate-800 rounded-2xl">
                            <label class="text-indigo-400 text-sm font-bold uppercase tracking-wider">Save Current Settings</label>
                            <div class="flex gap-2">
                                <input type="text" id="preset-name-input" placeholder="Enter preset name..." class="flex-1 bg-slate-900 border border-white/10 rounded-xl p-3 text-white text-sm">
                                <button onclick="savePreset()" class="px-6 py-3 bg-green-600 hover:bg-green-500 rounded-xl font-bold text-sm transition-all active:scale-95">
                                    Save
                                </button>
                            </div>
                        </div>
                        
                        <!-- Preset List -->
                        <div class="space-y-2">
                            <label class="text-indigo-400 text-sm font-bold uppercase tracking-wider">Saved Presets</label>
                            <div id="preset-list" class="space-y-2">
                                <div class="text-slate-400 text-sm text-center py-4">No presets saved yet</div>
                            </div>
                        </div>
                        
                        <!-- Export/Import Presets -->
                        <div class="grid grid-cols-2 gap-3">
                            <button onclick="exportPresets()" class="py-3 bg-slate-700 hover:bg-slate-600 rounded-xl font-bold text-sm transition-all active:scale-95">
                                Export All
                            </button>
                            <button onclick="document.getElementById('import-presets-input').click()" class="py-3 bg-slate-700 hover:bg-slate-600 rounded-xl font-bold text-sm transition-all active:scale-95">
                                Import
                            </button>
                        </div>
                        <input type="file" id="import-presets-input" accept=".json" style="display:none;" onchange="importPresets(this.files[0])">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // Configuration Variables
        // ============================================================================
        
        // ========================================================================
        // API Configuration
        // ========================================================================
        // REMOVED: Direct API key usage is no longer supported
        // All API calls must go through Firebase Cloud Functions for security
        // 
        // To configure the API key:
        // 1. Set the key in Firebase Functions config:
        //    firebase functions:config:set genai.key="YOUR_API_KEY"
        // 2. Deploy the functions:
        //    firebase deploy --only functions
        // 3. Ensure Firebase configuration is set in the <script> tag above
        // 
        // The app will automatically route all API calls through secure Firebase proxies:
        // - Story generation: /generateStory
        // - Text-to-speech: /generateTTS
        // - Image generation: /generateImage
        //
        // See server/README.md for detailed deployment instructions
        
        const DEFAULT_ACCENT = 'American';
        const MUSIC_SELECTION_MIN_SCORE = 2; // Minimum keyword matches for intelligent music selection
        const IMAGE_QUEUE_DELAY_MS = 1000; // Delay between background image generations to avoid API overload
        const RESTART_PLAYBACK_DELAY_MS = 300; // Delay before starting playback after restart to allow UI updates to complete
        
        // API Response Validation Helpers
        function validateStoryResponse(data) {
            if (!data || !data.candidates || !data.candidates[0] || 
                !data.candidates[0].content || !data.candidates[0].content.parts ||
                !data.candidates[0].content.parts[0] || !data.candidates[0].content.parts[0].text) {
                throw new Error('Invalid story generation API response: ' + JSON.stringify(data));
            }
            return data;
        }
        
        function validateTTSResponse(data) {
            if (!data || !data.candidates || !data.candidates[0] || 
                !data.candidates[0].content || !data.candidates[0].content.parts || 
                !data.candidates[0].content.parts[0] || !data.candidates[0].content.parts[0].inlineData) {
                throw new Error('Invalid TTS API response structure: ' + JSON.stringify(data));
            }
            return data;
        }
        
        /**
         * Helper function to get App Check token with enhanced error logging
         * Provides detailed troubleshooting guidance for 400 errors
         * 
         * @returns {Promise<string>} - App Check token
         * @throws {Error} - If token acquisition fails
         */
        async function getAppCheckTokenWithErrorHandling() {
            // Import getToken from App Check
            const { getToken } = await import("https://www.gstatic.com/firebasejs/11.6.1/firebase-app-check.js");
            
            try {
                const appCheckTokenResponse = await getToken(window.fb.appCheck, /* forceRefresh */ false);
                return appCheckTokenResponse.token;
            } catch (tokenError) {
                console.error('‚ùå App Check token exchange failed:', tokenError);
                
                // Log detailed error information for 400 errors
                if (tokenError.message && (tokenError.message.includes('400') || tokenError.message.includes('Bad Request'))) {
                    console.error('');
                    console.error('üîç App Check Token Exchange Failed (400 Bad Request)');
                    console.error('');
                    console.error('Troubleshooting steps:');
                    console.error('  1. Verify domain authorization:');
                    console.error('     ‚Üí Google Cloud Console > Security > reCAPTCHA Enterprise');
                    console.error('     ‚Üí Ensure current domain (' + window.location.hostname + ') is in allowed domains');
                    console.error('  2. Check API status:');
                    console.error('     ‚Üí Google Cloud Console > APIs & Services');
                    console.error('     ‚Üí Verify "reCAPTCHA Enterprise API" is enabled');
                    console.error('  3. Verify billing:');
                    console.error('     ‚Üí reCAPTCHA Enterprise requires active billing on your GCP project');
                    console.error('  4. Validate App Check configuration:');
                    console.error('     ‚Üí Firebase Console > Build > App Check');
                    console.error('     ‚Üí Verify provider is correctly configured for this app');
                    console.error('');
                    console.error('Error details:', tokenError.message);
                    if (tokenError.stack) {
                        console.error('Stack trace:', tokenError.stack);
                    }
                }
                
                throw tokenError;
            }
        }
        
        /**
         * Retry wrapper for API calls with exponential backoff
         * @param {Function} fn - Async function to retry
         * @param {Object} options - Retry options
         * @returns {Promise<any>} - Result of successful call
         */
        async function retryWithBackoff(fn, options = {}) {
            const {
                maxRetries = 3,
                initialDelayMs = 1000,
                maxDelayMs = 10000,
                operationName = 'Operation'
            } = options;
            
            let lastError;
            
            for (let attempt = 0; attempt <= maxRetries; attempt++) {
                try {
                    return await fn();
                } catch (error) {
                    lastError = error;
                    
                    // Check if error is retryable based on backend response
                    const isRetryable = error.retryable || 
                                       error.message?.includes('timeout') ||
                                       error.message?.includes('network') ||
                                       error.statusCode === 429 ||
                                       error.statusCode >= 500;
                    
                    if (!isRetryable || attempt === maxRetries) {
                        console.error(`${operationName} failed after ${attempt + 1} attempts:`, error.message);
                        throw error;
                    }
                    
                    // Calculate delay with exponential backoff
                    const delay = Math.min(
                        initialDelayMs * Math.pow(2, attempt),
                        maxDelayMs
                    );
                    
                    console.warn(
                        `${operationName} attempt ${attempt + 1} failed: ${error.message}. ` +
                        `Retrying in ${delay}ms...`
                    );
                    
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
            
            throw lastError;
        }
        
        /**
         * Helper function to call the Firebase proxy for story generation
         * Acquires an App Check token and POSTs to the generateStory endpoint
         * 
         * @param {string} prompt - The story prompt or continuation instruction
         * @param {string} systemInstruction - System instruction for the AI
         * @returns {Promise<Object>} - API response data
         * @throws {Error} - If proxy is not configured or request fails
         */
        async function callGenerateProxy(prompt, systemInstruction) {
            // Check if Firebase App Check is initialized
            if (!window.fb || !window.fb.appCheck) {
                throw new Error('PROXY_NOT_CONFIGURED');
            }
            
            try {
                // Get App Check token with enhanced error handling and diagnostics
                const appCheckToken = await getAppCheckTokenWithErrorHandling();
                
                console.log('Calling generateStory proxy endpoint with App Check token');
                
                // Use the Firebase Hosting rewrite path
                const proxyUrl = '/generateStory';
                
                // POST to proxy endpoint
                const response = await fetch(proxyUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Firebase-AppCheck': appCheckToken
                    },
                    body: JSON.stringify({
                        prompt: prompt,
                        systemInstruction: systemInstruction
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                    
                    // Create error with retryable flag and status code from backend
                    const error = new Error();
                    error.statusCode = response.status;
                    error.retryable = errorData.retryable || false;
                    
                    // Provide helpful error messages based on status code
                    if (response.status === 403) {
                        error.message = `PROXY_AUTH_FAILED: ${errorData.details || 'App Check verification failed'}`;
                    } else if (response.status === 502 || response.status === 504) {
                        error.message = `PROXY_UPSTREAM_ERROR: ${errorData.details || 'Upstream API error'}`;
                    } else if (response.status === 500) {
                        error.message = `PROXY_SERVER_ERROR: ${errorData.details || 'Internal server error'}`;
                    } else {
                        error.message = `PROXY_ERROR: ${errorData.error || `HTTP ${response.status}`}`;
                    }
                    
                    throw error;
                }
                
                const data = await response.json();
                console.log('Successfully received response from generateStory proxy');
                return data;
                
            } catch (error) {
                // Enhanced logging for App Check token failures
                if (error.message && (error.message.includes('App Check') || error.message.includes('getToken'))) {
                    console.error('‚ùå App Check getToken failed in callGenerateProxy:', error);
                    console.info('üí° Troubleshooting hints:');
                    console.info('  ‚Ä¢ Verify reCAPTCHA Enterprise site key is correctly configured');
                    console.info('  ‚Ä¢ Check that reCAPTCHA Enterprise API is enabled in Google Cloud Console');
                    console.info('  ‚Ä¢ Ensure current domain is in the allowed domains list');
                    console.info('  ‚Ä¢ Verify Firebase App Check provider is properly configured');
                    console.info('  ‚Ä¢ Check that billing is enabled for reCAPTCHA Enterprise');
                }
                
                // Re-throw with more context
                if (error.message && error.message.startsWith('PROXY_')) {
                    throw error;
                }
                throw new Error(`PROXY_REQUEST_FAILED: ${error.message}`);
            }
        }
        
        /**
         * Helper function to call the Firebase proxy for TTS
         * 
         * @param {string} text - The text to convert to speech
         * @param {string} voice - Voice name
         * @param {string} accent - Accent to use
         * @returns {Promise<Object>} - API response data
         * @throws {Error} - If proxy is not configured or request fails
         */
        async function callTTSProxy(text, voice, accent) {
            // Check if Firebase App Check is initialized
            if (!window.fb || !window.fb.appCheck) {
                throw new Error('PROXY_NOT_CONFIGURED');
            }
            
            try {
                // Get App Check token with enhanced error handling and diagnostics
                const appCheckToken = await getAppCheckTokenWithErrorHandling();
                
                console.log('Calling generateTTS proxy endpoint with App Check token');
                
                // Determine proxy URL
                const proxyUrl = '/generateTTS';
                
                // POST to proxy endpoint
                const response = await fetch(proxyUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Firebase-AppCheck': appCheckToken
                    },
                    body: JSON.stringify({
                        text: text,
                        voice: voice,
                        accent: accent
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                    
                    // Create error with retryable flag and status code from backend
                    const error = new Error(`TTS_PROXY_ERROR: ${errorData.details || errorData.error || `HTTP ${response.status}`}`);
                    error.statusCode = response.status;
                    error.retryable = errorData.retryable || false;
                    
                    throw error;
                }
                
                const data = await response.json();
                console.log('Successfully received response from generateTTS proxy');
                return data;
                
            } catch (error) {
                // Enhanced logging for App Check token failures
                if (error.message && (error.message.includes('App Check') || error.message.includes('getToken'))) {
                    console.error('‚ùå App Check getToken failed in callTTSProxy:', error);
                    console.info('üí° Troubleshooting hints:');
                    console.info('  ‚Ä¢ Verify reCAPTCHA Enterprise site key is correctly configured');
                    console.info('  ‚Ä¢ Check that reCAPTCHA Enterprise API is enabled in Google Cloud Console');
                    console.info('  ‚Ä¢ Ensure current domain is in the allowed domains list');
                    console.info('  ‚Ä¢ Verify Firebase App Check provider is properly configured');
                    console.info('  ‚Ä¢ Check that billing is enabled for reCAPTCHA Enterprise');
                }
                
                if (error.message && error.message.startsWith('TTS_PROXY_')) {
                    throw error;
                }
                throw new Error(`TTS_PROXY_REQUEST_FAILED: ${error.message}`);
            }
        }
        
        /**
         * Helper function to call the Firebase proxy for image generation
         * 
         * @param {string} prompt - The image generation prompt
         * @returns {Promise<Object>} - API response data
         * @throws {Error} - If proxy is not configured or request fails
         */
        async function callImageProxy(prompt) {
            // Check if Firebase App Check is initialized
            if (!window.fb || !window.fb.appCheck) {
                throw new Error('PROXY_NOT_CONFIGURED');
            }
            
            try {
                // Get App Check token with enhanced error handling and diagnostics
                const appCheckToken = await getAppCheckTokenWithErrorHandling();
                
                console.log('Calling generateImage proxy endpoint with App Check token');
                
                // Determine proxy URL
                const proxyUrl = '/generateImage';
                
                // POST to proxy endpoint
                const response = await fetch(proxyUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Firebase-AppCheck': appCheckToken
                    },
                    body: JSON.stringify({
                        prompt: prompt
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                    
                    // Create error with retryable flag and status code from backend
                    const error = new Error(`IMAGE_PROXY_ERROR: ${errorData.details || errorData.error || `HTTP ${response.status}`}`);
                    error.statusCode = response.status;
                    error.retryable = errorData.retryable || false;
                    
                    throw error;
                }
                
                const data = await response.json();
                console.log('Successfully received response from generateImage proxy');
                return data;
                
            } catch (error) {
                // Enhanced logging for App Check token failures
                if (error.message && (error.message.includes('App Check') || error.message.includes('getToken'))) {
                    console.error('‚ùå App Check getToken failed in callImageProxy:', error);
                    console.info('üí° Troubleshooting hints:');
                    console.info('  ‚Ä¢ Verify reCAPTCHA Enterprise site key is correctly configured');
                    console.info('  ‚Ä¢ Check that reCAPTCHA Enterprise API is enabled in Google Cloud Console');
                    console.info('  ‚Ä¢ Ensure current domain is in the allowed domains list');
                    console.info('  ‚Ä¢ Verify Firebase App Check provider is properly configured');
                    console.info('  ‚Ä¢ Check that billing is enabled for reCAPTCHA Enterprise');
                }
                
                if (error.message && error.message.startsWith('IMAGE_PROXY_')) {
                    throw error;
                }
                throw new Error(`IMAGE_PROXY_REQUEST_FAILED: ${error.message}`);
            }
        }
        
        /**
         * Show a transient banner with error message
         * Used to inform users about proxy/API issues
         */
        function showTransientBanner(message, type = 'warning') {
            // Check if banner already exists
            let banner = document.getElementById('transient-banner');
            if (!banner) {
                banner = document.createElement('div');
                banner.id = 'transient-banner';
                banner.className = 'fixed top-20 left-1/2 -translate-x-1/2 max-w-2xl mx-auto z-50 transition-all duration-300';
                document.body.appendChild(banner);
            }
            
            const bgColor = type === 'error' ? 'bg-red-900/30 border-red-500/50' : 
                           type === 'info' ? 'bg-blue-900/30 border-blue-500/50' :
                           'bg-yellow-900/30 border-yellow-500/50';
            
            const textColor = type === 'error' ? 'text-red-400' : 
                             type === 'info' ? 'text-blue-400' :
                             'text-yellow-400';
            
            banner.innerHTML = `
                <div class="${bgColor} border rounded-2xl p-4 backdrop-blur-sm">
                    <div class="flex items-start gap-3">
                        <svg class="w-6 h-6 ${textColor} flex-shrink-0 mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>
                        </svg>
                        <div class="flex-1 min-w-0">
                            <div class="${textColor} text-sm">${message}</div>
                        </div>
                        <button onclick="document.getElementById('transient-banner').remove()" 
                                class="${textColor} hover:opacity-75 transition-opacity p-1" 
                                title="Dismiss">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                            </svg>
                        </button>
                    </div>
                </div>
            `;
            
            // Auto-dismiss after 10 seconds
            setTimeout(() => {
                if (banner && banner.parentNode) {
                    banner.remove();
                }
            }, 10000);
        }
        
        const VOICES = {
            'American - Kore (Firm)': { name: 'Kore', accent: 'American' },
            'American - Zephyr (Bright)': { name: 'Zephyr', accent: 'American' },
            'American - Puck (Upbeat)': { name: 'Puck', accent: 'American' },
            'British - Enceladus (Breathy)': { name: 'Enceladus', accent: 'British' },
            'British - Charon (Informative)': { name: 'Charon', accent: 'British' },
            'Australian - Fenrir (Excitable)': { name: 'Fenrir', accent: 'Australian' },
            'Australian - Despina (Smooth)': { name: 'Despina', accent: 'Australian' },
            'Indian - Algieba (Smooth)': { name: 'Algieba', accent: 'Indian' }
        };
        const SCORE_LIBRARY = {
            whimsical: { name: "Whimsical Fantasy", icon: "ü™Ñ", url: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3', keywords: ['magic', 'wonder', 'playful', 'light', 'fantasy', 'enchant', 'fairy', 'charm'] },
            noir: { name: "Noir Mystery", icon: "üïµÔ∏è", url: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3', keywords: ['mystery', 'detective', 'shadow', 'noir', 'investigate', 'clue', 'secret', 'hidden'] },
            epic: { name: "High Adventure", icon: "‚öîÔ∏è", url: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-8.mp3', keywords: ['battle', 'war', 'hero', 'quest', 'adventure', 'fight', 'warrior', 'epic', 'glory', 'triumph'] },
            horror: { name: "Dark Suspense", icon: "üåë", url: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3', keywords: ['dark', 'fear', 'horror', 'terror', 'dread', 'nightmare', 'shadow', 'death', 'blood', 'scream'] },
            scifi: { name: "Sci-Fi Ambient", icon: "üöÄ", url: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3', keywords: ['space', 'future', 'technology', 'alien', 'robot', 'cyber', 'quantum', 'science', 'ship', 'galaxy'] },
            dramatic: { name: "Heavy Drama", icon: "üé≠", url: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3', keywords: ['emotion', 'tragic', 'sorrow', 'loss', 'pain', 'heart', 'tear', 'despair', 'sacrifice'] }
        };

        const state = {
            isPlaying: false,
            sentences: [],
            currentIndex: 0,
            voice: 'Kore',
            accent: 'American',
            timeLeftSeconds: 0,
            genre: '',
            history: [],
            audioBuffer: new Map(),
            currentAudio: new Audio(),
            music: new Audio(),
            isGeneratingChapter: false,
            isGeneratingVisual: false,
            chapterStartIndex: 0,
            // Timing estimates: ~8 seconds per sentence based on TTS speed and natural reading pace
            estimatedSecondsPerSentence: 8,
            // Average chapter length: ~12 sentences (~400 words) for optimal pacing and generation speed
            averageSentencesPerChapter: 12,
            // Minimum time buffer: Require at least half a chapter's duration before generating next chapter
            minTimeBufferRatio: 0.5,
            // Retry delay: Wait 5 seconds before allowing retry after failed generation to avoid rapid retries
            retryDelayMs: 5000,
            nextChapterTriggered: false,
            // Image generation: Track generated images and queue for pre-generation
            imageCache: new Map(),
            imageQueue: [],
            lastImageIndex: -1,
            isProcessingImageQueue: false,
            // Music intelligence: Track current mood and prose content for intelligent selection
            currentMood: null,
            lastProseContent: '',
            // Spotify integration
            spotifyAccessToken: null,
            spotifyRefreshToken: null,
            spotifyTokenExpiry: null,
            spotifyUser: null,
            spotifyPlayer: null,
            spotifyDeviceId: null,
            isUsingSpotify: false,
            currentSpotifyTrack: null,
            availableSpotifyTracks: [],
            // Music source selection: tracks currently selected music source for synchronization
            musicSource: 'spotify',
            // Demo mode: tracks when running in fallback mode without API access
            isDemoMode: false
        };

        // Spotify Authentication Functions
        
        // Helper function to extract error message from Spotify API responses
        // Handles different error formats from different Spotify API endpoints
        async function parseSpotifyError(response) {
            let errorMessage = response.statusText;
            try {
                const data = await response.json();
                // Token endpoint returns: error_description, error
                // Other endpoints return: error.message
                errorMessage = data.error_description || data.error?.message || data.error || errorMessage;
            } catch (jsonError) {
                // If parsing JSON fails (e.g., non-JSON error response), use the HTTP status text as fallback
            }
            return errorMessage;
        }
        
        async function loginSpotify() {
            // Check if Spotify config is available
            if (!window.spotify || !window.spotify.clientId) {
                console.error('Spotify configuration not available');
                alert('Spotify integration is not configured. Please add your Spotify Client ID.');
                return;
            }
            
            const codeVerifier = generateCodeVerifier();
            const codeChallenge = await generateCodeChallenge(codeVerifier);
            
            // Store code verifier for later use
            localStorage.setItem('spotify_code_verifier', codeVerifier);
            
            const authUrl = new URL('https://accounts.spotify.com/authorize');
            authUrl.searchParams.append('client_id', window.spotify.clientId);
            authUrl.searchParams.append('response_type', 'code');
            authUrl.searchParams.append('redirect_uri', window.spotify.redirectUri);
            authUrl.searchParams.append('scope', window.spotify.scopes);
            authUrl.searchParams.append('code_challenge_method', 'S256');
            authUrl.searchParams.append('code_challenge', codeChallenge);
            
            window.location.href = authUrl.toString();
        }

        function logoutSpotify() {
            // Clear Spotify state
            state.spotifyAccessToken = null;
            state.spotifyRefreshToken = null;
            state.spotifyTokenExpiry = null;
            state.spotifyUser = null;
            state.isUsingSpotify = false;
            state.currentSpotifyTrack = null;
            state.availableSpotifyTracks = [];
            
            // Clear local storage
            localStorage.removeItem('spotify_access_token');
            localStorage.removeItem('spotify_refresh_token');
            localStorage.removeItem('spotify_token_expiry');
            localStorage.removeItem('spotify_user');
            
            // Update UI
            updateSpotifyUI();
            
            // If currently using Spotify music, switch back to default
            if (state.currentMood) {
                applyScore(state.currentMood);
            }
        }

        function generateCodeVerifier() {
            const array = new Uint8Array(32);
            crypto.getRandomValues(array);
            return base64UrlEncode(array);
        }

        async function generateCodeChallenge(verifier) {
            const encoder = new TextEncoder();
            const data = encoder.encode(verifier);
            const digest = await crypto.subtle.digest('SHA-256', data);
            return base64UrlEncode(new Uint8Array(digest));
        }

        function base64UrlEncode(array) {
            const base64 = btoa(String.fromCharCode.apply(null, array));
            return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
        }

        async function handleSpotifyCallback() {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            
            if (code) {
                const codeVerifier = localStorage.getItem('spotify_code_verifier');
                if (!codeVerifier) {
                    console.error('Code verifier not found');
                    return;
                }
                
                try {
                    const response = await fetch('https://accounts.spotify.com/api/token', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: new URLSearchParams({
                            grant_type: 'authorization_code',
                            code: code,
                            redirect_uri: window.spotify.redirectUri,
                            client_id: window.spotify.clientId,
                            code_verifier: codeVerifier,
                        }),
                    });
                    
                    if (!response.ok) {
                        // Parse error response to get detailed error message
                        const errorMessage = await parseSpotifyError(response);
                        throw new Error(`Spotify authentication failed: ${errorMessage}`);
                    }
                    
                    const data = await response.json();
                    
                    if (data.access_token) {
                        state.spotifyAccessToken = data.access_token;
                        state.spotifyRefreshToken = data.refresh_token;
                        state.spotifyTokenExpiry = Date.now() + (data.expires_in * 1000);
                        
                        // Store in localStorage
                        localStorage.setItem('spotify_access_token', data.access_token);
                        localStorage.setItem('spotify_refresh_token', data.refresh_token);
                        localStorage.setItem('spotify_token_expiry', state.spotifyTokenExpiry);
                        
                        // Get user info
                        await fetchSpotifyUserInfo();
                        
                        // Update UI
                        updateSpotifyUI();
                        
                        // Clear URL parameters
                        window.history.replaceState({}, document.title, window.location.pathname);
                        
                        // Clean up
                        localStorage.removeItem('spotify_code_verifier');
                    }
                } catch (error) {
                    console.error('Error exchanging code for token:', error);
                    // Show user-friendly error message
                    alert(`Failed to log in to Spotify: ${error.message}\n\nPlease check that your Spotify Client ID is correct and that the redirect URI is properly configured in your Spotify app settings.`);
                    // Clear URL parameters to allow retry
                    window.history.replaceState({}, document.title, window.location.pathname);
                    // Clean up
                    localStorage.removeItem('spotify_code_verifier');
                }
            }
        }

        async function fetchSpotifyUserInfo() {
            if (!state.spotifyAccessToken) return;
            
            try {
                const response = await fetch('https://api.spotify.com/v1/me', {
                    headers: {
                        'Authorization': `Bearer ${state.spotifyAccessToken}`
                    }
                });
                
                if (!response.ok) {
                    // If we can't fetch user info, clear the token as it may be invalid
                    if (response.status === 401 || response.status === 403) {
                        logoutSpotify();
                    }
                    
                    const errorMessage = await parseSpotifyError(response);
                    throw new Error(`Failed to fetch Spotify user info: ${errorMessage}`);
                }
                
                const userData = await response.json();
                state.spotifyUser = userData;
                localStorage.setItem('spotify_user', JSON.stringify(userData));
            } catch (error) {
                console.error('Error fetching Spotify user info:', error);
            }
        }

        function updateSpotifyUI() {
            const loginBtn = document.getElementById('spotify-login-btn');
            const userInfo = document.getElementById('spotify-user-info');
            const username = document.getElementById('spotify-username');
            
            if (state.spotifyAccessToken && state.spotifyUser) {
                loginBtn.classList.add('hidden');
                userInfo.classList.remove('hidden');
                username.textContent = state.spotifyUser.display_name || state.spotifyUser.id;
            } else {
                loginBtn.classList.remove('hidden');
                userInfo.classList.add('hidden');
            }
        }

        async function searchSpotifyTracks(mood, genre) {
            if (!state.spotifyAccessToken) {
                console.log('Not logged into Spotify, using default music');
                return null;
            }
            
            // Map moods to Spotify search terms
            const moodKeywords = {
                whimsical: 'whimsical fantasy magical',
                noir: 'noir mystery detective jazz',
                epic: 'epic orchestral cinematic adventure',
                horror: 'dark horror suspense ambient',
                scifi: 'sci-fi electronic ambient futuristic',
                dramatic: 'dramatic emotional orchestral'
            };
            
            const searchQuery = moodKeywords[mood] || mood;
            
            try {
                const response = await fetch(`https://api.spotify.com/v1/search?q=${encodeURIComponent(searchQuery)}&type=track&limit=10`, {
                    headers: {
                        'Authorization': `Bearer ${state.spotifyAccessToken}`
                    }
                });
                
                if (!response.ok) {
                    const errorMessage = await parseSpotifyError(response);
                    console.error(`Spotify search failed: ${errorMessage}`);
                    return null;
                }
                
                const data = await response.json();
                
                if (data.tracks && data.tracks.items && data.tracks.items.length > 0) {
                    state.availableSpotifyTracks = data.tracks.items;
                    return data.tracks.items[0]; // Return first track
                }
            } catch (error) {
                console.error('Error searching Spotify tracks:', error);
            }
            
            return null;
        }

        async function playSpotifyTrack(track) {
            if (!state.spotifyAccessToken || !track) return false;
            
            try {
                // Stop current music
                state.music.pause();
                
                // Use Spotify Web Playback SDK or fallback to preview URL
                if (track.preview_url) {
                    state.music.src = track.preview_url;
                    state.music.loop = true;
                    state.currentSpotifyTrack = track;
                    state.isUsingSpotify = true;
                    
                    // Update UI
                    const musicStatus = document.getElementById('music-status');
                    const musicSourceDisplay = document.getElementById('music-source-display');
                    if (musicStatus) {
                        musicStatus.textContent = `${track.name} - ${track.artists[0].name}`;
                    }
                    if (musicSourceDisplay) {
                        musicSourceDisplay.textContent = `Source: Spotify`;
                    }
                    
                    if (state.isPlaying) {
                        await state.music.play();
                    }
                    
                    return true;
                } else {
                    console.warn('Track has no preview URL available');
                    return false;
                }
            } catch (error) {
                console.error('Error playing Spotify track:', error);
                return false;
            }
        }

        async function changeSong() {
            const btn = document.getElementById('change-song-btn');
            const originalText = btn.innerHTML;
            
            // Show loading state
            btn.innerHTML = '<svg class="animate-spin h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10" stroke-opacity="0.25"></circle><path d="M12 2a10 10 0 0 1 10 10" stroke-opacity="0.75"></path></svg> Searching...';
            btn.disabled = true;
            
            try {
                if (state.spotifyAccessToken && state.currentMood) {
                    // Use Spotify if logged in
                    const track = await searchSpotifyTracks(state.currentMood, state.genre);
                    
                    if (track) {
                        const success = await playSpotifyTrack(track);
                        
                        if (success) {
                            console.log('Changed to Spotify track:', track.name);
                        } else {
                            // Fallback to next track in default library
                            changeToNextDefaultTrack();
                        }
                    } else {
                        // Fallback to default library
                        changeToNextDefaultTrack();
                    }
                } else {
                    // Use default music library
                    changeToNextDefaultTrack();
                }
            } catch (error) {
                console.error('Error changing song:', error);
                changeToNextDefaultTrack();
            } finally {
                // Restore button
                btn.innerHTML = originalText;
                btn.disabled = false;
            }
        }

        function changeToNextDefaultTrack() {
            if (!state.currentMood) return;
            
            // Get all tracks matching the current mood category
            const currentTrackKey = state.currentMood;
            const sameMoodTracks = [];
            
            // Find tracks with similar keywords
            const currentTrack = SCORE_LIBRARY[currentTrackKey];
            if (!currentTrack) return;
            
            for (const [key, track] of Object.entries(SCORE_LIBRARY)) {
                if (key !== currentTrackKey) {
                    // Check if tracks share keywords
                    const sharedKeywords = currentTrack.keywords.filter(k => 
                        track.keywords.includes(k)
                    );
                    if (sharedKeywords.length > 0) {
                        sameMoodTracks.push(key);
                    }
                }
            }
            
            // If no similar tracks, use any other track
            if (sameMoodTracks.length === 0) {
                const allKeys = Object.keys(SCORE_LIBRARY);
                sameMoodTracks.push(...allKeys.filter(k => k !== currentTrackKey));
            }
            
            // Select a random track from similar ones
            if (sameMoodTracks.length > 0) {
                const randomKey = sameMoodTracks[Math.floor(Math.random() * sameMoodTracks.length)];
                state.currentMood = randomKey;
                state.isUsingSpotify = false;
                applyScore(randomKey);
                console.log('Changed to default track:', randomKey);
            }
        }

        // Check for stored Spotify credentials on page load
        function restoreSpotifySession() {
            const accessToken = localStorage.getItem('spotify_access_token');
            const refreshToken = localStorage.getItem('spotify_refresh_token');
            const tokenExpiry = localStorage.getItem('spotify_token_expiry');
            const userStr = localStorage.getItem('spotify_user');
            
            if (accessToken && tokenExpiry && Date.now() < parseInt(tokenExpiry)) {
                state.spotifyAccessToken = accessToken;
                state.spotifyRefreshToken = refreshToken;
                state.spotifyTokenExpiry = parseInt(tokenExpiry);
                
                if (userStr) {
                    try {
                        state.spotifyUser = JSON.parse(userStr);
                    } catch (e) {
                        console.error('Error parsing stored user data:', e);
                    }
                }
                
                updateSpotifyUI();
            } else if (accessToken && refreshToken) {
                // Token expired, try to refresh
                refreshSpotifyToken().catch(err => {
                    console.error('Failed to refresh Spotify token:', err);
                    logoutSpotify();
                });
            }
        }

        async function refreshSpotifyToken() {
            if (!state.spotifyRefreshToken) return;
            
            try {
                const response = await fetch('https://accounts.spotify.com/api/token', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        grant_type: 'refresh_token',
                        refresh_token: state.spotifyRefreshToken,
                        client_id: window.spotify.clientId,
                    }),
                });
                
                if (!response.ok) {
                    // Parse error response to get detailed error message
                    const errorMessage = await parseSpotifyError(response);
                    throw new Error(`Failed to refresh Spotify token: ${errorMessage}`);
                }
                
                const data = await response.json();
                
                if (data.access_token) {
                    state.spotifyAccessToken = data.access_token;
                    state.spotifyTokenExpiry = Date.now() + (data.expires_in * 1000);
                    
                    localStorage.setItem('spotify_access_token', data.access_token);
                    localStorage.setItem('spotify_token_expiry', state.spotifyTokenExpiry);
                    
                    if (data.refresh_token) {
                        state.spotifyRefreshToken = data.refresh_token;
                        localStorage.setItem('spotify_refresh_token', data.refresh_token);
                    }
                    
                    updateSpotifyUI();
                }
            } catch (error) {
                console.error('Error refreshing Spotify token:', error);
                throw error;
            }
        }


        // Helper function to synchronize music source to MusicPlayer module
        function syncMusicSourceToPlayer(source) {
            if (typeof MusicPlayer !== 'undefined' && MusicPlayer.setSource) {
                MusicPlayer.setSource(source);
            } else if (typeof MusicPlayer !== 'undefined') {
                // Fallback: dispatch change event on the select element for MusicPlayer.attachUI to pick up
                const musicSourceSelect = document.getElementById('music-source-select');
                if (musicSourceSelect) {
                    const changeEvent = new Event('change', { bubbles: true });
                    musicSourceSelect.dispatchEvent(changeEvent);
                }
            }
        }

        async function initiateSession() {
            const prompt = document.getElementById('prompt-input').value || "Tell me an interesting story.";
            const selectedVoice = document.getElementById('voice-select').value;
            let voiceConfig = VOICES[selectedVoice];
            
            // Validate voice configuration with fallback
            if (!voiceConfig) {
                console.error('Invalid voice selection:', selectedVoice, '- falling back to default');
                const defaultVoiceKey = Object.keys(VOICES)[0];
                voiceConfig = VOICES[defaultVoiceKey];
            }
            
            state.voice = voiceConfig.name;
            state.accent = voiceConfig.accent;
            state.timeLeftSeconds = parseInt(document.getElementById('length-select').value) * 60;
            state.genre = document.getElementById('genre-select').value;
            
            // Sync reader voice selector with initial selection
            document.getElementById('voice-select-reader').value = selectedVoice;
            
            // Capture selected music source from front page
            const selectedMusicSource = document.getElementById('music-source-select')?.value || 'spotify';
            
            // Synchronize state.musicSource with selected value
            state.musicSource = selectedMusicSource;
            
            // Propagate music source to MusicPlayer module
            syncMusicSourceToPlayer(state.musicSource);
            
            // Show loading state
            const startBtn = document.getElementById('start-btn');
            startBtn.disabled = true;
            startBtn.textContent = 'Generating Story...';
            
            try {
                // First Chapter - wait for complete generation
                await generateNextChapter(prompt);
                
                // Update button to show audio generation
                startBtn.textContent = 'Preparing Narrator...';
                
                // Preload first 3 sentences for immediate playback in parallel
                const preloadPromises = [];
                for (let i = 0; i < Math.min(3, state.sentences.length); i++) {
                    preloadPromises.push(preloadAudio(i));
                }
                await Promise.all(preloadPromises);
                
                // Switch to reader view
                switchView('reader');
                startTimerDisplay();
                
                // Update music display to show selected source and current state
                updateMusicDisplayForSource(selectedMusicSource);
                
                // Auto-start playback immediately for instant narration
                togglePlayback();
                
                console.log('Story started with instant narration.');
            } catch (error) {
                console.error('Failed to start session:', error);
                
                // Instead of aborting, provide a fallback demo chapter
                // This allows users to still experience the music player and visuals
                console.log('Generating fallback demo chapter due to API failure...');
                
                // Create fallback demo chapter with 4-6 sentences
                const fallbackChapter = {
                    title: "Demo: A Moonlit Journey",
                    prose: "The night was alive with whispers of ancient magic. Stars danced across the velvet sky, painting stories of forgotten realms. A lone traveler stood at the crossroads, gazing up at the silver moon. The wind carried secrets from distant lands, weaving through the trees like a gentle song. In this moment, time itself seemed to pause, holding its breath. The journey ahead would be filled with wonder and mystery.",
                    score_type: state.genre.toLowerCase() === 'fantasy' ? 'whimsical' : 
                               state.genre.toLowerCase() === 'sci-fi' ? 'scifi' : 
                               state.genre.toLowerCase() === 'mystery' ? 'noir' : 
                               state.genre.toLowerCase() === 'horror' ? 'horror' : 'dramatic',
                    key_visual_moments: [
                        "A lone traveler at a mystical crossroads under a moonlit sky",
                        "Stars painting stories across the velvet night"
                    ]
                };
                
                // Populate state with fallback chapter
                appendChapter(fallbackChapter);
                
                // Set demo mode flag to indicate limited functionality
                state.isDemoMode = true;
                
                // Apply appropriate music score
                applyScore(fallbackChapter.score_type);
                
                // Switch to reader view to show the demo content
                switchView('reader');
                startTimerDisplay();
                
                // Update music display
                updateMusicDisplayForSource(selectedMusicSource);
                
                // Restore start button state
                startBtn.disabled = false;
                startBtn.textContent = 'Begin Story';
                
                // Display user-friendly error message explaining the failure
                let errorMessage = '‚ö†Ô∏è Story Generation Failed\n\n';
                
                // Provide specific guidance based on error type from the proxy functions
                if (error.message && error.message.includes('PROXY_NOT_CONFIGURED')) {
                    errorMessage += 'Firebase Configuration Issue: Firebase Cloud Functions are not configured.\n\n';
                    errorMessage += 'Please set up Firebase:\n';
                    errorMessage += '1. Configure Firebase in index.html (__firebase_config)\n';
                    errorMessage += '2. Set up reCAPTCHA v3 for App Check (__recaptcha_site_key)\n';
                    errorMessage += '3. Deploy Cloud Functions with API key configured\n';
                    errorMessage += 'See server/README.md for detailed setup instructions.\n\n';
                } else if (error.message && (error.message.includes('PROXY_AUTH_FAILED') || error.message.includes('APP_CHECK'))) {
                    errorMessage += 'App Check Verification Failed: Security verification could not be completed.\n\n';
                    errorMessage += 'Please ensure:\n';
                    errorMessage += '‚Ä¢ reCAPTCHA v3 site key is correctly configured\n';
                    errorMessage += '‚Ä¢ Firebase App Check is properly initialized\n';
                    errorMessage += '‚Ä¢ Your domain is added to the reCAPTCHA allowlist\n\n';
                } else if (error.message && error.message.includes('PROXY_UPSTREAM_ERROR')) {
                    errorMessage += 'Backend API Issue: The Cloud Function cannot communicate with Google AI API.\n\n';
                    errorMessage += 'Possible causes:\n';
                    errorMessage += '‚Ä¢ API key not configured in Firebase Functions\n';
                    errorMessage += '‚Ä¢ API key is invalid or expired\n';
                    errorMessage += '‚Ä¢ API quota has been exceeded\n';
                    errorMessage += '‚Ä¢ Generative Language API not enabled\n\n';
                    errorMessage += 'To configure: firebase functions:config:set genai.key="YOUR_KEY"\n';
                    errorMessage += 'Then redeploy: firebase deploy --only functions\n\n';
                } else if (error.message && error.message.includes('PROXY_SERVER_ERROR')) {
                    errorMessage += 'Server Error: The Cloud Function encountered an internal error.\n\n';
                    errorMessage += 'Please check Firebase Functions logs for details:\n';
                    errorMessage += '  firebase functions:log\n\n';
                } else if (error.message && error.message.includes('PROXY_ERROR')) {
                    errorMessage += 'Proxy Communication Error: Failed to communicate with the backend.\n\n';
                    errorMessage += 'Error details: ' + error.message + '\n\n';
                } else if (error.message && error.message.includes('PROXY_REQUEST_FAILED')) {
                    errorMessage += 'Request Failed: Network or connectivity issue.\n\n';
                    errorMessage += 'Please check:\n';
                    errorMessage += '‚Ä¢ Your internet connection\n';
                    errorMessage += '‚Ä¢ Firebase Cloud Functions are deployed and accessible\n';
                    errorMessage += '‚Ä¢ Browser console for detailed error messages\n\n';
                } else {
                    errorMessage += 'An unexpected error occurred.\n\n';
                    errorMessage += 'Error details: ' + (error.message || 'Unknown error') + '\n\n';
                }
                
                // Add file:// protocol specific guidance
                if (window.location.protocol === 'file:') {
                    errorMessage += '‚ö†Ô∏è IMPORTANT: You are running this app via file:// protocol.\n';
                    errorMessage += 'This can cause API restrictions and CORS issues.\n\n';
                    errorMessage += 'Please serve the app over HTTP instead:\n';
                    errorMessage += '  python -m http.server 8000\n';
                    errorMessage += '  Then visit: http://localhost:8000/index.html\n\n';
                }
                
                errorMessage += 'A demo chapter has been loaded so you can explore the music player and visuals.\n';
                errorMessage += 'In demo mode, the story text is displayed but AI narration and image generation are unavailable.\n';
                errorMessage += 'Fix the API configuration to enable full story generation with AI narration and images.';
                
                // Show error message using non-intrusive banner instead of blocking alert
                // Convert newlines to HTML breaks for proper display
                showTransientBanner(errorMessage.replace(/\n/g, '<br>'), 'warning');
                
                // Also log friendly message to console
                console.log('Fallback demo chapter loaded.');
                console.log('Demo mode: Music playback and text display are available.');
                console.log('Demo mode: AI narration and image generation are disabled.');
                console.log('Error details:', error.message || error);
            }
        }

        async function generateNextChapter(seedPrompt) {
            if (state.isGeneratingChapter) return;
            state.isGeneratingChapter = true;
            
            const sys = `You are a professional novelist writing a ${state.genre} story. 
            The session has ${Math.ceil(state.timeLeftSeconds / 60)} minutes remaining.
            Continue the story based on history. If this is the start, use the prompt.
            Output JSON: { "title": "Chapter Title", "prose": "About 400 words of story", "score_type": "epic/horror/noir/scifi/whimsical/dramatic", "key_visual_moments": ["brief scene description 1", "brief scene description 2"] }
            Include 2-3 key visual moments that represent important scenes in this chapter.`;

            const promptText = `History: ${state.history.join(' ')}\n\nCurrent Focus: ${seedPrompt}`;
            
            try {
                // Always use Firebase proxy for story generation
                if (!window.fb || !window.fb.appCheck) {
                    throw new Error('Firebase configuration is required. Please configure Firebase and App Check to use Dreamweaver.');
                }
                
                console.log('Using Firebase proxy for story generation');
                
                // Wrap in retry logic
                const data = await retryWithBackoff(
                    async () => await callGenerateProxy(promptText, sys),
                    { operationName: 'Story Generation', maxRetries: 3 }
                );
                
                console.log('‚úì Successfully used Firebase proxy');
                
                // Validate response structure
                validateStoryResponse(data);
                
                const result = JSON.parse(data.candidates[0].content.parts[0].text);
                
                state.history.push(result.prose);
                state.lastProseContent = result.prose;
                
                // Append chapter content to the page
                appendChapter(result);
                
                // Intelligently select music based on prose content analysis
                await applyIntelligentScore(result.prose, result.score_type);
                
                // Pre-generate images for this chapter before reading begins
                await preGenerateChapterImages(result);
            } catch (err) {
                console.error('Error generating chapter:', err);
                
                // Show informative error banner
                if (err.message.includes('PROXY_NOT_CONFIGURED') || err.message.includes('Firebase configuration is required')) {
                    showTransientBanner('‚ö†Ô∏è Story Generation Failed: Firebase not configured. Please set up Firebase and deploy Cloud Functions to enable story generation. See server/README.md for setup instructions.', 'error');
                } else if (err.message.includes('PROXY_AUTH_FAILED') || err.message.includes('APP_CHECK')) {
                    showTransientBanner('‚ö†Ô∏è Story Generation Failed: App Check verification failed. Please configure reCAPTCHA v3 site key and ensure Firebase App Check is properly initialized.', 'error');
                } else if (err.message.includes('PROXY_UPSTREAM_ERROR')) {
                    showTransientBanner('‚ö†Ô∏è Story Generation Failed: API key issue. Please ensure your API key is configured in Firebase Functions: firebase functions:config:set genai.key="YOUR_KEY"', 'error');
                } else if (err.message.includes('PROXY_SERVER_ERROR')) {
                    showTransientBanner('‚ö†Ô∏è Story Generation Failed: Server error. Check Firebase Functions logs for details.', 'error');
                } else {
                    showTransientBanner(`‚ö†Ô∏è Story Generation Failed: ${err.message}`, 'error');
                }
                
                // Re-throw error to propagate to caller
                throw err;
            } finally {
                state.isGeneratingChapter = false;
            }
        }

        function appendChapter(data) {
            const container = document.getElementById('reader-content');
            const chapterSents = data.prose.match(/[^.!?]+[.!?]+(?=\s|$)/g) || [data.prose];
            const startIdx = state.sentences.length;
            
            // Track where this chapter starts
            state.chapterStartIndex = startIdx;
            // Reset flag for next chapter generation trigger
            state.nextChapterTriggered = false;
            
            document.getElementById('reader-title').innerText = data.title;
            
            chapterSents.forEach((text, i) => {
                const globalIdx = startIdx + i;
                const span = document.createElement('span');
                span.id = `s-${globalIdx}`;
                span.className = 'sentence-span';
                text.split(/\s+/).forEach((word, wi) => {
                    const wSpan = document.createElement('span');
                    wSpan.className = 'word-token';
                    wSpan.id = `s-${globalIdx}-w-${wi}`;
                    wSpan.innerText = word + ' ';
                    span.appendChild(wSpan);
                });
                container.appendChild(span);
                state.sentences.push(text);
            });
        }

        async function playCycle() {
            // Check if we should stop playback
            if (!state.isPlaying || state.currentIndex >= state.sentences.length) {
                if (shouldGenerateNextChapter()) {
                    await generateNextChapter("Continue the narrative smoothly.");
                    await playCycle();
                }
                return;
            }

            // In demo mode, skip chapter generation and image generation
            if (!state.isDemoMode) {
                // Calculate how many sentences are left in current chapter
                const sentencesLeftInChapter = state.sentences.length - state.currentIndex;
                const sentencesInCurrentChapter = state.sentences.length - state.chapterStartIndex;
                
                // Trigger next chapter generation when halfway through current chapter
                // This allows AI to write while reading
                // Only trigger once per chapter to avoid duplicate generation requests
                // Require at least 2 sentences in chapter to avoid edge cases with very short chapters
                if (!state.nextChapterTriggered && 
                    sentencesInCurrentChapter >= 2 && 
                    sentencesLeftInChapter > 0 &&
                    sentencesLeftInChapter <= Math.floor(sentencesInCurrentChapter / 2)) {
                    if (shouldGenerateNextChapter()) {
                        state.nextChapterTriggered = true;
                        // Generate in parallel without awaiting, so reading continues
                        generateNextChapter("Continue the narrative smoothly.").catch(err => {
                            console.error('Failed to generate next chapter in background:', err);
                            console.error('Context: Chapter generation failed mid-reading. System will retry when current chapter completes.');
                            // Note: If generation fails, the system will retry when playCycle reaches end of current chapter
                            // Reset flag after a delay to avoid rapid retries
                            setTimeout(() => { state.nextChapterTriggered = false; }, state.retryDelayMs);
                        });
                    }
                }

                // Trigger visual every 4 sentences - use cached images if available
                // Check if current index aligns with image generation points (every 4 sentences from chapter start)
                const sentencesIntoChapter = state.currentIndex - state.chapterStartIndex;
                if (sentencesIntoChapter >= 0 && sentencesIntoChapter % 4 === 0) {
                    if (state.imageCache.has(state.currentIndex)) {
                        displayCachedImage(state.currentIndex);
                    } else {
                        // Fallback: generate on-the-fly if not cached
                        updateVisual(state.currentIndex).catch(err => console.error('Visual generation error:', err));
                    }
                }
            }

            // Demo mode: Display text with highlighting but without TTS narration
            if (state.isDemoMode) {
                // Highlight current sentence
                highlight(state.currentIndex);
                
                // Use a fixed duration per sentence for demo mode (5 seconds for comfortable reading)
                const demoDurationMs = 5000;
                
                // Move to next sentence after delay
                setTimeout(() => {
                    if (state.isPlaying) {
                        state.currentIndex++;
                        playCycle().catch(err => console.error('Playback cycle error:', err));
                    }
                }, demoDurationMs);
                
                return;
            }

            // Normal mode with TTS narration
            let blob = state.audioBuffer.get(state.currentIndex);
            if (!blob) blob = await fetchTTS(state.sentences[state.currentIndex]);

            // Preload next sentences for seamless playback
            preloadNextSentences(state.currentIndex, 2);

            const audioUrl = URL.createObjectURL(blob);
            state.currentAudio.src = audioUrl;
            
            // Apply narrator volume
            const narratorVolControl = document.getElementById('narrator-vol');
            if (narratorVolControl) {
                state.currentAudio.volume = parseFloat(narratorVolControl.value) || 1;
            }
            
            // Start highlighting and word animation immediately
            highlight(state.currentIndex);
            
            const onMetadataLoaded = () => {
                animateWords(state.currentIndex);
                state.currentAudio.removeEventListener('loadedmetadata', onMetadataLoaded);
            };
            
            const onEnded = () => {
                URL.revokeObjectURL(audioUrl);
                state.currentAudio.removeEventListener('loadedmetadata', onMetadataLoaded);
                state.currentAudio.removeEventListener('ended', onEnded);
                state.currentIndex++;
                playCycle().catch(err => console.error('Playback cycle error:', err));
            };
            
            state.currentAudio.addEventListener('loadedmetadata', onMetadataLoaded);
            state.currentAudio.addEventListener('ended', onEnded);
            
            // Play immediately without delay
            state.currentAudio.play().catch(err => console.error('Audio playback error:', err));
        }
        
        function shouldGenerateNextChapter() {
            // Don't generate in demo mode
            if (state.isDemoMode) return false;
            
            // Don't generate if already generating
            if (state.isGeneratingChapter) return false;
            
            // Don't generate if no time left
            if (state.timeLeftSeconds <= 0) return false;
            
            // Estimate time needed for one chapter (avg sentences per chapter * seconds per sentence)
            const estimatedChapterDuration = state.averageSentencesPerChapter * state.estimatedSecondsPerSentence;
            
            // Only generate if we have enough time to read at least minTimeBufferRatio of the next chapter
            // This prevents starting chapters that won't have time to complete
            return state.timeLeftSeconds >= (estimatedChapterDuration * state.minTimeBufferRatio);
        }

        async function fetchTTS(text) {
            try {
                // Always use Firebase proxy for TTS
                if (!window.fb || !window.fb.appCheck) {
                    throw new Error('Firebase configuration is required for text-to-speech');
                }
                
                console.log('Using Firebase proxy for TTS');
                
                // Wrap in retry logic
                const data = await retryWithBackoff(
                    async () => await callTTSProxy(text, state.voice, state.accent),
                    { operationName: 'TTS Generation', maxRetries: 3 }
                );
                
                // Validate response structure
                validateTTSResponse(data);
                
                return base64ToWav(data.candidates[0].content.parts[0].inlineData.data, 24000);
            } catch (error) {
                console.error('TTS generation failed:', error);
                
                // Show error banner with specific guidance
                if (error.message && error.message.includes('PROXY_NOT_CONFIGURED')) {
                    showTransientBanner('‚ö†Ô∏è Text-to-Speech Failed: Firebase not configured. Please set up Firebase Cloud Functions and App Check. See server/README.md for instructions.', 'error');
                } else if (error.message && (error.message.includes('PROXY_AUTH_FAILED') || error.message.includes('APP_CHECK'))) {
                    showTransientBanner('‚ö†Ô∏è Text-to-Speech Failed: App Check verification failed. Please configure reCAPTCHA v3 site key.', 'error');
                } else if (error.message && error.message.includes('TTS_PROXY_ERROR')) {
                    showTransientBanner('‚ö†Ô∏è Text-to-Speech Failed: Backend API issue. Ensure API key is configured in Firebase Functions: firebase functions:config:set genai.key="YOUR_KEY"', 'error');
                } else if (error.message && error.message.includes('Firebase configuration is required')) {
                    showTransientBanner('‚ö†Ô∏è Text-to-Speech Failed: Firebase not configured. Please set up Firebase Cloud Functions.', 'error');
                } else {
                    showTransientBanner(`‚ö†Ô∏è Text-to-Speech Failed: ${error.message}`, 'error');
                }
                
                throw error;
            }
        }

        function base64ToWav(base64, rate) {
            const bin = atob(base64);
            const buf = new ArrayBuffer(bin.length);
            const view = new Uint8Array(buf);
            for (let i = 0; i < bin.length; i++) view[i] = bin.charCodeAt(i);
            const header = new ArrayBuffer(44);
            const hView = new DataView(header);
            const writeStr = (off, s) => { for (let i = 0; i < s.length; i++) hView.setUint8(off + i, s.charCodeAt(i)); };
            writeStr(0, 'RIFF'); hView.setUint32(4, 36 + buf.byteLength, true); writeStr(8, 'WAVE'); writeStr(12, 'fmt ');
            hView.setUint32(16, 16, true); hView.setUint16(20, 1, true); hView.setUint16(22, 1, true); hView.setUint32(24, rate, true);
            hView.setUint32(28, rate * 2, true); hView.setUint16(32, 2, true); hView.setUint16(34, 16, true); writeStr(36, 'data');
            hView.setUint32(40, buf.byteLength, true);
            return new Blob([header, buf], { type: 'audio/wav' });
        }

        async function updateVisual(idx) {
            if (state.isGeneratingVisual) return;
            state.isGeneratingVisual = true;
            document.getElementById('img-overlay').classList.remove('opacity-0');
            const context = state.sentences.slice(idx, idx+2).join(' ');
            try {
                // Always use Firebase proxy for image generation
                if (!window.fb || !window.fb.appCheck) {
                    throw new Error('Firebase configuration is required for image generation');
                }
                
                const prompt = `Cinematic professional fantasy art, atmospheric, ${state.genre} style: ${context}`;
                console.log('Using Firebase proxy for image generation');
                const data = await callImageProxy(prompt);
                
                // Validate response structure
                if (!data || !data.candidates || !data.candidates[0] || 
                    !data.candidates[0].content || !data.candidates[0].content.parts || 
                    !data.candidates[0].content.parts[0] || !data.candidates[0].content.parts[0].inlineData) {
                    throw new Error('Invalid API response structure: missing image data');
                }
                
                const img = document.getElementById('scene-image');
                img.src = `data:image/png;base64,${data.candidates[0].content.parts[0].inlineData.data}`;
                img.onload = () => {
                    img.classList.remove('opacity-0');
                    document.getElementById('img-overlay').classList.add('opacity-0');
                };
            } catch (err) {
                console.error('Visual generation error:', err);
                
                // Show error banner with specific guidance
                if (err.message && err.message.includes('PROXY_NOT_CONFIGURED')) {
                    showTransientBanner('‚ö†Ô∏è Image Generation Failed: Firebase not configured. Please set up Firebase Cloud Functions.', 'warning');
                } else if (err.message && (err.message.includes('PROXY_AUTH_FAILED') || err.message.includes('APP_CHECK'))) {
                    showTransientBanner('‚ö†Ô∏è Image Generation Failed: App Check verification failed.', 'warning');
                } else if (err.message && err.message.includes('IMAGE_PROXY_ERROR')) {
                    showTransientBanner('‚ö†Ô∏è Image Generation Failed: Backend API issue. Check Firebase Functions configuration.', 'warning');
                } else if (err.message && err.message.includes('Firebase configuration is required')) {
                    // Don't show banner for config errors (shown once during init)
                    console.log('Image generation skipped - Firebase not configured');
                } else {
                    showTransientBanner(`‚ö†Ô∏è Image Generation Failed: ${err.message}`, 'warning');
                }
                
                // Hide overlay on error to avoid blocking the UI
                document.getElementById('img-overlay').classList.add('opacity-0');
            } finally { 
                state.isGeneratingVisual = false; 
            }
        }

        function startTimerDisplay() {
            const el = document.getElementById('session-timer');
            el.classList.remove('hidden');
            const iv = setInterval(() => {
                if (state.timeLeftSeconds <= 0) {
                    clearInterval(iv);
                    // Auto-stop playback when time is up
                    if (state.isPlaying) {
                        state.isPlaying = false;
                        state.currentAudio.pause();
                        state.music.pause();
                        document.getElementById('icon-play').classList.remove('hidden');
                        document.getElementById('icon-pause').classList.add('hidden');
                    }
                    return;
                }
                if (state.isPlaying) state.timeLeftSeconds--;
                const h = Math.floor(state.timeLeftSeconds / 3600);
                const m = Math.floor((state.timeLeftSeconds % 3600) / 60);
                const s = state.timeLeftSeconds % 60;
                el.innerText = `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
            }, 1000);
        }

        function highlight(idx) {
            document.querySelectorAll('.sentence-span').forEach((el, i) => {
                el.classList.toggle('sentence-active', i === idx);
            });
            // Auto-scroll the active sentence into view as story progresses
            const el = document.getElementById(`s-${idx}`);
            if (el) {
                el.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function animateWords(sIdx) {
            const words = state.sentences[sIdx].split(/\s+/);
            const duration = state.currentAudio.duration || 2;
            const step = (duration * 1000) / words.length;
            let w = 0;
            const iv = setInterval(() => {
                if (!state.isPlaying || w >= words.length) { clearInterval(iv); return; }
                document.querySelectorAll('.word-active').forEach(e => e.classList.remove('word-active'));
                const el = document.getElementById(`s-${sIdx}-w-${w}`);
                if (el) {
                    el.classList.add('word-active');
                    document.getElementById('current-word').innerText = words[w];
                }
                w++;
            }, step);
        }

        function applyScore(type) {
            const track = SCORE_LIBRARY[type] || SCORE_LIBRARY.dramatic;
            if (state.music.src !== track.url) {
                state.music.src = track.url;
                state.music.loop = true;
                // Don't auto-play - music will be controlled by togglePlayback()
            }
            const badge = document.getElementById('vibe-badge');
            badge.innerText = `Atmosphere: ${track.name}`;
            badge.classList.remove('opacity-0');
            const musicStatus = document.getElementById('music-status');
            const musicSourceDisplay = document.getElementById('music-source-display');
            const musicSource = document.getElementById('music-source-select')?.value || 'spotify';
            
            if (musicSource === 'spotify' || state.isUsingSpotify) {
                // Show Spotify track name if available
                if (state.currentSpotifyTrack) {
                    musicStatus.innerText = `${state.currentSpotifyTrack.name}`;
                    if (musicSourceDisplay) musicSourceDisplay.innerText = `Source: Spotify`;
                } else {
                    musicStatus.innerText = track.name;
                    if (musicSourceDisplay) musicSourceDisplay.innerText = `Source: Default`;
                }
            } else if (musicSource === 'local') {
                musicStatus.innerText = track.name;
                if (musicSourceDisplay) musicSourceDisplay.innerText = `Source: Local Files`;
            } else if (musicSource === 'youtube') {
                musicStatus.innerText = track.name;
                if (musicSourceDisplay) musicSourceDisplay.innerText = `Source: YouTube`;
            } else {
                musicStatus.innerText = track.name;
                if (musicSourceDisplay) musicSourceDisplay.innerText = `Source: Default`;
            }
            
            document.getElementById('genre-icon').innerText = track.icon;
        }

        async function applyIntelligentScore(proseText, suggestedType) {
            // Analyze prose content to intelligently select music
            const lowerText = proseText.toLowerCase();
            const scores = {};
            
            // Calculate score for each music type based on keyword matching
            for (const [key, track] of Object.entries(SCORE_LIBRARY)) {
                let score = 0;
                for (const keyword of track.keywords) {
                    // Escape special regex characters to prevent injection
                    const escapedKeyword = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(`\\b${escapedKeyword}\\w*\\b`, 'gi');
                    const matches = lowerText.match(regex);
                    score += matches ? matches.length : 0;
                }
                scores[key] = score;
            }
            
            // Find the music type with highest score
            let bestMatch = suggestedType;
            let highestScore = scores[suggestedType] || 0;
            
            for (const [key, score] of Object.entries(scores)) {
                if (score > highestScore) {
                    highestScore = score;
                    bestMatch = key;
                }
            }
            
            // Only change music if we found a strong match (at least MUSIC_SELECTION_MIN_SCORE keyword occurrences)
            // or if this is the first chapter
            if (highestScore >= MUSIC_SELECTION_MIN_SCORE || state.currentMood === null) {
                state.currentMood = bestMatch;
                
                // Try Spotify first if logged in
                if (state.spotifyAccessToken) {
                    const track = await searchSpotifyTracks(bestMatch, state.genre);
                    if (track) {
                        const success = await playSpotifyTrack(track);
                        if (success) {
                            console.log(`Intelligent music selection (Spotify): ${track.name} for mood ${bestMatch} (score: ${highestScore}, suggested: ${suggestedType})`);
                            return;
                        }
                    }
                }
                
                // Fallback to default music
                applyScore(bestMatch);
                console.log(`Intelligent music selection: ${bestMatch} (score: ${highestScore}, suggested: ${suggestedType})`);
            } else {
                // Fall back to suggested type if analysis is weak
                state.currentMood = suggestedType;
                
                // Try Spotify first if logged in
                if (state.spotifyAccessToken) {
                    const track = await searchSpotifyTracks(suggestedType, state.genre);
                    if (track) {
                        const success = await playSpotifyTrack(track);
                        if (success) {
                            console.log(`Using suggested music (Spotify): ${track.name} for ${suggestedType} (analysis score too low: ${highestScore})`);
                            return;
                        }
                    }
                }
                
                // Fallback to default music
                applyScore(suggestedType);
                console.log(`Using suggested music: ${suggestedType} (analysis score too low: ${highestScore})`);
            }
        }

        async function preGenerateChapterImages(chapterData) {
            // Generate images for key visual moments before chapter reading begins
            const visualMoments = chapterData.key_visual_moments || [];
            
            if (visualMoments.length === 0) {
                // Fallback: generate images based on chapter content
                const sentences = chapterData.prose.match(/[^.!?]+[.!?]+(?=\s|$)/g) || [];
                // Generate images for every 4 sentences
                for (let i = 0; i < sentences.length; i += 4) {
                    const context = sentences.slice(i, Math.min(i + 4, sentences.length)).join(' ');
                    visualMoments.push(context);
                }
            }
            
            // Pre-generate first image immediately for display
            if (visualMoments.length > 0) {
                const startIdx = state.chapterStartIndex;
                await generateAndCacheImage(startIdx, visualMoments[0]);
                
                // Display the first image immediately since chapter will start from here
                if (state.imageCache.has(startIdx)) {
                    displayCachedImage(startIdx);
                }
                
                // Queue remaining images for background generation
                for (let i = 1; i < visualMoments.length; i++) {
                    const sentenceIdx = startIdx + (i * 4);
                    state.imageQueue.push({
                        index: sentenceIdx,
                        prompt: visualMoments[i]
                    });
                }
                
                // Start background image generation (don't await to avoid blocking)
                // Check if queue processing is already running to prevent race conditions
                if (!state.isProcessingImageQueue) {
                    processImageQueue();
                }
            }
        }

        async function generateAndCacheImage(sentenceIdx, promptText) {
            if (state.imageCache.has(sentenceIdx)) return;
            
            try {
                // Always use Firebase proxy for image generation
                if (!window.fb || !window.fb.appCheck) {
                    throw new Error('Firebase configuration is required for image generation');
                }
                
                const prompt = `Cinematic professional fantasy art, atmospheric, ${state.genre} style: ${promptText}`;
                
                // Wrap in retry logic
                const data = await retryWithBackoff(
                    async () => await callImageProxy(prompt),
                    { operationName: 'Image Generation', maxRetries: 2 } // Fewer retries for images
                );
                
                // Validate response structure
                if (!data || !data.candidates || !data.candidates[0] || 
                    !data.candidates[0].content || !data.candidates[0].content.parts || 
                    !data.candidates[0].content.parts[0] || !data.candidates[0].content.parts[0].inlineData) {
                    throw new Error('Invalid API response structure: missing image data');
                }
                
                const imageData = `data:image/png;base64,${data.candidates[0].content.parts[0].inlineData.data}`;
                state.imageCache.set(sentenceIdx, imageData);
                console.log(`Pre-generated image for sentence ${sentenceIdx}`);
            } catch (err) {
                console.error(`Failed to pre-generate image for sentence ${sentenceIdx}:`, err);
                // Image generation failures shouldn't block the story flow
            }
        }

        async function processImageQueue() {
            // Prevent multiple concurrent queue processing
            if (state.isProcessingImageQueue) return;
            state.isProcessingImageQueue = true;
            
            try {
                // Process queued images in background, one at a time
                while (state.imageQueue.length > 0) {
                    const { index, prompt } = state.imageQueue.shift();
                    await generateAndCacheImage(index, prompt);
                    // Small delay to avoid overwhelming the API
                    await new Promise(resolve => setTimeout(resolve, IMAGE_QUEUE_DELAY_MS));
                }
            } finally {
                state.isProcessingImageQueue = false;
            }
        }

        function displayCachedImage(sentenceIdx) {
            if (!state.imageCache.has(sentenceIdx)) return;
            
            const img = document.getElementById('scene-image');
            const overlay = document.getElementById('img-overlay');
            
            img.src = state.imageCache.get(sentenceIdx);
            img.onload = () => {
                img.classList.remove('opacity-0');
                overlay.classList.add('opacity-0');
            };
            
            state.lastImageIndex = sentenceIdx;
            console.log(`Displayed cached image for sentence ${sentenceIdx}`);
        }

        async function preloadAudio(idx) {
            if (idx >= state.sentences.length || state.audioBuffer.has(idx)) return;
            const b = await fetchTTS(state.sentences[idx]);
            state.audioBuffer.set(idx, b);
        }

        function preloadNextSentences(currentIdx, count) {
            for (let i = 1; i <= count; i++) {
                const nextIdx = currentIdx + i;
                if (!state.audioBuffer.has(nextIdx)) {
                    preloadAudio(nextIdx).catch(err => console.error('Preload error:', err));
                }
            }
        }

        function togglePlayback() {
            state.isPlaying = !state.isPlaying;
            document.getElementById('icon-play').classList.toggle('hidden', state.isPlaying);
            document.getElementById('icon-pause').classList.toggle('hidden', !state.isPlaying);
            if (state.isPlaying) { 
                // Control music playback based on selected source
                const musicSource = document.getElementById('music-source-select')?.value || 'spotify';
                if (musicSource === 'spotify' || state.isUsingSpotify) {
                    // Use existing Spotify logic
                    state.music.play().catch(err => console.error('Music playback error:', err)); 
                } else {
                    // Use MusicPlayer for local/YouTube
                    if (typeof MusicPlayer !== 'undefined') {
                        MusicPlayer.play();
                        // Sync volume from music volume slider
                        const volControl = document.getElementById('music-vol');
                        if (volControl) {
                            const MUSIC_PLAYER_VOLUME_SCALE = 2; // Scale factor for MusicPlayer volume
                            MusicPlayer.setVolume(parseFloat(volControl.value) * MUSIC_PLAYER_VOLUME_SCALE);
                        }
                    }
                }
                playCycle().catch(err => console.error('Playback cycle error:', err));
                
                // Start settings interval for auto-save and recording updates
                if (typeof startSettingsInterval !== 'undefined') {
                    startSettingsInterval();
                }
            } 
            else { 
                if (state.currentAudio) {
                    state.currentAudio.pause();
                }
                // Pause music based on selected source
                const musicSource = document.getElementById('music-source-select')?.value || 'spotify';
                if (musicSource === 'spotify' || state.isUsingSpotify) {
                    state.music.pause(); 
                } else {
                    if (typeof MusicPlayer !== 'undefined') {
                        MusicPlayer.pause();
                    }
                }
                
                // Stop settings interval when paused
                if (typeof stopSettingsInterval !== 'undefined') {
                    stopSettingsInterval();
                }
            }
        }

        function stopPlayback() {
            // Stop playback
            state.isPlaying = false;
            if (state.currentAudio) {
                state.currentAudio.pause();
            }
            
            // Pause music based on selected source
            const musicSource = document.getElementById('music-source-select')?.value || 'spotify';
            if (musicSource === 'spotify' || state.isUsingSpotify) {
                state.music.pause();
            } else {
                if (typeof MusicPlayer !== 'undefined') {
                    MusicPlayer.pause();
                }
            }
            
            // Update UI to ensure consistency even if already stopped
            document.getElementById('icon-play').classList.remove('hidden');
            document.getElementById('icon-pause').classList.add('hidden');
            
            // Clear word highlighting
            document.querySelectorAll('.word-active').forEach(e => e.classList.remove('word-active'));
            document.getElementById('current-word').innerText = '...';
        }

        function restartPlayback() {
            // Stop current playback
            stopPlayback();
            
            // Reset to beginning
            state.currentIndex = 0;
            
            // Clear all highlighting
            document.querySelectorAll('.sentence-span').forEach(el => {
                el.classList.remove('sentence-active');
            });
            document.querySelectorAll('.word-active').forEach(e => e.classList.remove('word-active'));
            
            // Scroll to top
            const firstSentence = document.getElementById('s-0');
            if (firstSentence) {
                firstSentence.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
            
            // Start playing from beginning
            setTimeout(() => {
                togglePlayback();
            }, RESTART_PLAYBACK_DELAY_MS);
        }

        async function changeVoice(selectedVoice) {
            const wasPlaying = state.isPlaying;
            const currentPosition = state.currentIndex;
            
            // Pause playback if currently playing
            if (wasPlaying) {
                state.isPlaying = false;
                state.currentAudio.pause();
            }
            
            // Update voice configuration
            const voiceConfig = VOICES[selectedVoice];
            if (!voiceConfig) {
                console.error('Invalid voice selection:', selectedVoice);
                return;
            }
            
            state.voice = voiceConfig.name;
            state.accent = voiceConfig.accent;
            
            // Clear audio buffer to force regeneration with new voice
            state.audioBuffer.clear();
            
            // Update both voice selectors to stay in sync
            document.getElementById('voice-select').value = selectedVoice;
            document.getElementById('voice-select-reader').value = selectedVoice;
            
            // Preload next few sentences with new voice
            const preloadPromises = [];
            for (let i = currentPosition; i < Math.min(currentPosition + 3, state.sentences.length); i++) {
                preloadPromises.push(preloadAudio(i));
            }
            await Promise.all(preloadPromises);
            
            // Resume playback if it was playing before
            if (wasPlaying) {
                state.isPlaying = true;
                playCycle().catch(err => console.error('Playback cycle error:', err));
                state.music.play().catch(err => console.error('Music playback error:', err));
            }
        }

        function switchView(v) {
            document.getElementById('view-home').classList.toggle('hidden', v !== 'home');
            document.getElementById('view-reader').classList.toggle('hidden', v !== 'reader');
            document.getElementById('control-panel').classList.toggle('hidden', v !== 'reader');
            
            // Update reader playlist display when switching to reader view
            if (v === 'reader') {
                updateReaderPlaylistDisplay();
                updateSettingsDisplay();
            }
        }
        
        function updateSettingsDisplay() {
            // Update genre display
            const genreDisplay = document.getElementById('display-genre');
            if (genreDisplay) {
                genreDisplay.textContent = state.genre || 'Fantasy';
            }
            
            // Update duration display
            const durationDisplay = document.getElementById('display-duration');
            if (durationDisplay) {
                if (state.sleepMode) {
                    durationDisplay.textContent = 'Sleep Mode';
                } else {
                    const minutes = Math.floor(state.timeLeftSeconds / 60);
                    if (minutes >= 60) {
                        const hours = Math.floor(minutes / 60);
                        durationDisplay.textContent = hours === 1 ? '1 Hour' : `${hours} Hours`;
                    } else {
                        durationDisplay.textContent = `${minutes} Minutes`;
                    }
                }
            }
            
            // Update score dynamics display
            const scoreSensitivity = document.getElementById('score-sensitivity')?.value || 3;
            const dynamicsDisplay = document.getElementById('display-dynamics');
            if (dynamicsDisplay) {
                dynamicsDisplay.textContent = `${scoreSensitivity}/5`;
            }
            
            // Update dynamics bars
            for (let i = 1; i <= 5; i++) {
                const bar = document.getElementById(`dynamics-bar-${i}`);
                if (bar) {
                    if (i <= scoreSensitivity) {
                        bar.classList.remove('bg-slate-600');
                        bar.classList.add('bg-indigo-500');
                    } else {
                        bar.classList.remove('bg-indigo-500');
                        bar.classList.add('bg-slate-600');
                    }
                }
            }
            
            // Update music source display
            const musicSourceDisplay = document.getElementById('display-music-source');
            if (musicSourceDisplay) {
                const source = state.musicSource || 'spotify';
                const sourceNames = {
                    'spotify': 'Spotify',
                    'local': 'Local Files',
                    'youtube': 'YouTube'
                };
                musicSourceDisplay.textContent = sourceNames[source] || 'Spotify';
            }
        }
        
        function updateMusicDisplayForSource(source) {
            const musicStatus = document.getElementById('music-status');
            const musicSourceDisplay = document.getElementById('music-source-display');
            
            if (!musicStatus || !musicSourceDisplay) return;
            
            // Get info from MusicPlayer about what's loaded
            if (source === 'local' && typeof MusicPlayer !== 'undefined') {
                const debugState = MusicPlayer._debugState();
                if (debugState.localTracks && debugState.localTracks.length > 0) {
                    const idx = debugState.localIndex;
                    // Validate index is within bounds
                    if (idx >= 0 && idx < debugState.localTracks.length) {
                        const currentTrack = debugState.localTracks[idx];
                        musicStatus.textContent = currentTrack ? currentTrack.name : 'Local Files Ready';
                        musicSourceDisplay.textContent = 'Source: Local Files';
                    } else {
                        musicStatus.textContent = 'Local Files Ready';
                        musicSourceDisplay.textContent = 'Source: Local Files';
                    }
                } else {
                    musicStatus.textContent = 'No local files loaded';
                    musicSourceDisplay.textContent = 'Source: Local Files (None Loaded)';
                }
            } else if (source === 'youtube' && typeof MusicPlayer !== 'undefined') {
                const debugState = MusicPlayer._debugState();
                if (debugState.ytQueue && debugState.ytQueue.length > 0) {
                    const idx = debugState.ytIndex || 0;
                    // Validate index is within bounds
                    if (idx >= 0 && idx < debugState.ytQueue.length) {
                        const currentVideoId = debugState.ytQueue[idx];
                        musicStatus.textContent = `Video ID: ${currentVideoId}`;
                        musicSourceDisplay.textContent = 'Source: YouTube';
                    } else {
                        // Fallback to first video if index is invalid
                        musicStatus.textContent = `Video ID: ${debugState.ytQueue[0]}`;
                        musicSourceDisplay.textContent = 'Source: YouTube';
                    }
                } else {
                    // Check if a video was loaded (check YouTube input)
                    const ytInput = document.getElementById('youtube-url-input');
                    if (ytInput && ytInput.value) {
                        musicStatus.textContent = `YouTube: ${ytInput.value}`;
                        musicSourceDisplay.textContent = 'Source: YouTube';
                    } else {
                        musicStatus.textContent = 'No YouTube video loaded';
                        musicSourceDisplay.textContent = 'Source: YouTube (None Loaded)';
                    }
                }
            } else if (source === 'spotify') {
                if (state.spotifyAccessToken && state.currentSpotifyTrack) {
                    musicStatus.textContent = `${state.currentSpotifyTrack.name} - ${state.currentSpotifyTrack.artists[0].name}`;
                    musicSourceDisplay.textContent = 'Source: Spotify';
                } else {
                    musicStatus.textContent = 'Using Default Music Library';
                    musicSourceDisplay.textContent = 'Source: Default';
                }
            }
        }
        
        // Music playback control functions for playlist/queue navigation
        function musicPrev() {
            if (typeof MusicPlayer !== 'undefined') {
                MusicPlayer.prev();
            }
        }
        
        function musicNext() {
            if (typeof MusicPlayer !== 'undefined') {
                MusicPlayer.next();
            }
        }
        
        function musicReplay() {
            if (typeof MusicPlayer !== 'undefined') {
                MusicPlayer.replay();
            }
        }
        
        /**
         * Toggle the visibility of the tally display panel
         * Shows or hides playlist statistics and updates button text
         */
        function toggleTallyDisplay() {
            const tallyDisplay = document.getElementById('tally-display');
            const tallyBtn = document.getElementById('tally-btn-text');
            if (!tallyDisplay) return;
            
            if (tallyDisplay.classList.contains('hidden')) {
                tallyDisplay.classList.remove('hidden');
                if (tallyBtn) tallyBtn.textContent = 'Hide Tally';
                updateTallyDisplay();
            } else {
                tallyDisplay.classList.add('hidden');
                if (tallyBtn) tallyBtn.textContent = 'Show Tally';
            }
        }
        
        /**
         * Update the tally display with current playlist statistics
         * Only updates if the tally display is currently visible
         * Calculates total playlists, total items, and current playlist items
         */
        function updateTallyDisplay() {
            const tallyDisplay = document.getElementById('tally-display');
            // Only update if tally is visible (performance optimization)
            if (!tallyDisplay || tallyDisplay.classList.contains('hidden')) return;
            
            if (typeof MusicPlayer === 'undefined' || !MusicPlayer.getPlaylists) return;
            
            const playlists = MusicPlayer.getPlaylists();
            const playlistSelect = document.getElementById('playlist-select');
            const activePlaylistId = playlistSelect ? playlistSelect.value : '';
            
            // Count total playlists
            const totalPlaylists = Object.keys(playlists).length;
            
            // Count total items across all playlists
            let totalItems = 0;
            Object.values(playlists).forEach(playlist => {
                totalItems += playlist.items.length;
            });
            
            // Count items in currently selected playlist
            let currentItems = 0;
            if (activePlaylistId && playlists[activePlaylistId]) {
                currentItems = playlists[activePlaylistId].items.length;
            }
            
            // Update display
            const totalPlaylistsEl = document.getElementById('tally-total-playlists');
            const totalItemsEl = document.getElementById('tally-total-items');
            const currentItemsEl = document.getElementById('tally-current-items');
            
            if (totalPlaylistsEl) totalPlaylistsEl.textContent = totalPlaylists;
            if (totalItemsEl) totalItemsEl.textContent = totalItems;
            if (currentItemsEl) currentItemsEl.textContent = currentItems;
        }
        
        // Delete current playlist function
        function deleteCurrentPlaylist() {
            const playlistSelect = document.getElementById('playlist-select');
            if (!playlistSelect || !playlistSelect.value) {
                alert('Please select a playlist to delete');
                return;
            }
            
            if (confirm('Are you sure you want to delete this playlist? This cannot be undone.')) {
                if (typeof MusicPlayer !== 'undefined') {
                    MusicPlayer.deletePlaylist(playlistSelect.value);
                }
            }
        }
        
        // Add current track to playlist based on selected music source
        function addCurrentTrackToPlaylist() {
            const playlistSelect = document.getElementById('playlist-select');
            if (!playlistSelect || !playlistSelect.value) {
                alert('Please select or create a playlist first');
                return;
            }
            
            const musicSource = document.getElementById('music-source-select')?.value || 'spotify';
            
            if (musicSource === 'spotify') {
                // Add Spotify track
                if (state.currentSpotifyTrack) {
                    const trackData = {
                        uri: state.currentSpotifyTrack.uri,
                        id: state.currentSpotifyTrack.id,
                        name: state.currentSpotifyTrack.name,
                        artist: state.currentSpotifyTrack.artists[0].name,
                        previewUrl: state.currentSpotifyTrack.preview_url
                    };
                    const trackName = `${trackData.name} - ${trackData.artist}`;
                    MusicPlayer.addToPlaylist(playlistSelect.value, 'spotify', trackData, trackName);
                    alert('Spotify track added to playlist!');
                } else {
                    alert('No Spotify track is currently playing. Please play a track first or connect to Spotify.');
                }
            } else if (musicSource === 'youtube') {
                // Add YouTube video
                const ytInput = document.getElementById('youtube-url-input');
                if (ytInput && ytInput.value.trim()) {
                    // Use MusicPlayer's parseYouTubeId function or extract it ourselves
                    const val = ytInput.value.trim();
                    let id = null;
                    
                    // Simple YouTube ID extraction
                    try {
                        if (val.length === 11 && /^[A-Za-z0-9_-]+$/.test(val)) {
                            id = val;
                        } else {
                            const u = new URL(val);
                            if (u.hostname === 'www.youtube.com' || u.hostname === 'youtube.com' || u.hostname === 'm.youtube.com') {
                                id = u.searchParams.get('v');
                            } else if (u.hostname === 'youtu.be') {
                                id = u.pathname.slice(1);
                            }
                        }
                    } catch (e) {
                        if (val.length === 11) id = val;
                    }
                    
                    if (id) {
                        MusicPlayer.addToPlaylist(playlistSelect.value, 'youtube', id, `YouTube: ${id}`);
                        alert('YouTube video added to playlist!');
                    } else {
                        alert('Please enter a valid YouTube URL or ID first');
                    }
                } else {
                    alert('Please enter a YouTube URL first');
                }
            } else if (musicSource === 'local') {
                // Local files - add metadata note
                alert('Local files are session-only and cannot be permanently saved to playlists. To use local files across sessions, please re-upload them each time.');
            }
        }
        
        // Function to play Spotify track from playlist
        window.playSpotifyTrackFromPlaylist = async function(trackData) {
            if (!state.spotifyAccessToken) {
                alert('Please connect to Spotify first to play this track.');
                return;
            }
            
            // Create a track object compatible with playSpotifyTrack
            const track = {
                uri: trackData.uri,
                id: trackData.id,
                name: trackData.name,
                artists: [{ name: trackData.artist }],
                preview_url: trackData.previewUrl
            };
            
            // Use existing playSpotifyTrack function
            const success = await playSpotifyTrack(track);
            if (!success) {
                console.warn('Failed to play Spotify track from playlist');
            }
        };
        
        // Toggle playlist visibility in reader view
        function toggleReaderPlaylist() {
            const itemsDiv = document.getElementById('reader-playlist-items');
            const icon = document.getElementById('playlist-toggle-icon');
            if (itemsDiv.classList.contains('hidden')) {
                itemsDiv.classList.remove('hidden');
                icon.textContent = '‚ñ≤';
            } else {
                itemsDiv.classList.add('hidden');
                icon.textContent = '‚ñº';
            }
        }
        
        // Switch active playlist in reader view
        function switchReaderPlaylist(playlistId) {
            if (playlistId && typeof MusicPlayer !== 'undefined') {
                MusicPlayer.loadPlaylist(playlistId);
                updateReaderPlaylistDisplay();
            } else {
                // No playlist selected
                const itemsDiv = document.getElementById('reader-playlist-items');
                itemsDiv.innerHTML = '<div class="text-xs text-slate-400 text-center py-2">No playlist selected</div>';
            }
        }
        
        // Update reader playlist display
        function updateReaderPlaylistDisplay() {
            if (typeof MusicPlayer === 'undefined') return;
            
            const debugState = MusicPlayer._debugState();
            const playlists = MusicPlayer.getPlaylists();
            const activePlaylistId = MusicPlayer.getActivePlaylist();
            
            // Update dropdown
            const select = document.getElementById('reader-playlist-select');
            if (select) {
                select.innerHTML = '<option value="">No Playlist (Manual Control)</option>';
                Object.keys(playlists).forEach(id => {
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = playlists[id].name + ' (' + playlists[id].items.length + ' items)';
                    if (id === activePlaylistId) option.selected = true;
                    select.appendChild(option);
                });
            }
            
            // Update items display
            const itemsDiv = document.getElementById('reader-playlist-items');
            if (!itemsDiv || !activePlaylistId || !playlists[activePlaylistId]) {
                if (itemsDiv) {
                    itemsDiv.innerHTML = '<div class="text-xs text-slate-400 text-center py-2">No playlist selected</div>';
                }
                return;
            }
            
            const playlist = playlists[activePlaylistId];
            const playlistIndex = debugState.playlistIndex || 0;
            itemsDiv.innerHTML = '';
            
            if (playlist.items.length === 0) {
                itemsDiv.innerHTML = '<div class="text-xs text-slate-400 text-center py-2">Playlist is empty</div>';
                return;
            }
            
            playlist.items.forEach((item, index) => {
                const itemEl = document.createElement('div');
                itemEl.className = 'flex items-center justify-between p-2 rounded-lg hover:bg-slate-700/50 transition-colors cursor-pointer';
                
                // Highlight currently playing item
                if (index === playlistIndex && activePlaylistId) {
                    itemEl.className += ' bg-indigo-600/20 border border-indigo-500/30';
                }
                
                // Add icon based on source type
                const iconEl = document.createElement('span');
                iconEl.className = 'text-xs mr-2';
                if (item.type === 'spotify') {
                    iconEl.innerHTML = 'üéµ';
                } else if (item.type === 'youtube') {
                    iconEl.innerHTML = '‚ñ∂Ô∏è';
                } else if (item.type === 'local') {
                    iconEl.innerHTML = 'üìÅ';
                }
                
                const nameEl = document.createElement('span');
                nameEl.className = 'text-xs flex-1 truncate';
                nameEl.textContent = item.name;
                
                // Highlight currently playing
                if (index === playlistIndex && activePlaylistId) {
                    nameEl.className += ' text-indigo-300 font-bold';
                } else {
                    nameEl.className += ' text-slate-300';
                }
                
                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'flex items-center flex-1 min-w-0';
                contentWrapper.appendChild(iconEl);
                contentWrapper.appendChild(nameEl);
                
                // Click to play this item
                itemEl.onclick = () => {
                    if (typeof MusicPlayer !== 'undefined' && MusicPlayer._debugState) {
                        // Use the internal playPlaylistItem through the exposed next/prev
                        // Or we can add a new exposed function
                        playPlaylistItemByIndex(index);
                    }
                };
                
                itemEl.appendChild(contentWrapper);
                itemsDiv.appendChild(itemEl);
            });
        }
        
        // Play specific playlist item by index
        function playPlaylistItemByIndex(index) {
            if (typeof MusicPlayer === 'undefined') return;
            
            // Use the MusicPlayer's exposed playPlaylistItem function
            MusicPlayer.playPlaylistItem(index);
            
            // Update display to show current item
            updateReaderPlaylistDisplay();
        }

        window.onload = () => {
            // Check for file:// protocol and show warning banner
            if (window.location.protocol === 'file:') {
                const warningBanner = document.getElementById('file-protocol-warning');
                if (warningBanner) {
                    warningBanner.classList.remove('hidden');
                }
                
                // Also log to console
                console.warn('‚ö†Ô∏è Running from file:// protocol detected!');
                console.warn('This may cause issues with:');
                console.warn('  ‚Ä¢ Spotify Web Playback SDK postMessage origin errors');
                console.warn('  ‚Ä¢ YouTube IFrame API restrictions');
                console.warn('  ‚Ä¢ API CORS/referrer restrictions');
                console.warn('  ‚Ä¢ OAuth redirect URIs');
                console.warn('');
                console.warn('Recommended: Serve over HTTP using:');
                console.warn('  python -m http.server 8000');
                console.warn('  Then visit: http://localhost:8000/index.html');
            }
            
            const vs = document.getElementById('voice-select');
            const vsReader = document.getElementById('voice-select-reader');
            Object.keys(VOICES).forEach(label => {
                const o = document.createElement('option');
                o.value = label;
                o.textContent = label;
                vs.appendChild(o);
                
                // Also populate reader voice selector
                const oReader = document.createElement('option');
                oReader.value = label;
                oReader.textContent = label;
                vsReader.appendChild(oReader);
            });
            
            // Connect music volume control
            const DEFAULT_VOLUME = 0.15;
            const MAX_VOLUME = 0.5;
            const validateVolume = (value) => {
                const vol = parseFloat(value);
                return isNaN(vol) ? DEFAULT_VOLUME : Math.max(0, Math.min(MAX_VOLUME, vol));
            };
            
            const volControl = document.getElementById('music-vol');
            if (volControl) {
                state.music.volume = validateVolume(volControl.value);
                volControl.addEventListener('input', (e) => {
                    state.music.volume = validateVolume(e.target.value);
                    // Also update MusicPlayer volume if using local/YouTube
                    const musicSource = document.getElementById('music-source-select')?.value || 'spotify';
                    if (musicSource !== 'spotify' && typeof MusicPlayer !== 'undefined') {
                        const MUSIC_PLAYER_VOLUME_SCALE = 2; // Scale factor for MusicPlayer volume
                        MusicPlayer.setVolume(validateVolume(e.target.value) * MUSIC_PLAYER_VOLUME_SCALE);
                    }
                });
            } else {
                state.music.volume = DEFAULT_VOLUME;
            }
            
            // Connect narrator volume control
            const narratorVolControl = document.getElementById('narrator-vol');
            if (narratorVolControl) {
                narratorVolControl.addEventListener('input', (e) => {
                    const volume = parseFloat(e.target.value);
                    const validVolume = isNaN(volume) ? 1 : Math.max(0, Math.min(1, volume));
                    // Only set volume if currentAudio exists
                    if (state.currentAudio) {
                        state.currentAudio.volume = validVolume;
                    }
                });
            }
            
            // Initialize Spotify
            handleSpotifyCallback();
            restoreSpotifySession();
            
            // Setup playlist selector event listener
            const playlistSelect = document.getElementById('playlist-select');
            if (playlistSelect) {
                playlistSelect.addEventListener('change', (e) => {
                    if (e.target.value && typeof MusicPlayer !== 'undefined') {
                        MusicPlayer.loadPlaylist(e.target.value);
                    }
                });
            }
            
            // Display Firebase initialization error banner if there was an error
            if (window.fb && window.fb.firebaseInitError) {
                showTransientBanner('‚ö†Ô∏è ' + window.fb.firebaseInitError, 'error');
            }
            
            // Initialize settings modal
            loadSettingsFromStorage();
            loadPresetsFromStorage();
            syncSettingsUI();
        };
        
        // ============================================================================
        // Settings Modal Functions
        // ============================================================================
        
        // Settings state
        const settingsState = {
            sleepMode: false,
            autoSave: false,
            maxStorySize: 500, // KB
            audioRecording: false,
            mediaRecorder: null,
            recordedChunks: [],
            recordingStartTime: null,
            presets: {}
        };
        
        function openSettingsModal() {
            document.getElementById('settings-modal').classList.remove('hidden');
            syncSettingsUI();
        }
        
        function closeSettingsModal() {
            document.getElementById('settings-modal').classList.add('hidden');
        }
        
        function switchSettingsTab(tabName) {
            // Hide all tabs
            document.getElementById('settings-general').classList.add('hidden');
            document.getElementById('settings-audio').classList.add('hidden');
            document.getElementById('settings-presets').classList.add('hidden');
            
            // Remove active class from all tab buttons
            document.getElementById('tab-general').classList.remove('bg-indigo-600', 'text-white');
            document.getElementById('tab-general').classList.add('text-slate-400');
            document.getElementById('tab-audio').classList.remove('bg-indigo-600', 'text-white');
            document.getElementById('tab-audio').classList.add('text-slate-400');
            document.getElementById('tab-presets').classList.remove('bg-indigo-600', 'text-white');
            document.getElementById('tab-presets').classList.add('text-slate-400');
            
            // Show selected tab
            document.getElementById('settings-' + tabName).classList.remove('hidden');
            document.getElementById('tab-' + tabName).classList.add('bg-indigo-600', 'text-white');
            document.getElementById('tab-' + tabName).classList.remove('text-slate-400');
        }
        
        function syncSettingsUI() {
            // Sync sleep mode toggle
            document.getElementById('sleep-mode-toggle').checked = settingsState.sleepMode;
            
            // Show/hide session duration based on sleep mode
            document.getElementById('session-duration-setting').style.display = 
                settingsState.sleepMode ? 'none' : 'block';
            
            // Sync session duration select
            const minutes = Math.floor(state.timeLeftSeconds / 60);
            const lengthSelect = document.getElementById('length-select-reader');
            if (lengthSelect) {
                // Find closest match or set to current value
                const options = Array.from(lengthSelect.options).map(o => parseInt(o.value));
                const closest = options.reduce((prev, curr) => 
                    Math.abs(curr - minutes) < Math.abs(prev - minutes) ? curr : prev
                );
                lengthSelect.value = closest;
            }
            
            // Sync auto-save toggle
            document.getElementById('auto-save-toggle').checked = settingsState.autoSave;
            document.getElementById('max-story-size').value = settingsState.maxStorySize;
            
            // Sync audio recording toggle
            document.getElementById('audio-recording-toggle').checked = settingsState.audioRecording;
            
            // Update recording status display
            if (settingsState.audioRecording && settingsState.mediaRecorder?.state === 'recording') {
                document.getElementById('recording-status').classList.remove('hidden');
            } else {
                document.getElementById('recording-status').classList.add('hidden');
            }
            
            // Enable/disable download button based on recorded chunks
            const downloadBtn = document.getElementById('download-recording-btn');
            downloadBtn.disabled = settingsState.recordedChunks.length === 0;
        }
        
        // ============================================================================
        // Sleep Mode Functions
        // ============================================================================
        
        // Sleep mode "unlimited" time constant (~31 years in seconds)
        const SLEEP_MODE_TIME_SECONDS = 999999999;
        
        function toggleSleepMode(enabled) {
            settingsState.sleepMode = enabled;
            state.sleepMode = enabled;
            
            if (enabled) {
                // Enable sleep mode - set time to very large number
                state.timeLeftSeconds = SLEEP_MODE_TIME_SECONDS;
                document.getElementById('session-timer').textContent = '‚àû SLEEP MODE';
            } else {
                // Disable sleep mode - restore to selected duration
                const selectedMinutes = parseInt(document.getElementById('length-select-reader').value);
                state.timeLeftSeconds = selectedMinutes * 60;
            }
            
            syncSettingsUI();
            saveSettingsToStorage();
            updateSettingsDisplay();
        }
        
        function updateSessionDuration(minutes) {
            if (!settingsState.sleepMode) {
                state.timeLeftSeconds = parseInt(minutes) * 60;
                saveSettingsToStorage();
                updateSettingsDisplay();
            }
        }
        
        // ============================================================================
        // Story Saving Functions
        // ============================================================================
        
        function toggleAutoSave(enabled) {
            settingsState.autoSave = enabled;
            
            if (enabled) {
                // Start auto-saving
                autoSaveStory();
            }
            
            saveSettingsToStorage();
        }
        
        function autoSaveStory() {
            if (!settingsState.autoSave) return;
            
            try {
                const storyData = {
                    title: document.getElementById('reader-title').textContent,
                    content: state.sentences.join(' '),
                    genre: state.genre,
                    timestamp: Date.now()
                };
                
                const storyJson = JSON.stringify(storyData);
                const storySizeKB = new Blob([storyJson]).size / 1024;
                
                // Check size limit
                if (storySizeKB <= settingsState.maxStorySize) {
                    localStorage.setItem('dreamweaver_auto_saved_story', storyJson);
                    console.log(`Story auto-saved (${storySizeKB.toFixed(2)} KB)`);
                } else {
                    console.warn(`Story exceeds size limit (${storySizeKB.toFixed(2)} KB > ${settingsState.maxStorySize} KB)`);
                }
            } catch (error) {
                console.error('Failed to auto-save story:', error);
            }
        }
        
        function exportStory() {
            try {
                const storyData = {
                    title: document.getElementById('reader-title').textContent,
                    content: state.sentences.join('\n\n'),
                    genre: state.genre,
                    voice: state.voice,
                    accent: state.accent,
                    exportDate: new Date().toISOString()
                };
                
                const storyText = `${storyData.title}\n\n${storyData.content}\n\n---\nGenre: ${storyData.genre}\nNarrator: ${storyData.voice} (${storyData.accent})\nExported: ${storyData.exportDate}`;
                
                const blob = new Blob([storyText], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `dreamweaver_story_${Date.now()}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showTransientBanner('Story exported successfully!', 'success');
            } catch (error) {
                console.error('Failed to export story:', error);
                showTransientBanner('Failed to export story: ' + error.message, 'error');
            }
        }
        
        // ============================================================================
        // Audio Recording Functions
        // ============================================================================
        
        function toggleAudioRecording(enabled) {
            settingsState.audioRecording = enabled;
            
            if (enabled) {
                startAudioRecording();
            } else {
                stopAudioRecording();
            }
            
            syncSettingsUI();
            saveSettingsToStorage();
        }
        
        function startAudioRecording() {
            try {
                // Validate that audio element exists and is ready
                if (!state.currentAudio || !state.currentAudio.src) {
                    throw new Error('No audio source available for recording');
                }
                
                // Create a MediaStreamDestination to capture audio
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const destination = audioContext.createMediaStreamDestination();
                
                // Connect current audio to destination
                const source = audioContext.createMediaElementSource(state.currentAudio);
                source.connect(destination);
                source.connect(audioContext.destination); // Also play normally
                
                // Create MediaRecorder
                settingsState.mediaRecorder = new MediaRecorder(destination.stream);
                settingsState.recordedChunks = [];
                settingsState.recordingStartTime = Date.now();
                
                settingsState.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        settingsState.recordedChunks.push(event.data);
                        updateRecordingStatus();
                    }
                };
                
                settingsState.mediaRecorder.start(1000); // Capture in 1-second chunks
                
                console.log('Audio recording started');
                syncSettingsUI();
            } catch (error) {
                console.error('Failed to start audio recording:', error);
                showTransientBanner('Failed to start recording: ' + error.message, 'error');
                settingsState.audioRecording = false;
                document.getElementById('audio-recording-toggle').checked = false;
            }
        }
        
        function stopAudioRecording() {
            if (settingsState.mediaRecorder && settingsState.mediaRecorder.state !== 'inactive') {
                settingsState.mediaRecorder.stop();
                console.log('Audio recording stopped');
            }
            syncSettingsUI();
        }
        
        function updateRecordingStatus() {
            if (!settingsState.recordingStartTime) return;
            
            const duration = Math.floor((Date.now() - settingsState.recordingStartTime) / 1000);
            const minutes = Math.floor(duration / 60);
            const seconds = duration % 60;
            
            const totalSize = settingsState.recordedChunks.reduce((acc, chunk) => acc + chunk.size, 0);
            const sizeKB = (totalSize / 1024).toFixed(2);
            
            document.getElementById('recording-duration').textContent = 
                `${minutes}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('recording-size').textContent = `${sizeKB} KB`;
        }
        
        function downloadRecording() {
            if (settingsState.recordedChunks.length === 0) {
                showTransientBanner('No recording available to download', 'warning');
                return;
            }
            
            try {
                const blob = new Blob(settingsState.recordedChunks, { type: 'audio/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `dreamweaver_recording_${Date.now()}.webm`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showTransientBanner('Recording downloaded successfully!', 'success');
            } catch (error) {
                console.error('Failed to download recording:', error);
                showTransientBanner('Failed to download recording: ' + error.message, 'error');
            }
        }
        
        // ============================================================================
        // Preset Management Functions
        // ============================================================================
        
        function savePreset() {
            const presetName = document.getElementById('preset-name-input').value.trim();
            
            if (!presetName) {
                showTransientBanner('Please enter a preset name', 'warning');
                return;
            }
            
            const scoreSensitivity = document.getElementById('score-sensitivity');
            const scoreDynamicsValue = scoreSensitivity ? (parseInt(scoreSensitivity.value) || 3) : 3;
            
            const preset = {
                name: presetName,
                voice: document.getElementById('voice-select-reader').value,
                genre: state.genre,
                sessionDuration: parseInt(document.getElementById('length-select-reader').value),
                sleepMode: settingsState.sleepMode,
                scoreDynamics: scoreDynamicsValue,
                musicSource: state.musicSource,
                autoSave: settingsState.autoSave,
                maxStorySize: settingsState.maxStorySize,
                timestamp: Date.now()
            };
            
            settingsState.presets[presetName] = preset;
            savePresetsToStorage();
            renderPresetList();
            
            document.getElementById('preset-name-input').value = '';
            showTransientBanner(`Preset "${presetName}" saved!`, 'success');
        }
        
        function loadPreset(presetName) {
            const preset = settingsState.presets[presetName];
            if (!preset) return;
            
            // Apply preset settings
            document.getElementById('voice-select').value = preset.voice;
            document.getElementById('voice-select-reader').value = preset.voice;
            
            const voiceConfig = VOICES[preset.voice];
            if (voiceConfig) {
                state.voice = voiceConfig.name;
                state.accent = voiceConfig.accent;
            }
            
            state.genre = preset.genre;
            
            if (preset.sleepMode) {
                settingsState.sleepMode = true;
                state.timeLeftSeconds = 999999999;
            } else {
                settingsState.sleepMode = false;
                state.timeLeftSeconds = preset.sessionDuration * 60;
                document.getElementById('length-select-reader').value = preset.sessionDuration;
            }
            
            if (document.getElementById('score-sensitivity')) {
                document.getElementById('score-sensitivity').value = preset.scoreDynamics;
            }
            
            state.musicSource = preset.musicSource;
            settingsState.autoSave = preset.autoSave;
            settingsState.maxStorySize = preset.maxStorySize;
            
            syncSettingsUI();
            showTransientBanner(`Preset "${presetName}" loaded!`, 'success');
        }
        
        function deletePreset(presetName) {
            if (!confirm(`Delete preset "${presetName}"?`)) return;
            
            delete settingsState.presets[presetName];
            savePresetsToStorage();
            renderPresetList();
            
            showTransientBanner(`Preset "${presetName}" deleted`, 'success');
        }
        
        function renderPresetList() {
            const presetList = document.getElementById('preset-list');
            const presets = Object.values(settingsState.presets);
            
            if (presets.length === 0) {
                presetList.innerHTML = '<div class="text-slate-400 text-sm text-center py-4">No presets saved yet</div>';
                return;
            }
            
            // Helper function to escape HTML
            function escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
            
            presetList.innerHTML = presets.map(preset => {
                const safeName = escapeHtml(preset.name);
                const safeVoice = escapeHtml(preset.voice);
                const safeGenre = escapeHtml(preset.genre);
                const safeDuration = preset.sleepMode ? 'Sleep Mode' : escapeHtml(preset.sessionDuration + ' min');
                
                return `
                <div class="flex items-center justify-between p-3 bg-slate-800 rounded-xl">
                    <div class="flex-1">
                        <div class="text-white font-bold text-sm">${safeName}</div>
                        <div class="text-slate-400 text-xs mt-1">
                            ${safeVoice} ‚Ä¢ ${safeGenre} ‚Ä¢ ${safeDuration}
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <button onclick="loadPreset('${safeName.replace(/'/g, "\\'")}')" class="px-3 py-1 bg-indigo-600 hover:bg-indigo-500 rounded-lg text-xs font-bold transition-all active:scale-95">
                            Load
                        </button>
                        <button onclick="deletePreset('${safeName.replace(/'/g, "\\'")}')" class="px-3 py-1 bg-red-600 hover:bg-red-500 rounded-lg text-xs font-bold transition-all active:scale-95">
                            Delete
                        </button>
                    </div>
                </div>
            `;
            }).join('');
        }
        
        function exportPresets() {
            try {
                const presetsJson = JSON.stringify(settingsState.presets, null, 2);
                const blob = new Blob([presetsJson], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `dreamweaver_presets_${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showTransientBanner('Presets exported successfully!', 'success');
            } catch (error) {
                console.error('Failed to export presets:', error);
                showTransientBanner('Failed to export presets: ' + error.message, 'error');
            }
        }
        
        function importPresets(file) {
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const imported = JSON.parse(e.target.result);
                    
                    // Merge imported presets with existing ones
                    settingsState.presets = { ...settingsState.presets, ...imported };
                    savePresetsToStorage();
                    renderPresetList();
                    
                    const count = Object.keys(imported).length;
                    showTransientBanner(`Imported ${count} preset(s) successfully!`, 'success');
                } catch (error) {
                    console.error('Failed to import presets:', error);
                    showTransientBanner('Failed to import presets: Invalid file format', 'error');
                }
            };
            reader.readAsText(file);
        }
        
        // ============================================================================
        // Storage Functions
        // ============================================================================
        
        function saveSettingsToStorage() {
            try {
                localStorage.setItem('dreamweaver_settings', JSON.stringify({
                    sleepMode: settingsState.sleepMode,
                    autoSave: settingsState.autoSave,
                    maxStorySize: settingsState.maxStorySize,
                    audioRecording: settingsState.audioRecording
                }));
            } catch (error) {
                console.warn('Failed to save settings to storage:', error);
            }
        }
        
        function loadSettingsFromStorage() {
            try {
                const stored = localStorage.getItem('dreamweaver_settings');
                if (stored) {
                    const settings = JSON.parse(stored);
                    settingsState.sleepMode = settings.sleepMode || false;
                    settingsState.autoSave = settings.autoSave || false;
                    settingsState.maxStorySize = settings.maxStorySize || 500;
                    settingsState.audioRecording = settings.audioRecording || false;
                }
            } catch (error) {
                console.warn('Failed to load settings from storage:', error);
            }
        }
        
        function savePresetsToStorage() {
            try {
                localStorage.setItem('dreamweaver_presets', JSON.stringify(settingsState.presets));
            } catch (error) {
                console.warn('Failed to save presets to storage:', error);
            }
        }
        
        function loadPresetsFromStorage() {
            try {
                const stored = localStorage.getItem('dreamweaver_presets');
                if (stored) {
                    settingsState.presets = JSON.parse(stored);
                    renderPresetList();
                }
            } catch (error) {
                console.warn('Failed to load presets from storage:', error);
            }
        }
        
        // Update auto-save and recording status periodically during playback
        let settingsIntervalId = null;
        
        function startSettingsInterval() {
            // Only start if not already running
            if (settingsIntervalId) return;
            
            settingsIntervalId = setInterval(() => {
                // Auto-save if enabled and playing
                if (state.isPlaying && settingsState.autoSave) {
                    autoSaveStory();
                }
                
                // Update recording status if recording
                if (settingsState.audioRecording && settingsState.mediaRecorder?.state === 'recording') {
                    updateRecordingStatus();
                }
            }, 5000); // Every 5 seconds
        }
        
        function stopSettingsInterval() {
            if (settingsIntervalId) {
                clearInterval(settingsIntervalId);
                settingsIntervalId = null;
            }
        }
        
        // Start the interval when playback begins, stop when it ends
        // Note: This should be called from the existing togglePlayback() function
    </script>
    
    <!-- Music Player Module -->
    <script src="music-player.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            MusicPlayer.init();
            
            // Synchronize music source selection on app startup
            const musicSourceSelect = document.getElementById('music-source-select');
            if (musicSourceSelect) {
                // Initialize state.musicSource from the select element
                state.musicSource = musicSourceSelect.value || 'spotify';
                
                // Apply initial source to MusicPlayer using shared helper function
                syncMusicSourceToPlayer(state.musicSource);
                
                // Add change listener to keep state.musicSource and MusicPlayer synchronized
                musicSourceSelect.addEventListener('change', (e) => {
                    state.musicSource = e.target.value;
                    syncMusicSourceToPlayer(state.musicSource);
                });
            }
            
            // Note: Play/pause buttons for the story narration are handled separately
            // The music-player.js controls background music only and does not interfere
            // with the main story playback controls (togglePlayback, etc.)
        });
    </script>
    
    <!-- Starfield generation script -->
    <script>
        // Generate stars for the background
        (function generateStarfield() {
            const starfield = document.getElementById('starfield');
            if (!starfield) return;
            
            // Predefined classes for performance
            const sizes = ['star-size-small', 'star-size-medium', 'star-size-large'];
            const speeds = ['star-slow', 'star-medium', 'star-fast'];
            const delays = ['star-delay-1', 'star-delay-2', 'star-delay-3', 'star-delay-4'];
            
            // Create regular stars
            const starCount = 200;
            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                
                // Random position
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                
                // Add random predefined classes
                star.classList.add(sizes[Math.floor(Math.random() * sizes.length)]);
                star.classList.add(speeds[Math.floor(Math.random() * speeds.length)]);
                star.classList.add(delays[Math.floor(Math.random() * delays.length)]);
                
                starfield.appendChild(star);
            }
            
            // Create shooting stars
            const shootingStarCount = 5;
            const shootSpeeds = ['shoot-slow', 'shoot-medium', 'shoot-fast'];
            const shootDelays = ['shoot-delay-1', 'shoot-delay-2', 'shoot-delay-3', 'shoot-delay-4', 'shoot-delay-5'];
            const shootWidths = ['shoot-width-small', 'shoot-width-medium', 'shoot-width-large'];
            
            for (let i = 0; i < shootingStarCount; i++) {
                const shootingStar = document.createElement('div');
                shootingStar.className = 'shooting-star';
                
                // Random starting position
                shootingStar.style.left = Math.random() * 50 + '%';
                shootingStar.style.top = Math.random() * 50 + '%';
                
                // Add predefined classes for performance
                shootingStar.classList.add(shootWidths[Math.floor(Math.random() * shootWidths.length)]);
                shootingStar.classList.add(shootSpeeds[Math.floor(Math.random() * shootSpeeds.length)]);
                shootingStar.classList.add(shootDelays[i % shootDelays.length]); // Distribute delays sequentially for consistent spacing
                
                starfield.appendChild(shootingStar);
            }
        })();
    </script>
    
    <!-- Debug Mode Detection -->
    <script>
        // Show debug link if debug parameter is present or user has special access
        (function checkDebugMode() {
            const urlParams = new URLSearchParams(window.location.search);
            const debugMode = urlParams.get('debug') === 'true';
            
            // Show debug link if in debug mode
            if (debugMode) {
                const debugLink = document.getElementById('debug-link');
                if (debugLink) {
                    debugLink.classList.remove('hidden');
                }
                console.log('%cüîß Debug Mode Active', 'color: #facc15; font-size: 14px; font-weight: bold;');
                console.log('%cAccess debug area at: debug.html', 'color: #94a3b8; font-size: 12px;');
            }
        })();
    </script>
</body>

</html>


