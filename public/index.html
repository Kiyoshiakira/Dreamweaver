<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- Content Security Policy: Defines allowed sources for scripts, styles, and other resources
         IMPORTANT: 'unsafe-eval' is required for Spotify Web Playback SDK to function properly.
         The Spotify SDK dynamically evaluates JavaScript code for player functionality.
         'unsafe-inline' is used for inline scripts and styles present in this HTML file.
         If hosting on a platform with server-side CSP headers, ensure those headers also include 'unsafe-eval'. -->
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self';
        script-src 'self' 'unsafe-inline' 'unsafe-eval' 
            https://cdn.tailwindcss.com 
            https://sdk.scdn.co 
            https://www.gstatic.com 
            https://www.google-analytics.com 
            https://ssl.google-analytics.com 
            https://www.google.com 
            https://www.google.com/recaptcha/ 
            https://*.googletagmanager.com 
            https://accounts.scdn.co
            https://www.youtube.com;
        style-src 'self' 'unsafe-inline' 
            https://cdn.tailwindcss.com 
            https://fonts.googleapis.com;
        font-src 'self' 
            https://fonts.gstatic.com;
        img-src 'self' data: https: blob:;
        connect-src 'self' 
            https://generativelanguage.googleapis.com 
            https://accounts.spotify.com 
            https://api.spotify.com 
            https://firebasestorage.googleapis.com 
            https://*.googleapis.com
            https://www.gstatic.com;
        media-src 'self' https: blob:;
        frame-src https://accounts.spotify.com https://sdk.scdn.co https://www.youtube.com https://www.youtube-nocookie.com https://www.google.com https://recaptcha.google.com;
    ">
    <title>Dreamweaver</title>
    <!-- Note: Tailwind CDN is used for development convenience. For production deployment,
         consider using Tailwind CLI or PostCSS plugin: https://tailwindcss.com/docs/installation -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,400;0,700;1,400&family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <script src="https://sdk.scdn.co/spotify-player.js"></script>
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, addDoc, getDocs, query, where, onSnapshot, deleteDoc, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { initializeAppCheck, ReCaptchaV3Provider } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app-check.js";

        // Firebase configuration - REQUIRED for Dreamweaver to function
        let auth = null;
        let db = null;
        let appCheck = null;
        let firebaseInitError = null; // Store error to display later
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'narrative-engine-infinite';
        
        try {
            if (typeof __firebase_config !== 'undefined') {
                const firebaseConfig = JSON.parse(__firebase_config);
                
                // Check if configuration has been updated from defaults
                if (firebaseConfig.apiKey === 'YOUR_FIREBASE_API_KEY' || 
                    firebaseConfig.projectId === 'your-project-id') {
                    console.error('⚠️ Firebase configuration not updated. Please configure Firebase.');
                    firebaseInitError = 'Firebase Configuration Required: Dreamweaver requires Firebase Cloud Functions to work. ' +
                        'Please update the Firebase configuration (__firebase_config variable in the <script> tag) with your project details. ' +
                        'See server/README.md for setup instructions.';
                } else {
                    const app = initializeApp(firebaseConfig);
                    auth = getAuth(app);
                    db = getFirestore(app);
                    
                    // Initialize App Check if reCAPTCHA site key is provided
                    if (typeof __recaptcha_site_key !== 'undefined' && __recaptcha_site_key) {
                        // Check if reCAPTCHA key has been updated from default
                        if (__recaptcha_site_key === 'YOUR_RECAPTCHA_V3_SITE_KEY') {
                            console.error('⚠️ reCAPTCHA site key not updated. Please configure App Check.');
                            firebaseInitError = 'App Check Configuration Required: Please update the reCAPTCHA site key (__recaptcha_site_key variable in the <script> tag). ' +
                                'Get a key from https://www.google.com/recaptcha/admin';
                        } else {
                            try {
                                appCheck = initializeAppCheck(app, {
                                    provider: new ReCaptchaV3Provider(__recaptcha_site_key),
                                    isTokenAutoRefreshEnabled: true
                                });
                                console.log('✓ Firebase App Check initialized successfully');
                            } catch (appCheckError) {
                                console.error('App Check initialization failed:', appCheckError.message);
                                firebaseInitError = 'App Check Initialization Failed: ' + appCheckError.message + '. ' +
                                    'Dreamweaver will not function without App Check. Please verify your reCAPTCHA v3 site key.';
                            }
                        }
                    } else {
                        console.error('⚠️ reCAPTCHA site key not provided');
                        firebaseInitError = 'App Check Not Configured: reCAPTCHA v3 site key is required. ' +
                            'Please set __recaptcha_site_key variable in the <script> tag.';
                    }
                }
            } else {
                console.error('⚠️ Firebase configuration not provided');
                firebaseInitError = 'Firebase Not Configured: Dreamweaver requires Firebase Cloud Functions. ' +
                    'Please configure Firebase in index.html. See server/README.md for instructions.';
            }
        } catch (error) {
            console.error('Firebase initialization failed:', error.message);
            firebaseInitError = 'Firebase Initialization Failed: ' + error.message + '. ' +
                'Please check your Firebase configuration in index.html.';
        }

        window.fb = { auth, db, appId, appCheck, firebaseInitError };

        // Spotify Configuration
        // IMPORTANT: Replace SPOTIFY_CLIENT_ID with your actual Spotify Client ID from https://developer.spotify.com/dashboard
        // This is a placeholder value and must be updated for Spotify integration to work
        const SPOTIFY_CLIENT_ID = '5c1a5a8a8f4d4f1f9c3e9e5c0c3e0c3e'; // Replace with your Spotify Client ID
        const SPOTIFY_REDIRECT_URI = window.location.origin + window.location.pathname;
        const SPOTIFY_SCOPES = 'streaming user-read-email user-read-private user-modify-playback-state user-read-playback-state';
        
        window.spotify = {
            clientId: SPOTIFY_CLIENT_ID,
            redirectUri: SPOTIFY_REDIRECT_URI,
            scopes: SPOTIFY_SCOPES
        };
        
        // Define Spotify Web Playback SDK callback
        // This function is called when the Spotify SDK is ready
        window.onSpotifyWebPlaybackSDKReady = () => {
            console.log('Spotify Web Playback SDK is ready');
            // Player initialization will be handled when user logs in
        };
    </script>

    <style>
        :root { --bg-deep: #020617; --accent: #6366f1; --text-main: #e2e8f0; }
        body { background-color: var(--bg-deep); color: var(--text-main); font-family: 'Inter', sans-serif; overflow-x: hidden; position: relative; }
        .novel-font { font-family: 'Crimson Pro', serif; }
        .glass { background: rgba(15, 23, 42, 0.8); backdrop-filter: blur(16px); border: 1px solid rgba(255,255,255,0.08); }
        .tab-active { background: var(--accent); color: white; }
        
        .sentence-span { transition: opacity 0.3s ease; opacity: 0.3; cursor: pointer; display: inline; }
        .sentence-active { opacity: 1 !important; color: #1a1a1a !important; font-weight: 500; }
        
        .word-token { display: inline; padding: 0; transition: all 0.15s ease; }
        .word-active { background-color: #3b82f6 !important; color: white !important; padding: 2px 4px; border-radius: 4px; }

        .image-container { 
            position: sticky; top: 2rem; width: 100%; aspect-ratio: 1/1; 
            border-radius: 2rem; overflow: hidden; background: #0f172a; 
            border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }
        .image-container img { width: 100%; height: 100%; object-fit: cover; transition: opacity 1.5s ease; }
        
        .timer-glow { text-shadow: 0 0 10px rgba(99, 102, 241, 0.5); }
        
        /* Sleepy starfield background */
        .starfield {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            background: linear-gradient(to bottom, #020617 0%, #0f172a 50%, #1e1b4b 100%);
            overflow: hidden;
        }
        
        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle linear infinite;
        }
        
        @keyframes twinkle {
            0%, 100% { opacity: 0.2; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }
        
        /* Predefined animation classes for better performance */
        .star-slow { animation-duration: 8s; }
        .star-medium { animation-duration: 5s; }
        .star-fast { animation-duration: 3s; }
        .star-delay-1 { animation-delay: 0s; }
        .star-delay-2 { animation-delay: 1s; }
        .star-delay-3 { animation-delay: 2s; }
        .star-delay-4 { animation-delay: 3s; }
        .star-size-small { width: 1px; height: 1px; }
        .star-size-medium { width: 2px; height: 2px; }
        .star-size-large { width: 3px; height: 3px; }
        
        .shoot-slow { animation-duration: 5s; }
        .shoot-medium { animation-duration: 3.5s; }
        .shoot-fast { animation-duration: 2s; }
        .shoot-delay-1 { animation-delay: 0s; }
        .shoot-delay-2 { animation-delay: 3s; }
        .shoot-delay-3 { animation-delay: 6s; }
        .shoot-delay-4 { animation-delay: 9s; }
        .shoot-delay-5 { animation-delay: 12s; }
        .shoot-width-small { width: 50px; }
        .shoot-width-medium { width: 100px; }
        .shoot-width-large { width: 150px; }
        
        .shooting-star {
            position: absolute;
            height: 2px;
            background: linear-gradient(to right, rgba(255, 255, 255, 0), rgba(255, 255, 255, 1), rgba(255, 255, 255, 0));
            animation: shoot linear infinite;
            opacity: 0;
        }
        
        @keyframes shoot {
            0% { opacity: 0; transform: translateX(-10vw) translateY(-10vh); }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { opacity: 0; transform: translateX(100vw) translateY(100vh); }
        }
        
        .moon {
            position: fixed;
            top: 5%;
            right: 5%;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: linear-gradient(135deg, #fef9e7 0%, #f7dc6f 50%, #f4d03f 100%);
            box-shadow: 0 0 60px rgba(247, 220, 111, 0.6), 
                        inset -20px -20px 40px rgba(0, 0, 0, 0.1);
            z-index: 5;
            animation: moon-glow 4s ease-in-out infinite;
        }
        
        @keyframes moon-glow {
            0%, 100% { box-shadow: 0 0 60px rgba(247, 220, 111, 0.6), inset -20px -20px 40px rgba(0, 0, 0, 0.1); }
            50% { box-shadow: 0 0 80px rgba(247, 220, 111, 0.8), inset -20px -20px 40px rgba(0, 0, 0, 0.1); }
        }
        
        /* Ensure content stays above background */
        #app {
            position: relative;
            z-index: 10;
        }
    </style>
</head>
<body class="selection:bg-indigo-500/30">
    <script>
       // ========================================================================
       // REQUIRED: Firebase Configuration
       // ========================================================================
       // Dreamweaver requires Firebase Cloud Functions to work. All API calls
       // (story generation, text-to-speech, image generation) are routed through
       // secure Firebase Cloud Functions to protect API keys.
       //
       // Setup Steps:
       // 1. Create a Firebase project: https://console.firebase.google.com/
       // 2. Get your Firebase config from: Project Settings > Your apps > Web app
       // 3. Replace the values below with your Firebase configuration
       // 4. Set up Cloud Functions (see server/README.md for instructions):
       //    - Configure API key: firebase functions:config:set genai.key="YOUR_KEY"
       //    - Deploy functions: firebase deploy --only functions
       // 5. Set up Firebase App Check with reCAPTCHA v3 (required for security)
       //
       // IMPORTANT: DO NOT commit real API keys to public repositories
       // 
       const __firebase_config = JSON.stringify({
            apiKey: "YOUR_FIREBASE_API_KEY",
            authDomain: "your-project.firebaseapp.com",
            projectId: "your-project-id",
            storageBucket: "your-project.firebasestorage.app",
            messagingSenderId: "123456789",
            appId: "1:123456789:web:abcdef123456",
            measurementId: "G-XXXXXXXXXX"
       });

       // ========================================================================
       // REQUIRED: reCAPTCHA v3 Site Key (for Firebase App Check)
       // ========================================================================
       // Get from: https://www.google.com/recaptcha/admin
       // Create a v3 site key and add your domain(s) (including localhost for dev)
       // App Check protects your Cloud Functions from abuse
       //
       const __recaptcha_site_key = "YOUR_RECAPTCHA_V3_SITE_KEY";
    </script>
    <!-- Starfield background -->
    <div class="starfield" id="starfield"></div>
    <div class="moon"></div>
    
    <div id="app" class="relative z-10 min-h-screen flex flex-col">
        <nav class="flex items-center justify-between p-6 max-w-7xl mx-auto w-full">
            <div class="flex items-center gap-3">
                <div class="w-10 h-10 bg-indigo-600 rounded-xl flex items-center justify-center shadow-lg shadow-indigo-500/20">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg>
                </div>
                <h1 class="text-xl font-black tracking-tighter uppercase">Dream<span class="text-indigo-500">weaver</span></h1>
            </div>
            
            <div id="session-timer" class="hidden glass px-6 py-2 rounded-full border border-indigo-500/30 font-mono text-indigo-400 font-bold timer-glow" title="Time remaining in your story session. Story generation stops when timer reaches zero">
                00:00:00
            </div>
        </nav>

        <!-- File Protocol Warning Banner -->
        <div id="file-protocol-warning" class="hidden mx-auto max-w-7xl px-6 mb-4">
            <div class="bg-yellow-900/30 border border-yellow-500/50 rounded-2xl p-4 backdrop-blur-sm">
                <div class="flex items-start gap-3">
                    <svg class="w-6 h-6 text-yellow-400 flex-shrink-0 mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>
                    </svg>
                    <div class="flex-1 min-w-0">
                        <h3 class="text-yellow-400 font-bold text-sm mb-1">⚠️ Running from file:// protocol</h3>
                        <p class="text-yellow-200/80 text-xs leading-relaxed mb-2">
                            You're opening this app directly from your filesystem. This can cause issues with:
                            Spotify SDK postMessage origins, YouTube IFrame API, API CORS restrictions, and OAuth redirects.
                        </p>
                        <div class="bg-slate-900/50 rounded-lg p-2 font-mono text-xs text-yellow-100">
                            <div class="text-yellow-400 font-bold mb-1">Recommended: Serve over HTTP</div>
                            <div class="text-slate-300">python -m http.server 8000</div>
                            <div class="text-slate-400 text-[10px] mt-1">Then visit: http://localhost:8000/dreamweaver.html</div>
                        </div>
                    </div>
                    <button onclick="document.getElementById('file-protocol-warning').classList.add('hidden')" 
                            class="text-yellow-400 hover:text-yellow-300 transition-colors p-1" 
                            title="Dismiss warning">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                        </svg>
                    </button>
                </div>
            </div>
        </div>

        <!-- Setup Screen -->
        <main id="view-home" class="flex-1 max-w-3xl mx-auto px-6 py-12 w-full">
            <div class="glass rounded-[2.5rem] p-10 space-y-10 shadow-2xl border border-white/5">
                <div class="space-y-4">
                    <h2 class="text-4xl font-black tracking-tight">Welcome to Dreamweaver</h2>
                    <p class="text-slate-400 text-sm">Tell me what story you'd like to hear, and I'll weave it for you.</p>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                    <!-- Narrator Selection -->
                    <div class="space-y-2">
                        <label class="text-indigo-400 text-[11px] font-black uppercase tracking-widest ml-1">Narrator Voice</label>
                        <select id="voice-select" class="w-full bg-slate-900 border border-white/10 rounded-2xl p-4 text-white appearance-none cursor-pointer hover:bg-slate-800 transition-colors" title="Choose from 8 different voice personas with varied accents to narrate your story"></select>
                    </div>

                    <!-- Session Length (Restored & Enhanced) -->
                    <div class="space-y-2">
                        <label class="text-indigo-400 text-[11px] font-black uppercase tracking-widest ml-1">Session Duration</label>
                        <select id="length-select" class="w-full bg-slate-900 border border-white/10 rounded-2xl p-4 text-white appearance-none cursor-pointer" title="Set how long you want the story to continue (AI will generate chapters to fill this time)">
                            <option value="5">5 Minutes</option>
                            <option value="30">30 Minutes</option>
                            <option value="60">1 Hour</option>
                            <option value="120">2 Hours</option>
                        </select>
                    </div>

                    <div class="space-y-2">
                        <label class="text-indigo-400 text-[11px] font-black uppercase tracking-widest ml-1">Narrative Genre</label>
                        <select id="genre-select" class="w-full bg-slate-900 border border-white/10 rounded-2xl p-4 text-white appearance-none cursor-pointer" title="Select the genre that will shape the story's theme, style, and atmosphere">
                            <option value="Fantasy">Fantasy</option>
                            <option value="Sci-Fi">Sci-Fi</option>
                            <option value="Mystery">Mystery</option>
                            <option value="Horror">Horror</option>
                            <option value="Drama">Historical Drama</option>
                        </select>
                    </div>

                    <!-- Intelligent Score -->
                    <div class="space-y-2">
                        <label class="text-indigo-400 text-[11px] font-black uppercase tracking-widest ml-1">Score Dynamics</label>
                        <div class="flex items-center gap-4 bg-slate-900 border border-white/10 rounded-2xl p-4">
                            <span class="text-[10px] text-slate-500 uppercase font-bold">Static</span>
                            <input type="range" id="score-sensitivity" class="flex-1 accent-indigo-500" min="1" max="5" value="3" title="Control how dynamically the background music changes. Static = same music throughout, Fluid = music adapts to story mood">
                            <span class="text-[10px] text-slate-500 uppercase font-bold">Fluid</span>
                        </div>
                    </div>
                </div>
                
                <!-- Spotify Integration Section -->
                <div class="space-y-2 p-6 bg-slate-900/50 border border-indigo-500/20 rounded-2xl">
                    <div class="flex items-center justify-between">
                        <div class="space-y-1">
                            <label class="text-indigo-400 text-[11px] font-black uppercase tracking-widest">Music Source</label>
                            <p class="text-slate-400 text-xs">Connect Spotify for personalized music selection</p>
                        </div>
                        <div id="spotify-status" class="flex items-center gap-2">
                            <button id="spotify-login-btn" onclick="loginSpotify()" class="px-5 py-2 bg-green-600 hover:bg-green-500 rounded-xl font-bold text-sm transition-all active:scale-95 flex items-center gap-2" title="Log in with your Spotify account to access millions of songs for intelligent music selection based on story mood">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z"/></svg>
                                Connect Spotify
                            </button>
                            <div id="spotify-user-info" class="hidden flex items-center gap-3 bg-slate-800 border border-white/10 rounded-xl px-4 py-2">
                                <div class="flex items-center gap-2">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="#1DB954"><path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z"/></svg>
                                    <span id="spotify-username" class="text-sm font-bold text-white">User</span>
                                </div>
                                <button onclick="logoutSpotify()" class="text-xs text-slate-400 hover:text-white transition-colors" title="Disconnect your Spotify account and return to default music library">Disconnect</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Music Player Controls -->
                <div id="music-source-controls" class="space-y-2 p-6 bg-slate-900/50 border border-indigo-500/20 rounded-2xl">
                    <div class="space-y-3">
                        <label class="text-indigo-400 text-[11px] font-black uppercase tracking-widest">Background Music Player</label>
                        <div class="flex flex-wrap items-center gap-3">
                            <select id="music-source-select" aria-label="Music Source" class="bg-slate-900 border border-white/10 rounded-xl px-4 py-2 text-white text-sm appearance-none cursor-pointer hover:bg-slate-800 transition-colors" title="Choose where your background music comes from: Spotify (default library or connected account), Local Files (upload from your device), or YouTube (play audio from videos)">
                                <option value="spotify">Spotify</option>
                                <option value="local">Local Files</option>
                                <option value="youtube">YouTube</option>
                            </select>

                            <input id="local-files-input" type="file" accept="audio/*" multiple style="display:none;" class="text-sm text-slate-400 file:mr-4 file:py-2 file:px-4 file:rounded-xl file:border-0 file:text-sm file:font-semibold file:bg-indigo-600 file:text-white hover:file:bg-indigo-500" title="Upload audio files from your computer (MP3, OGG, etc.). Files play in sequence and are not saved across sessions" />
                            
                            <input id="youtube-url-input" type="text" placeholder="Paste YouTube URL or ID" style="display:none;" class="bg-slate-900 border border-white/10 rounded-xl px-4 py-2 text-white text-sm flex-1 min-w-[280px]" title="Paste a YouTube video URL or video ID to play its audio in the background. Note: YouTube may show ads and requires user interaction for autoplay" />
                            
                            <button id="youtube-load-btn" style="display:none;" class="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded-xl font-bold text-sm transition-all active:scale-95" title="Load the YouTube video for audio playback">Load</button>
                        </div>

                        <!-- Spotify Selected Display -->
                        <div id="spotify-track-info" style="display:none;" class="mt-3 p-3 bg-slate-800 border border-green-500/30 rounded-xl text-sm text-slate-300">
                            <div class="flex items-center gap-2 mb-1">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="#1DB954"><path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z"/></svg>
                                <span class="font-bold text-white">Spotify Selected</span>
                            </div>
                            <div class="text-xs text-slate-400">Default music library will be used (or connect Spotify for personalized selection)</div>
                        </div>

                        <!-- Local Files Display -->
                        <div id="local-track-list" class="space-y-1 text-sm text-slate-300"></div>
                        
                        <!-- YouTube Track Display -->
                        <div id="youtube-track-info" style="display:none;" class="mt-3 p-3 bg-slate-800 border border-red-500/30 rounded-xl text-sm text-slate-300">
                            <div class="flex items-center gap-2 mb-1">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="#FF0000"><path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/></svg>
                                <span class="font-bold text-white">YouTube Selected</span>
                            </div>
                            <div id="youtube-track-name" class="text-xs text-slate-400">No video loaded yet. Paste a YouTube URL above and click Load.</div>
                        </div>
                    </div>
                </div>
                
                <!-- Playlist Management Section -->
                <div id="playlist-controls" class="space-y-2 p-6 bg-slate-900/50 border border-indigo-500/20 rounded-2xl">
                    <div class="space-y-3">
                        <label class="text-indigo-400 text-[11px] font-black uppercase tracking-widest">Playlists</label>
                        <p class="text-slate-400 text-xs">Create playlists to organize your music from Spotify, YouTube, and local files. Playlists are saved across sessions.</p>
                        
                        <div class="flex flex-wrap items-center gap-3">
                            <select id="playlist-select" class="bg-slate-900 border border-white/10 rounded-xl px-4 py-2 text-white text-sm appearance-none cursor-pointer hover:bg-slate-800 transition-colors flex-1 min-w-[200px]" title="Select a playlist to view and manage">
                                <option value="">Select a playlist...</option>
                            </select>
                            
                            <button id="create-playlist-btn" class="px-4 py-2 bg-green-600 hover:bg-green-500 rounded-xl font-bold text-sm transition-all active:scale-95 flex items-center gap-2" title="Create a new playlist">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                                New Playlist
                            </button>
                            
                            <button id="delete-playlist-btn" class="px-4 py-2 bg-red-600 hover:bg-red-500 rounded-xl font-bold text-sm transition-all active:scale-95" title="Delete the selected playlist" onclick="deleteCurrentPlaylist()">
                                Delete
                            </button>
                        </div>
                        
                        <!-- Add Current Track to Playlist -->
                        <div class="flex items-center gap-2 p-3 bg-slate-800/50 rounded-xl">
                            <span class="text-xs text-slate-400 flex-1">Add current track to playlist:</span>
                            <button id="add-current-to-playlist-btn" class="px-3 py-1 bg-indigo-600 hover:bg-indigo-500 rounded-lg font-bold text-xs transition-all active:scale-95" title="Add the current music source (Spotify track, YouTube video, or local file) to the selected playlist" onclick="addCurrentTrackToPlaylist()">
                                Add to Playlist
                            </button>
                        </div>
                        
                        <!-- Playlist Items Display -->
                        <div class="mt-3 p-3 bg-slate-800 border border-indigo-500/30 rounded-xl">
                            <div class="flex items-center justify-between mb-2">
                                <span class="text-xs font-bold text-white uppercase tracking-wider">Playlist Items</span>
                            </div>
                            <div id="playlist-items-container" class="space-y-1 max-h-[200px] overflow-y-auto">
                                <div class="text-xs text-slate-400">Select a playlist to view items</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="space-y-2">
                    <label class="text-indigo-400 text-[11px] font-black uppercase tracking-widest ml-1">Story Prompt</label>
                    <textarea id="prompt-input" class="w-full bg-slate-900 border border-white/10 rounded-3xl p-6 text-white h-40 focus:ring-2 ring-indigo-500 outline-none resize-none text-lg leading-relaxed" placeholder="What story would you like to hear? Describe your characters, setting, or adventure..." title="Describe the story you want to experience. AI will generate a narrative based on your prompt, continuing for the selected duration"></textarea>
                </div>

                <button id="start-btn" onclick="initiateSession()" class="w-full py-6 bg-indigo-600 rounded-2xl font-black text-xl shadow-xl hover:bg-indigo-500 transition-all active:scale-[0.98] uppercase tracking-widest" title="Start your AI-generated story experience with narration, images, and music">
                    Begin Story
                </button>
            </div>
        </main>

        <!-- Reader Screen -->
        <main id="view-reader" class="hidden flex-1 max-w-7xl mx-auto px-4 py-6 w-full pb-48">
            <div class="grid grid-cols-1 lg:grid-cols-12 gap-10">
                <div class="lg:col-span-7 bg-[#fafaf9] text-[#1c1917] novel-font rounded-[3rem] shadow-2xl flex flex-col min-h-[85vh] border border-stone-200 overflow-hidden">
                    <div id="scroll-target" class="p-12 md:p-20 flex-1 overflow-y-auto">
                        <div id="vibe-badge" class="inline-block px-4 py-1 rounded-full bg-indigo-100 text-indigo-700 text-[10px] font-black uppercase tracking-widest mb-6 transition-all opacity-0">...</div>
                        <h1 id="reader-title" class="text-5xl font-bold mb-10 tracking-tight text-stone-900 italic">Initializing...</h1>
                        <div id="reader-content" class="text-[24px] md:text-[28px] leading-[1.7] text-stone-700 space-y-8"></div>
                    </div>
                </div>

                <div class="lg:col-span-5 space-y-8">
                    <div class="image-container">
                        <div id="img-overlay" class="absolute inset-0 bg-black/60 flex flex-col items-center justify-center opacity-0 transition-opacity z-10 backdrop-blur-sm">
                            <div class="w-10 h-10 border-2 border-white/20 border-t-white rounded-full animate-spin mb-3"></div>
                            <span class="text-[10px] font-bold text-white uppercase tracking-widest">Generating Scene</span>
                        </div>
                        <img id="scene-image" src="" class="opacity-0">
                    </div>
                    
                    <div class="glass p-8 rounded-[2.5rem] space-y-6">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center gap-4">
                                <div class="w-12 h-12 bg-indigo-500/20 rounded-2xl flex items-center justify-center text-indigo-400">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle></svg>
                                </div>
                                <div class="flex-1 min-w-0">
                                    <p class="text-white font-black text-sm uppercase tracking-wider">Dynamic Score</p>
                                    <p id="music-status" class="text-indigo-300 text-xs truncate">Analyzing Prose...</p>
                                    <p id="music-source-display" class="text-slate-400 text-[10px] mt-1">Source: Default</p>
                                </div>
                            </div>
                            <div id="genre-icon" class="text-2xl">✨</div>
                        </div>
                        <div class="space-y-2">
                            <label class="text-indigo-400 text-[10px] font-bold uppercase tracking-wider">Music Volume</label>
                            <input type="range" id="music-vol" min="0" max="0.5" step="0.01" value="0.15" class="w-full accent-indigo-500" title="Adjust the volume of the background music independently from the narrator">
                        </div>
                        
                        <div class="space-y-2">
                            <label class="text-indigo-400 text-[10px] font-bold uppercase tracking-wider">Narrator Volume</label>
                            <input type="range" id="narrator-vol" min="0" max="1" step="0.05" value="1" class="w-full accent-indigo-500" title="Adjust the volume of the narrator's voice independently from the music">
                        </div>
                        
                        <!-- Change Song Button -->
                        <button id="change-song-btn" onclick="changeSong()" class="w-full py-3 bg-slate-700 hover:bg-slate-600 rounded-2xl font-bold text-sm transition-all active:scale-95 flex items-center justify-center gap-2" title="Switch to a different track while maintaining the same mood and genre (uses Spotify when connected, otherwise cycles through default library)">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 4v6h6M23 20v-6h-6"></path><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path></svg>
                            Change Song
                        </button>
                        
                        <!-- Music Playback Controls -->
                        <div class="grid grid-cols-3 gap-2 mt-3">
                            <button onclick="musicPrev()" class="py-2 bg-slate-700 hover:bg-slate-600 rounded-xl font-bold text-xs transition-all active:scale-95 flex items-center justify-center gap-1" title="Previous track in playlist or queue">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"></path></svg>
                                Prev
                            </button>
                            <button onclick="musicReplay()" class="py-2 bg-slate-700 hover:bg-slate-600 rounded-xl font-bold text-xs transition-all active:scale-95 flex items-center justify-center gap-1" title="Replay current track from the beginning">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"></path></svg>
                                Replay
                            </button>
                            <button onclick="musicNext()" class="py-2 bg-slate-700 hover:bg-slate-600 rounded-xl font-bold text-xs transition-all active:scale-95 flex items-center justify-center gap-1" title="Next track in playlist or queue">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M16 18h2V6h-2zm-11-7l8.5-6v12z"></path></svg>
                                Next
                            </button>
                        </div>
                        
                        <!-- Active Playlist Display -->
                        <div id="reader-playlist-section" class="mt-4 space-y-2">
                            <div class="flex items-center justify-between">
                                <label class="text-indigo-400 text-[10px] font-bold uppercase tracking-wider">Active Playlist</label>
                                <button onclick="toggleReaderPlaylist()" class="text-indigo-400 hover:text-indigo-300 text-xs transition-colors" title="Show/hide playlist">
                                    <span id="playlist-toggle-icon">▼</span>
                                </button>
                            </div>
                            <select id="reader-playlist-select" onchange="switchReaderPlaylist(this.value)" class="w-full bg-slate-800 border border-white/10 rounded-xl px-3 py-2 text-white text-xs appearance-none cursor-pointer hover:bg-slate-700 transition-colors" title="Select a playlist to play from">
                                <option value="">No Playlist (Manual Control)</option>
                            </select>
                            <div id="reader-playlist-items" class="hidden space-y-1 max-h-[200px] overflow-y-auto bg-slate-800/50 rounded-xl p-2">
                                <div class="text-xs text-slate-400 text-center py-2">No playlist selected</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <div id="control-panel" class="hidden fixed bottom-10 left-1/2 -translate-x-1/2 w-[90%] max-w-4xl glass rounded-[2.5rem] p-5 shadow-2xl z-50 border border-white/10">
            <div class="flex flex-col sm:flex-row items-center gap-4">
                <!-- Playback Controls -->
                <div class="flex items-center gap-3">
                    <button onclick="restartPlayback()" class="w-12 h-12 bg-slate-700 rounded-2xl flex items-center justify-center text-white shadow-lg hover:bg-slate-600 active:scale-95 transition-all" title="Restart story from the beginning">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"></path></svg>
                    </button>
                    <button onclick="togglePlayback()" class="w-16 h-16 bg-white rounded-3xl flex items-center justify-center text-indigo-900 shadow-xl hover:scale-105 active:scale-95 transition-all" title="Play or pause the story narration and music">
                        <svg id="icon-play" width="32" height="32" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"></path></svg>
                        <svg id="icon-pause" class="hidden" width="32" height="32" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg>
                    </button>
                    <button onclick="stopPlayback()" class="w-12 h-12 bg-slate-700 rounded-2xl flex items-center justify-center text-white shadow-lg hover:bg-slate-600 active:scale-95 transition-all" title="Stop playback and clear current progress">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="6" width="12" height="12"></rect></svg>
                    </button>
                </div>
                
                <!-- Current Word Display -->
                <div class="flex-1 overflow-hidden min-w-0">
                    <div class="text-[10px] font-black text-indigo-400 uppercase tracking-widest mb-1">Live Feed</div>
                    <div id="current-word" class="text-xl font-black text-white truncate italic">...</div>
                </div>
                
                <!-- Voice Selector -->
                <div class="flex items-center gap-3">
                    <div class="text-right">
                        <div class="text-[10px] font-black text-indigo-400 uppercase tracking-widest mb-1">Narrator</div>
                        <select id="voice-select-reader" onchange="changeVoice(this.value)" class="bg-slate-800 border border-white/10 rounded-xl px-4 py-2 text-white text-sm appearance-none cursor-pointer hover:bg-slate-700 transition-colors" title="Change the narrator's voice during playback. Audio will be regenerated with the new voice">
                        </select>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // Configuration Variables
        // ============================================================================
        
        // ========================================================================
        // API Configuration
        // ========================================================================
        // REMOVED: Direct API key usage is no longer supported
        // All API calls must go through Firebase Cloud Functions for security
        // 
        // To configure the API key:
        // 1. Set the key in Firebase Functions config:
        //    firebase functions:config:set genai.key="YOUR_API_KEY"
        // 2. Deploy the functions:
        //    firebase deploy --only functions
        // 3. Ensure Firebase configuration is set in the <script> tag above
        // 
        // The app will automatically route all API calls through secure Firebase proxies:
        // - Story generation: /generateStory
        // - Text-to-speech: /generateTTS
        // - Image generation: /generateImage
        //
        // See server/README.md for detailed deployment instructions
        
        const DEFAULT_ACCENT = 'American';
        const MUSIC_SELECTION_MIN_SCORE = 2; // Minimum keyword matches for intelligent music selection
        const IMAGE_QUEUE_DELAY_MS = 1000; // Delay between background image generations to avoid API overload
        const RESTART_PLAYBACK_DELAY_MS = 300; // Delay before starting playback after restart to allow UI updates to complete
        
        // API Response Validation Helpers
        function validateStoryResponse(data) {
            if (!data || !data.candidates || !data.candidates[0] || 
                !data.candidates[0].content || !data.candidates[0].content.parts ||
                !data.candidates[0].content.parts[0] || !data.candidates[0].content.parts[0].text) {
                throw new Error('Invalid story generation API response: ' + JSON.stringify(data));
            }
            return data;
        }
        
        function validateTTSResponse(data) {
            if (!data || !data.candidates || !data.candidates[0] || 
                !data.candidates[0].content || !data.candidates[0].content.parts || 
                !data.candidates[0].content.parts[0] || !data.candidates[0].content.parts[0].inlineData) {
                throw new Error('Invalid TTS API response structure: ' + JSON.stringify(data));
            }
            return data;
        }
        
        /**
         * Helper function to call the Firebase proxy for story generation
         * Acquires an App Check token and POSTs to the generateStory endpoint
         * 
         * @param {string} prompt - The story prompt or continuation instruction
         * @param {string} systemInstruction - System instruction for the AI
         * @returns {Promise<Object>} - API response data
         * @throws {Error} - If proxy is not configured or request fails
         */
        async function callGenerateProxy(prompt, systemInstruction) {
            // Check if Firebase App Check is initialized
            if (!window.fb || !window.fb.appCheck) {
                throw new Error('PROXY_NOT_CONFIGURED');
            }
            
            try {
                // Import getToken from App Check
                const { getToken } = await import("https://www.gstatic.com/firebasejs/11.6.1/firebase-app-check.js");
                
                // Get App Check token
                const appCheckTokenResponse = await getToken(window.fb.appCheck, /* forceRefresh */ false);
                const appCheckToken = appCheckTokenResponse.token;
                
                console.log('Calling generateStory proxy endpoint with App Check token');
                
                // Use the Firebase Hosting rewrite path
                const proxyUrl = '/generateStory';
                
                // POST to proxy endpoint
                const response = await fetch(proxyUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Firebase-AppCheck': appCheckToken
                    },
                    body: JSON.stringify({
                        prompt: prompt,
                        systemInstruction: systemInstruction
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                    
                    // Provide helpful error messages based on status code
                    if (response.status === 403) {
                        throw new Error(`PROXY_AUTH_FAILED: ${errorData.details || 'App Check verification failed'}`);
                    } else if (response.status === 502) {
                        throw new Error(`PROXY_UPSTREAM_ERROR: ${errorData.details || 'Upstream API error'}`);
                    } else if (response.status === 500) {
                        throw new Error(`PROXY_SERVER_ERROR: ${errorData.details || 'Internal server error'}`);
                    } else {
                        throw new Error(`PROXY_ERROR: ${errorData.error || `HTTP ${response.status}`}`);
                    }
                }
                
                const data = await response.json();
                console.log('Successfully received response from generateStory proxy');
                return data;
                
            } catch (error) {
                // Re-throw with more context
                if (error.message && error.message.startsWith('PROXY_')) {
                    throw error;
                }
                throw new Error(`PROXY_REQUEST_FAILED: ${error.message}`);
            }
        }
        
        /**
         * Helper function to call the Firebase proxy for TTS
         * 
         * @param {string} text - The text to convert to speech
         * @param {string} voice - Voice name
         * @param {string} accent - Accent to use
         * @returns {Promise<Object>} - API response data
         * @throws {Error} - If proxy is not configured or request fails
         */
        async function callTTSProxy(text, voice, accent) {
            // Check if Firebase App Check is initialized
            if (!window.fb || !window.fb.appCheck) {
                throw new Error('PROXY_NOT_CONFIGURED');
            }
            
            try {
                // Import getToken from App Check
                const { getToken } = await import("https://www.gstatic.com/firebasejs/11.6.1/firebase-app-check.js");
                
                // Get App Check token
                const appCheckTokenResponse = await getToken(window.fb.appCheck, /* forceRefresh */ false);
                const appCheckToken = appCheckTokenResponse.token;
                
                console.log('Calling generateTTS proxy endpoint with App Check token');
                
                // Determine proxy URL
                const proxyUrl = '/generateTTS';
                
                // POST to proxy endpoint
                const response = await fetch(proxyUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Firebase-AppCheck': appCheckToken
                    },
                    body: JSON.stringify({
                        text: text,
                        voice: voice,
                        accent: accent
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                    throw new Error(`TTS_PROXY_ERROR: ${errorData.details || errorData.error || `HTTP ${response.status}`}`);
                }
                
                const data = await response.json();
                console.log('Successfully received response from generateTTS proxy');
                return data;
                
            } catch (error) {
                if (error.message && error.message.startsWith('TTS_PROXY_')) {
                    throw error;
                }
                throw new Error(`TTS_PROXY_REQUEST_FAILED: ${error.message}`);
            }
        }
        
        /**
         * Helper function to call the Firebase proxy for image generation
         * 
         * @param {string} prompt - The image generation prompt
         * @returns {Promise<Object>} - API response data
         * @throws {Error} - If proxy is not configured or request fails
         */
        async function callImageProxy(prompt) {
            // Check if Firebase App Check is initialized
            if (!window.fb || !window.fb.appCheck) {
                throw new Error('PROXY_NOT_CONFIGURED');
            }
            
            try {
                // Import getToken from App Check
                const { getToken } = await import("https://www.gstatic.com/firebasejs/11.6.1/firebase-app-check.js");
                
                // Get App Check token
                const appCheckTokenResponse = await getToken(window.fb.appCheck, /* forceRefresh */ false);
                const appCheckToken = appCheckTokenResponse.token;
                
                console.log('Calling generateImage proxy endpoint with App Check token');
                
                // Determine proxy URL
                const proxyUrl = '/generateImage';
                
                // POST to proxy endpoint
                const response = await fetch(proxyUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Firebase-AppCheck': appCheckToken
                    },
                    body: JSON.stringify({
                        prompt: prompt
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                    throw new Error(`IMAGE_PROXY_ERROR: ${errorData.details || errorData.error || `HTTP ${response.status}`}`);
                }
                
                const data = await response.json();
                console.log('Successfully received response from generateImage proxy');
                return data;
                
            } catch (error) {
                if (error.message && error.message.startsWith('IMAGE_PROXY_')) {
                    throw error;
                }
                throw new Error(`IMAGE_PROXY_REQUEST_FAILED: ${error.message}`);
            }
        }
        
        /**
         * Show a transient banner with error message
         * Used to inform users about proxy/API issues
         */
        function showTransientBanner(message, type = 'warning') {
            // Check if banner already exists
            let banner = document.getElementById('transient-banner');
            if (!banner) {
                banner = document.createElement('div');
                banner.id = 'transient-banner';
                banner.className = 'fixed top-20 left-1/2 -translate-x-1/2 max-w-2xl mx-auto z-50 transition-all duration-300';
                document.body.appendChild(banner);
            }
            
            const bgColor = type === 'error' ? 'bg-red-900/30 border-red-500/50' : 
                           type === 'info' ? 'bg-blue-900/30 border-blue-500/50' :
                           'bg-yellow-900/30 border-yellow-500/50';
            
            const textColor = type === 'error' ? 'text-red-400' : 
                             type === 'info' ? 'text-blue-400' :
                             'text-yellow-400';
            
            banner.innerHTML = `
                <div class="${bgColor} border rounded-2xl p-4 backdrop-blur-sm">
                    <div class="flex items-start gap-3">
                        <svg class="w-6 h-6 ${textColor} flex-shrink-0 mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>
                        </svg>
                        <div class="flex-1 min-w-0">
                            <div class="${textColor} text-sm">${message}</div>
                        </div>
                        <button onclick="document.getElementById('transient-banner').remove()" 
                                class="${textColor} hover:opacity-75 transition-opacity p-1" 
                                title="Dismiss">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                            </svg>
                        </button>
                    </div>
                </div>
            `;
            
            // Auto-dismiss after 10 seconds
            setTimeout(() => {
                if (banner && banner.parentNode) {
                    banner.remove();
                }
            }, 10000);
        }
        
        const VOICES = {
            'American - Kore (Firm)': { name: 'Kore', accent: 'American' },
            'American - Zephyr (Bright)': { name: 'Zephyr', accent: 'American' },
            'American - Puck (Upbeat)': { name: 'Puck', accent: 'American' },
            'British - Enceladus (Breathy)': { name: 'Enceladus', accent: 'British' },
            'British - Charon (Informative)': { name: 'Charon', accent: 'British' },
            'Australian - Fenrir (Excitable)': { name: 'Fenrir', accent: 'Australian' },
            'Australian - Despina (Smooth)': { name: 'Despina', accent: 'Australian' },
            'Indian - Algieba (Smooth)': { name: 'Algieba', accent: 'Indian' }
        };
        const SCORE_LIBRARY = {
            whimsical: { name: "Whimsical Fantasy", icon: "🪄", url: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3', keywords: ['magic', 'wonder', 'playful', 'light', 'fantasy', 'enchant', 'fairy', 'charm'] },
            noir: { name: "Noir Mystery", icon: "🕵️", url: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3', keywords: ['mystery', 'detective', 'shadow', 'noir', 'investigate', 'clue', 'secret', 'hidden'] },
            epic: { name: "High Adventure", icon: "⚔️", url: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-8.mp3', keywords: ['battle', 'war', 'hero', 'quest', 'adventure', 'fight', 'warrior', 'epic', 'glory', 'triumph'] },
            horror: { name: "Dark Suspense", icon: "🌑", url: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3', keywords: ['dark', 'fear', 'horror', 'terror', 'dread', 'nightmare', 'shadow', 'death', 'blood', 'scream'] },
            scifi: { name: "Sci-Fi Ambient", icon: "🚀", url: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3', keywords: ['space', 'future', 'technology', 'alien', 'robot', 'cyber', 'quantum', 'science', 'ship', 'galaxy'] },
            dramatic: { name: "Heavy Drama", icon: "🎭", url: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3', keywords: ['emotion', 'tragic', 'sorrow', 'loss', 'pain', 'heart', 'tear', 'despair', 'sacrifice'] }
        };

        const state = {
            isPlaying: false,
            sentences: [],
            currentIndex: 0,
            voice: 'Kore',
            accent: 'American',
            timeLeftSeconds: 0,
            genre: '',
            history: [],
            audioBuffer: new Map(),
            currentAudio: new Audio(),
            music: new Audio(),
            isGeneratingChapter: false,
            isGeneratingVisual: false,
            chapterStartIndex: 0,
            // Timing estimates: ~8 seconds per sentence based on TTS speed and natural reading pace
            estimatedSecondsPerSentence: 8,
            // Average chapter length: ~12 sentences (~400 words) for optimal pacing and generation speed
            averageSentencesPerChapter: 12,
            // Minimum time buffer: Require at least half a chapter's duration before generating next chapter
            minTimeBufferRatio: 0.5,
            // Retry delay: Wait 5 seconds before allowing retry after failed generation to avoid rapid retries
            retryDelayMs: 5000,
            nextChapterTriggered: false,
            // Image generation: Track generated images and queue for pre-generation
            imageCache: new Map(),
            imageQueue: [],
            lastImageIndex: -1,
            isProcessingImageQueue: false,
            // Music intelligence: Track current mood and prose content for intelligent selection
            currentMood: null,
            lastProseContent: '',
            // Spotify integration
            spotifyAccessToken: null,
            spotifyRefreshToken: null,
            spotifyTokenExpiry: null,
            spotifyUser: null,
            spotifyPlayer: null,
            spotifyDeviceId: null,
            isUsingSpotify: false,
            currentSpotifyTrack: null,
            availableSpotifyTracks: [],
            // Music source selection: tracks currently selected music source for synchronization
            musicSource: 'spotify'
        };

        // Spotify Authentication Functions
        
        // Helper function to extract error message from Spotify API responses
        // Handles different error formats from different Spotify API endpoints
        async function parseSpotifyError(response) {
            let errorMessage = response.statusText;
            try {
                const data = await response.json();
                // Token endpoint returns: error_description, error
                // Other endpoints return: error.message
                errorMessage = data.error_description || data.error?.message || data.error || errorMessage;
            } catch (jsonError) {
                // If parsing JSON fails (e.g., non-JSON error response), use the HTTP status text as fallback
            }
            return errorMessage;
        }
        
        async function loginSpotify() {
            // Check if Spotify config is available
            if (!window.spotify || !window.spotify.clientId) {
                console.error('Spotify configuration not available');
                alert('Spotify integration is not configured. Please add your Spotify Client ID.');
                return;
            }
            
            const codeVerifier = generateCodeVerifier();
            const codeChallenge = await generateCodeChallenge(codeVerifier);
            
            // Store code verifier for later use
            localStorage.setItem('spotify_code_verifier', codeVerifier);
            
            const authUrl = new URL('https://accounts.spotify.com/authorize');
            authUrl.searchParams.append('client_id', window.spotify.clientId);
            authUrl.searchParams.append('response_type', 'code');
            authUrl.searchParams.append('redirect_uri', window.spotify.redirectUri);
            authUrl.searchParams.append('scope', window.spotify.scopes);
            authUrl.searchParams.append('code_challenge_method', 'S256');
            authUrl.searchParams.append('code_challenge', codeChallenge);
            
            window.location.href = authUrl.toString();
        }

        function logoutSpotify() {
            // Clear Spotify state
            state.spotifyAccessToken = null;
            state.spotifyRefreshToken = null;
            state.spotifyTokenExpiry = null;
            state.spotifyUser = null;
            state.isUsingSpotify = false;
            state.currentSpotifyTrack = null;
            state.availableSpotifyTracks = [];
            
            // Clear local storage
            localStorage.removeItem('spotify_access_token');
            localStorage.removeItem('spotify_refresh_token');
            localStorage.removeItem('spotify_token_expiry');
            localStorage.removeItem('spotify_user');
            
            // Update UI
            updateSpotifyUI();
            
            // If currently using Spotify music, switch back to default
            if (state.currentMood) {
                applyScore(state.currentMood);
            }
        }

        function generateCodeVerifier() {
            const array = new Uint8Array(32);
            crypto.getRandomValues(array);
            return base64UrlEncode(array);
        }

        async function generateCodeChallenge(verifier) {
            const encoder = new TextEncoder();
            const data = encoder.encode(verifier);
            const digest = await crypto.subtle.digest('SHA-256', data);
            return base64UrlEncode(new Uint8Array(digest));
        }

        function base64UrlEncode(array) {
            const base64 = btoa(String.fromCharCode.apply(null, array));
            return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
        }

        async function handleSpotifyCallback() {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            
            if (code) {
                const codeVerifier = localStorage.getItem('spotify_code_verifier');
                if (!codeVerifier) {
                    console.error('Code verifier not found');
                    return;
                }
                
                try {
                    const response = await fetch('https://accounts.spotify.com/api/token', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: new URLSearchParams({
                            grant_type: 'authorization_code',
                            code: code,
                            redirect_uri: window.spotify.redirectUri,
                            client_id: window.spotify.clientId,
                            code_verifier: codeVerifier,
                        }),
                    });
                    
                    if (!response.ok) {
                        // Parse error response to get detailed error message
                        const errorMessage = await parseSpotifyError(response);
                        throw new Error(`Spotify authentication failed: ${errorMessage}`);
                    }
                    
                    const data = await response.json();
                    
                    if (data.access_token) {
                        state.spotifyAccessToken = data.access_token;
                        state.spotifyRefreshToken = data.refresh_token;
                        state.spotifyTokenExpiry = Date.now() + (data.expires_in * 1000);
                        
                        // Store in localStorage
                        localStorage.setItem('spotify_access_token', data.access_token);
                        localStorage.setItem('spotify_refresh_token', data.refresh_token);
                        localStorage.setItem('spotify_token_expiry', state.spotifyTokenExpiry);
                        
                        // Get user info
                        await fetchSpotifyUserInfo();
                        
                        // Update UI
                        updateSpotifyUI();
                        
                        // Clear URL parameters
                        window.history.replaceState({}, document.title, window.location.pathname);
                        
                        // Clean up
                        localStorage.removeItem('spotify_code_verifier');
                    }
                } catch (error) {
                    console.error('Error exchanging code for token:', error);
                    // Show user-friendly error message
                    alert(`Failed to log in to Spotify: ${error.message}\n\nPlease check that your Spotify Client ID is correct and that the redirect URI is properly configured in your Spotify app settings.`);
                    // Clear URL parameters to allow retry
                    window.history.replaceState({}, document.title, window.location.pathname);
                    // Clean up
                    localStorage.removeItem('spotify_code_verifier');
                }
            }
        }

        async function fetchSpotifyUserInfo() {
            if (!state.spotifyAccessToken) return;
            
            try {
                const response = await fetch('https://api.spotify.com/v1/me', {
                    headers: {
                        'Authorization': `Bearer ${state.spotifyAccessToken}`
                    }
                });
                
                if (!response.ok) {
                    // If we can't fetch user info, clear the token as it may be invalid
                    if (response.status === 401 || response.status === 403) {
                        logoutSpotify();
                    }
                    
                    const errorMessage = await parseSpotifyError(response);
                    throw new Error(`Failed to fetch Spotify user info: ${errorMessage}`);
                }
                
                const userData = await response.json();
                state.spotifyUser = userData;
                localStorage.setItem('spotify_user', JSON.stringify(userData));
            } catch (error) {
                console.error('Error fetching Spotify user info:', error);
            }
        }

        function updateSpotifyUI() {
            const loginBtn = document.getElementById('spotify-login-btn');
            const userInfo = document.getElementById('spotify-user-info');
            const username = document.getElementById('spotify-username');
            
            if (state.spotifyAccessToken && state.spotifyUser) {
                loginBtn.classList.add('hidden');
                userInfo.classList.remove('hidden');
                username.textContent = state.spotifyUser.display_name || state.spotifyUser.id;
            } else {
                loginBtn.classList.remove('hidden');
                userInfo.classList.add('hidden');
            }
        }

        async function searchSpotifyTracks(mood, genre) {
            if (!state.spotifyAccessToken) {
                console.log('Not logged into Spotify, using default music');
                return null;
            }
            
            // Map moods to Spotify search terms
            const moodKeywords = {
                whimsical: 'whimsical fantasy magical',
                noir: 'noir mystery detective jazz',
                epic: 'epic orchestral cinematic adventure',
                horror: 'dark horror suspense ambient',
                scifi: 'sci-fi electronic ambient futuristic',
                dramatic: 'dramatic emotional orchestral'
            };
            
            const searchQuery = moodKeywords[mood] || mood;
            
            try {
                const response = await fetch(`https://api.spotify.com/v1/search?q=${encodeURIComponent(searchQuery)}&type=track&limit=10`, {
                    headers: {
                        'Authorization': `Bearer ${state.spotifyAccessToken}`
                    }
                });
                
                if (!response.ok) {
                    const errorMessage = await parseSpotifyError(response);
                    console.error(`Spotify search failed: ${errorMessage}`);
                    return null;
                }
                
                const data = await response.json();
                
                if (data.tracks && data.tracks.items && data.tracks.items.length > 0) {
                    state.availableSpotifyTracks = data.tracks.items;
                    return data.tracks.items[0]; // Return first track
                }
            } catch (error) {
                console.error('Error searching Spotify tracks:', error);
            }
            
            return null;
        }

        async function playSpotifyTrack(track) {
            if (!state.spotifyAccessToken || !track) return false;
            
            try {
                // Stop current music
                state.music.pause();
                
                // Use Spotify Web Playback SDK or fallback to preview URL
                if (track.preview_url) {
                    state.music.src = track.preview_url;
                    state.music.loop = true;
                    state.currentSpotifyTrack = track;
                    state.isUsingSpotify = true;
                    
                    // Update UI
                    const musicStatus = document.getElementById('music-status');
                    const musicSourceDisplay = document.getElementById('music-source-display');
                    if (musicStatus) {
                        musicStatus.textContent = `${track.name} - ${track.artists[0].name}`;
                    }
                    if (musicSourceDisplay) {
                        musicSourceDisplay.textContent = `Source: Spotify`;
                    }
                    
                    if (state.isPlaying) {
                        await state.music.play();
                    }
                    
                    return true;
                } else {
                    console.warn('Track has no preview URL available');
                    return false;
                }
            } catch (error) {
                console.error('Error playing Spotify track:', error);
                return false;
            }
        }

        async function changeSong() {
            const btn = document.getElementById('change-song-btn');
            const originalText = btn.innerHTML;
            
            // Show loading state
            btn.innerHTML = '<svg class="animate-spin h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10" stroke-opacity="0.25"></circle><path d="M12 2a10 10 0 0 1 10 10" stroke-opacity="0.75"></path></svg> Searching...';
            btn.disabled = true;
            
            try {
                if (state.spotifyAccessToken && state.currentMood) {
                    // Use Spotify if logged in
                    const track = await searchSpotifyTracks(state.currentMood, state.genre);
                    
                    if (track) {
                        const success = await playSpotifyTrack(track);
                        
                        if (success) {
                            console.log('Changed to Spotify track:', track.name);
                        } else {
                            // Fallback to next track in default library
                            changeToNextDefaultTrack();
                        }
                    } else {
                        // Fallback to default library
                        changeToNextDefaultTrack();
                    }
                } else {
                    // Use default music library
                    changeToNextDefaultTrack();
                }
            } catch (error) {
                console.error('Error changing song:', error);
                changeToNextDefaultTrack();
            } finally {
                // Restore button
                btn.innerHTML = originalText;
                btn.disabled = false;
            }
        }

        function changeToNextDefaultTrack() {
            if (!state.currentMood) return;
            
            // Get all tracks matching the current mood category
            const currentTrackKey = state.currentMood;
            const sameMoodTracks = [];
            
            // Find tracks with similar keywords
            const currentTrack = SCORE_LIBRARY[currentTrackKey];
            if (!currentTrack) return;
            
            for (const [key, track] of Object.entries(SCORE_LIBRARY)) {
                if (key !== currentTrackKey) {
                    // Check if tracks share keywords
                    const sharedKeywords = currentTrack.keywords.filter(k => 
                        track.keywords.includes(k)
                    );
                    if (sharedKeywords.length > 0) {
                        sameMoodTracks.push(key);
                    }
                }
            }
            
            // If no similar tracks, use any other track
            if (sameMoodTracks.length === 0) {
                const allKeys = Object.keys(SCORE_LIBRARY);
                sameMoodTracks.push(...allKeys.filter(k => k !== currentTrackKey));
            }
            
            // Select a random track from similar ones
            if (sameMoodTracks.length > 0) {
                const randomKey = sameMoodTracks[Math.floor(Math.random() * sameMoodTracks.length)];
                state.currentMood = randomKey;
                state.isUsingSpotify = false;
                applyScore(randomKey);
                console.log('Changed to default track:', randomKey);
            }
        }

        // Check for stored Spotify credentials on page load
        function restoreSpotifySession() {
            const accessToken = localStorage.getItem('spotify_access_token');
            const refreshToken = localStorage.getItem('spotify_refresh_token');
            const tokenExpiry = localStorage.getItem('spotify_token_expiry');
            const userStr = localStorage.getItem('spotify_user');
            
            if (accessToken && tokenExpiry && Date.now() < parseInt(tokenExpiry)) {
                state.spotifyAccessToken = accessToken;
                state.spotifyRefreshToken = refreshToken;
                state.spotifyTokenExpiry = parseInt(tokenExpiry);
                
                if (userStr) {
                    try {
                        state.spotifyUser = JSON.parse(userStr);
                    } catch (e) {
                        console.error('Error parsing stored user data:', e);
                    }
                }
                
                updateSpotifyUI();
            } else if (accessToken && refreshToken) {
                // Token expired, try to refresh
                refreshSpotifyToken().catch(err => {
                    console.error('Failed to refresh Spotify token:', err);
                    logoutSpotify();
                });
            }
        }

        async function refreshSpotifyToken() {
            if (!state.spotifyRefreshToken) return;
            
            try {
                const response = await fetch('https://accounts.spotify.com/api/token', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        grant_type: 'refresh_token',
                        refresh_token: state.spotifyRefreshToken,
                        client_id: window.spotify.clientId,
                    }),
                });
                
                if (!response.ok) {
                    // Parse error response to get detailed error message
                    const errorMessage = await parseSpotifyError(response);
                    throw new Error(`Failed to refresh Spotify token: ${errorMessage}`);
                }
                
                const data = await response.json();
                
                if (data.access_token) {
                    state.spotifyAccessToken = data.access_token;
                    state.spotifyTokenExpiry = Date.now() + (data.expires_in * 1000);
                    
                    localStorage.setItem('spotify_access_token', data.access_token);
                    localStorage.setItem('spotify_token_expiry', state.spotifyTokenExpiry);
                    
                    if (data.refresh_token) {
                        state.spotifyRefreshToken = data.refresh_token;
                        localStorage.setItem('spotify_refresh_token', data.refresh_token);
                    }
                    
                    updateSpotifyUI();
                }
            } catch (error) {
                console.error('Error refreshing Spotify token:', error);
                throw error;
            }
        }


        // Helper function to synchronize music source to MusicPlayer module
        function syncMusicSourceToPlayer(source) {
            if (typeof MusicPlayer !== 'undefined' && MusicPlayer.setSource) {
                MusicPlayer.setSource(source);
            } else if (typeof MusicPlayer !== 'undefined') {
                // Fallback: dispatch change event on the select element for MusicPlayer.attachUI to pick up
                const musicSourceSelect = document.getElementById('music-source-select');
                if (musicSourceSelect) {
                    const changeEvent = new Event('change', { bubbles: true });
                    musicSourceSelect.dispatchEvent(changeEvent);
                }
            }
        }

        async function initiateSession() {
            const prompt = document.getElementById('prompt-input').value || "Tell me an interesting story.";
            const selectedVoice = document.getElementById('voice-select').value;
            let voiceConfig = VOICES[selectedVoice];
            
            // Validate voice configuration with fallback
            if (!voiceConfig) {
                console.error('Invalid voice selection:', selectedVoice, '- falling back to default');
                const defaultVoiceKey = Object.keys(VOICES)[0];
                voiceConfig = VOICES[defaultVoiceKey];
            }
            
            state.voice = voiceConfig.name;
            state.accent = voiceConfig.accent;
            state.timeLeftSeconds = parseInt(document.getElementById('length-select').value) * 60;
            state.genre = document.getElementById('genre-select').value;
            
            // Sync reader voice selector with initial selection
            document.getElementById('voice-select-reader').value = selectedVoice;
            
            // Capture selected music source from front page
            const selectedMusicSource = document.getElementById('music-source-select')?.value || 'spotify';
            
            // Synchronize state.musicSource with selected value
            state.musicSource = selectedMusicSource;
            
            // Propagate music source to MusicPlayer module
            syncMusicSourceToPlayer(state.musicSource);
            
            // Show loading state
            const startBtn = document.getElementById('start-btn');
            startBtn.disabled = true;
            startBtn.textContent = 'Generating Story...';
            
            try {
                // First Chapter - wait for complete generation
                await generateNextChapter(prompt);
                
                // Update button to show audio generation
                startBtn.textContent = 'Preparing Narrator...';
                
                // Preload first 3 sentences for immediate playback in parallel
                const preloadPromises = [];
                for (let i = 0; i < Math.min(3, state.sentences.length); i++) {
                    preloadPromises.push(preloadAudio(i));
                }
                await Promise.all(preloadPromises);
                
                // Switch to reader view
                switchView('reader');
                startTimerDisplay();
                
                // Update music display to show selected source and current state
                updateMusicDisplayForSource(selectedMusicSource);
                
                // Auto-start playback immediately for instant narration
                togglePlayback();
                
                console.log('Story started with instant narration.');
            } catch (error) {
                console.error('Failed to start session:', error);
                
                // Instead of aborting, provide a fallback demo chapter
                // This allows users to still experience the music player and visuals
                console.log('Generating fallback demo chapter due to API failure...');
                
                // Create fallback demo chapter with 4-6 sentences
                const fallbackChapter = {
                    title: "Demo: A Moonlit Journey",
                    prose: "The night was alive with whispers of ancient magic. Stars danced across the velvet sky, painting stories of forgotten realms. A lone traveler stood at the crossroads, gazing up at the silver moon. The wind carried secrets from distant lands, weaving through the trees like a gentle song. In this moment, time itself seemed to pause, holding its breath. The journey ahead would be filled with wonder and mystery.",
                    score_type: state.genre.toLowerCase() === 'fantasy' ? 'whimsical' : 
                               state.genre.toLowerCase() === 'sci-fi' ? 'scifi' : 
                               state.genre.toLowerCase() === 'mystery' ? 'noir' : 
                               state.genre.toLowerCase() === 'horror' ? 'horror' : 'dramatic',
                    key_visual_moments: [
                        "A lone traveler at a mystical crossroads under a moonlit sky",
                        "Stars painting stories across the velvet night"
                    ]
                };
                
                // Populate state with fallback chapter
                appendChapter(fallbackChapter);
                
                // Apply appropriate music score
                applyScore(fallbackChapter.score_type);
                
                // Switch to reader view to show the demo content
                switchView('reader');
                startTimerDisplay();
                
                // Update music display
                updateMusicDisplayForSource(selectedMusicSource);
                
                // Restore start button state
                startBtn.disabled = false;
                startBtn.textContent = 'Begin Story';
                
                // Display user-friendly error message explaining the failure
                let errorMessage = '⚠️ Story Generation Failed\n\n';
                
                // Provide specific guidance based on error type
                if (error.message && error.message.includes('403')) {
                    errorMessage += 'API Key Issue: The API key may be invalid, expired, or restricted.\n\n';
                    errorMessage += 'Possible causes:\n';
                    errorMessage += '• API key is restricted to specific domains/IPs\n';
                    errorMessage += '• API key has insufficient permissions\n';
                    errorMessage += '• API quota has been exceeded\n\n';
                } else if (error.message && (error.message.includes('CORS') || error.message.includes('fetch'))) {
                    errorMessage += 'Network Issue: Unable to reach the generation API.\n\n';
                } else {
                    errorMessage += 'An unexpected error occurred during generation.\n\n';
                }
                
                // Add file:// protocol specific guidance
                if (window.location.protocol === 'file:') {
                    errorMessage += '⚠️ IMPORTANT: You are running this app via file:// protocol.\n';
                    errorMessage += 'This can cause API restrictions and CORS issues.\n\n';
                    errorMessage += 'Please serve the app over HTTP instead:\n';
                    errorMessage += '  python -m http.server 8000\n';
                    errorMessage += '  Then visit: http://localhost:8000/dreamweaver.html\n\n';
                }
                
                errorMessage += 'A demo chapter has been loaded so you can explore the music player and visuals.\n';
                errorMessage += 'Fix the API configuration to enable full story generation.';
                
                // Show error message using non-intrusive banner instead of blocking alert
                // Convert newlines to HTML breaks for proper display
                showTransientBanner(errorMessage.replace(/\n/g, '<br>'), 'warning');
                
                // Also log friendly message to console
                console.log('Fallback demo chapter loaded. Music and TTS controls are available.');
                console.log('Error details:', error.message || error);
            }
        }

        async function generateNextChapter(seedPrompt) {
            if (state.isGeneratingChapter) return;
            state.isGeneratingChapter = true;
            
            const sys = `You are a professional novelist writing a ${state.genre} story. 
            The session has ${Math.ceil(state.timeLeftSeconds / 60)} minutes remaining.
            Continue the story based on history. If this is the start, use the prompt.
            Output JSON: { "title": "Chapter Title", "prose": "About 400 words of story", "score_type": "epic/horror/noir/scifi/whimsical/dramatic", "key_visual_moments": ["brief scene description 1", "brief scene description 2"] }
            Include 2-3 key visual moments that represent important scenes in this chapter.`;

            const promptText = `History: ${state.history.join(' ')}\n\nCurrent Focus: ${seedPrompt}`;
            
            try {
                // Always use Firebase proxy for story generation
                if (!window.fb || !window.fb.appCheck) {
                    throw new Error('Firebase configuration is required. Please configure Firebase and App Check to use Dreamweaver.');
                }
                
                console.log('Using Firebase proxy for story generation');
                const data = await callGenerateProxy(promptText, sys);
                console.log('✓ Successfully used Firebase proxy');
                
                // Validate response structure
                validateStoryResponse(data);
                
                const result = JSON.parse(data.candidates[0].content.parts[0].text);
                
                state.history.push(result.prose);
                state.lastProseContent = result.prose;
                
                // Append chapter content to the page
                appendChapter(result);
                
                // Intelligently select music based on prose content analysis
                await applyIntelligentScore(result.prose, result.score_type);
                
                // Pre-generate images for this chapter before reading begins
                await preGenerateChapterImages(result);
            } catch (err) {
                console.error('Error generating chapter:', err);
                
                // Show informative error banner
                if (err.message.includes('PROXY_NOT_CONFIGURED') || err.message.includes('Firebase configuration is required')) {
                    showTransientBanner('⚠️ Story Generation Failed: Firebase not configured. Please set up Firebase and deploy Cloud Functions to enable story generation. See server/README.md for setup instructions.', 'error');
                } else if (err.message.includes('PROXY_AUTH_FAILED') || err.message.includes('APP_CHECK')) {
                    showTransientBanner('⚠️ Story Generation Failed: App Check verification failed. Please configure reCAPTCHA v3 site key and ensure Firebase App Check is properly initialized.', 'error');
                } else if (err.message.includes('PROXY_UPSTREAM_ERROR')) {
                    showTransientBanner('⚠️ Story Generation Failed: API key issue. Please ensure your API key is configured in Firebase Functions: firebase functions:config:set genai.key="YOUR_KEY"', 'error');
                } else if (err.message.includes('PROXY_SERVER_ERROR')) {
                    showTransientBanner('⚠️ Story Generation Failed: Server error. Check Firebase Functions logs for details.', 'error');
                } else {
                    showTransientBanner(`⚠️ Story Generation Failed: ${err.message}`, 'error');
                }
                
                // Re-throw error to propagate to caller
                throw err;
            } finally {
                state.isGeneratingChapter = false;
            }
        }

        function appendChapter(data) {
            const container = document.getElementById('reader-content');
            const chapterSents = data.prose.match(/[^.!?]+[.!?]+(?=\s|$)/g) || [data.prose];
            const startIdx = state.sentences.length;
            
            // Track where this chapter starts
            state.chapterStartIndex = startIdx;
            // Reset flag for next chapter generation trigger
            state.nextChapterTriggered = false;
            
            document.getElementById('reader-title').innerText = data.title;
            
            chapterSents.forEach((text, i) => {
                const globalIdx = startIdx + i;
                const span = document.createElement('span');
                span.id = `s-${globalIdx}`;
                span.className = 'sentence-span';
                text.split(/\s+/).forEach((word, wi) => {
                    const wSpan = document.createElement('span');
                    wSpan.className = 'word-token';
                    wSpan.id = `s-${globalIdx}-w-${wi}`;
                    wSpan.innerText = word + ' ';
                    span.appendChild(wSpan);
                });
                container.appendChild(span);
                state.sentences.push(text);
            });
        }

        async function playCycle() {
            // Check if we should stop playback
            if (!state.isPlaying || state.currentIndex >= state.sentences.length) {
                if (shouldGenerateNextChapter()) {
                    await generateNextChapter("Continue the narrative smoothly.");
                    await playCycle();
                }
                return;
            }

            // Calculate how many sentences are left in current chapter
            const sentencesLeftInChapter = state.sentences.length - state.currentIndex;
            const sentencesInCurrentChapter = state.sentences.length - state.chapterStartIndex;
            
            // Trigger next chapter generation when halfway through current chapter
            // This allows AI to write while reading
            // Only trigger once per chapter to avoid duplicate generation requests
            // Require at least 2 sentences in chapter to avoid edge cases with very short chapters
            if (!state.nextChapterTriggered && 
                sentencesInCurrentChapter >= 2 && 
                sentencesLeftInChapter > 0 &&
                sentencesLeftInChapter <= Math.floor(sentencesInCurrentChapter / 2)) {
                if (shouldGenerateNextChapter()) {
                    state.nextChapterTriggered = true;
                    // Generate in parallel without awaiting, so reading continues
                    generateNextChapter("Continue the narrative smoothly.").catch(err => {
                        console.error('Failed to generate next chapter in background:', err);
                        console.error('Context: Chapter generation failed mid-reading. System will retry when current chapter completes.');
                        // Note: If generation fails, the system will retry when playCycle reaches end of current chapter
                        // Reset flag after a delay to avoid rapid retries
                        setTimeout(() => { state.nextChapterTriggered = false; }, state.retryDelayMs);
                    });
                }
            }

            // Trigger visual every 4 sentences - use cached images if available
            // Check if current index aligns with image generation points (every 4 sentences from chapter start)
            const sentencesIntoChapter = state.currentIndex - state.chapterStartIndex;
            if (sentencesIntoChapter >= 0 && sentencesIntoChapter % 4 === 0) {
                if (state.imageCache.has(state.currentIndex)) {
                    displayCachedImage(state.currentIndex);
                } else {
                    // Fallback: generate on-the-fly if not cached
                    updateVisual(state.currentIndex).catch(err => console.error('Visual generation error:', err));
                }
            }

            let blob = state.audioBuffer.get(state.currentIndex);
            if (!blob) blob = await fetchTTS(state.sentences[state.currentIndex]);

            // Preload next sentences for seamless playback
            preloadNextSentences(state.currentIndex, 2);

            const audioUrl = URL.createObjectURL(blob);
            state.currentAudio.src = audioUrl;
            
            // Apply narrator volume
            const narratorVolControl = document.getElementById('narrator-vol');
            if (narratorVolControl) {
                state.currentAudio.volume = parseFloat(narratorVolControl.value) || 1;
            }
            
            // Start highlighting and word animation immediately
            highlight(state.currentIndex);
            
            const onMetadataLoaded = () => {
                animateWords(state.currentIndex);
                state.currentAudio.removeEventListener('loadedmetadata', onMetadataLoaded);
            };
            
            const onEnded = () => {
                URL.revokeObjectURL(audioUrl);
                state.currentAudio.removeEventListener('loadedmetadata', onMetadataLoaded);
                state.currentAudio.removeEventListener('ended', onEnded);
                state.currentIndex++;
                playCycle().catch(err => console.error('Playback cycle error:', err));
            };
            
            state.currentAudio.addEventListener('loadedmetadata', onMetadataLoaded);
            state.currentAudio.addEventListener('ended', onEnded);
            
            // Play immediately without delay
            state.currentAudio.play().catch(err => console.error('Audio playback error:', err));
        }
        
        function shouldGenerateNextChapter() {
            // Don't generate if already generating
            if (state.isGeneratingChapter) return false;
            
            // Don't generate if no time left
            if (state.timeLeftSeconds <= 0) return false;
            
            // Estimate time needed for one chapter (avg sentences per chapter * seconds per sentence)
            const estimatedChapterDuration = state.averageSentencesPerChapter * state.estimatedSecondsPerSentence;
            
            // Only generate if we have enough time to read at least minTimeBufferRatio of the next chapter
            // This prevents starting chapters that won't have time to complete
            return state.timeLeftSeconds >= (estimatedChapterDuration * state.minTimeBufferRatio);
        }

        async function fetchTTS(text) {
            try {
                // Always use Firebase proxy for TTS
                if (!window.fb || !window.fb.appCheck) {
                    throw new Error('Firebase configuration is required for text-to-speech');
                }
                
                console.log('Using Firebase proxy for TTS');
                const data = await callTTSProxy(text, state.voice, state.accent);
                
                // Validate response structure
                validateTTSResponse(data);
                
                return base64ToWav(data.candidates[0].content.parts[0].inlineData.data, 24000);
            } catch (error) {
                console.error('TTS generation failed:', error);
                
                // Show error banner
                if (error.message.includes('PROXY_NOT_CONFIGURED') || error.message.includes('Firebase configuration is required')) {
                    showTransientBanner('⚠️ Text-to-Speech Failed: Firebase not configured. Please set up Firebase Cloud Functions.', 'error');
                } else {
                    showTransientBanner(`⚠️ Text-to-Speech Failed: ${error.message}`, 'error');
                }
                
                throw error;
            }
        }

        function base64ToWav(base64, rate) {
            const bin = atob(base64);
            const buf = new ArrayBuffer(bin.length);
            const view = new Uint8Array(buf);
            for (let i = 0; i < bin.length; i++) view[i] = bin.charCodeAt(i);
            const header = new ArrayBuffer(44);
            const hView = new DataView(header);
            const writeStr = (off, s) => { for (let i = 0; i < s.length; i++) hView.setUint8(off + i, s.charCodeAt(i)); };
            writeStr(0, 'RIFF'); hView.setUint32(4, 36 + buf.byteLength, true); writeStr(8, 'WAVE'); writeStr(12, 'fmt ');
            hView.setUint32(16, 16, true); hView.setUint16(20, 1, true); hView.setUint16(22, 1, true); hView.setUint32(24, rate, true);
            hView.setUint32(28, rate * 2, true); hView.setUint16(32, 2, true); hView.setUint16(34, 16, true); writeStr(36, 'data');
            hView.setUint32(40, buf.byteLength, true);
            return new Blob([header, buf], { type: 'audio/wav' });
        }

        async function updateVisual(idx) {
            if (state.isGeneratingVisual) return;
            state.isGeneratingVisual = true;
            document.getElementById('img-overlay').classList.remove('opacity-0');
            const context = state.sentences.slice(idx, idx+2).join(' ');
            try {
                // Always use Firebase proxy for image generation
                if (!window.fb || !window.fb.appCheck) {
                    throw new Error('Firebase configuration is required for image generation');
                }
                
                const prompt = `Cinematic professional fantasy art, atmospheric, ${state.genre} style: ${context}`;
                console.log('Using Firebase proxy for image generation');
                const data = await callImageProxy(prompt);
                
                // Validate response structure
                if (!data || !data.candidates || !data.candidates[0] || 
                    !data.candidates[0].content || !data.candidates[0].content.parts || 
                    !data.candidates[0].content.parts[0] || !data.candidates[0].content.parts[0].inlineData) {
                    throw new Error('Invalid API response structure: missing image data');
                }
                
                const img = document.getElementById('scene-image');
                img.src = `data:image/png;base64,${data.candidates[0].content.parts[0].inlineData.data}`;
                img.onload = () => {
                    img.classList.remove('opacity-0');
                    document.getElementById('img-overlay').classList.add('opacity-0');
                };
            } catch (err) {
                console.error('Visual generation error:', err);
                
                // Show error banner only for non-config errors (config errors shown once during init)
                if (!err.message.includes('Firebase configuration is required')) {
                    showTransientBanner(`⚠️ Image Generation Failed: ${err.message}`, 'warning');
                }
                
                // Hide overlay on error to avoid blocking the UI
                document.getElementById('img-overlay').classList.add('opacity-0');
            } finally { 
                state.isGeneratingVisual = false; 
            }
        }

        function startTimerDisplay() {
            const el = document.getElementById('session-timer');
            el.classList.remove('hidden');
            const iv = setInterval(() => {
                if (state.timeLeftSeconds <= 0) {
                    clearInterval(iv);
                    // Auto-stop playback when time is up
                    if (state.isPlaying) {
                        state.isPlaying = false;
                        state.currentAudio.pause();
                        state.music.pause();
                        document.getElementById('icon-play').classList.remove('hidden');
                        document.getElementById('icon-pause').classList.add('hidden');
                    }
                    return;
                }
                if (state.isPlaying) state.timeLeftSeconds--;
                const h = Math.floor(state.timeLeftSeconds / 3600);
                const m = Math.floor((state.timeLeftSeconds % 3600) / 60);
                const s = state.timeLeftSeconds % 60;
                el.innerText = `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
            }, 1000);
        }

        function highlight(idx) {
            document.querySelectorAll('.sentence-span').forEach((el, i) => {
                el.classList.toggle('sentence-active', i === idx);
            });
            // Auto-scroll the active sentence into view as story progresses
            const el = document.getElementById(`s-${idx}`);
            if (el) {
                el.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function animateWords(sIdx) {
            const words = state.sentences[sIdx].split(/\s+/);
            const duration = state.currentAudio.duration || 2;
            const step = (duration * 1000) / words.length;
            let w = 0;
            const iv = setInterval(() => {
                if (!state.isPlaying || w >= words.length) { clearInterval(iv); return; }
                document.querySelectorAll('.word-active').forEach(e => e.classList.remove('word-active'));
                const el = document.getElementById(`s-${sIdx}-w-${w}`);
                if (el) {
                    el.classList.add('word-active');
                    document.getElementById('current-word').innerText = words[w];
                }
                w++;
            }, step);
        }

        function applyScore(type) {
            const track = SCORE_LIBRARY[type] || SCORE_LIBRARY.dramatic;
            if (state.music.src !== track.url) {
                state.music.src = track.url;
                state.music.loop = true;
                // Don't auto-play - music will be controlled by togglePlayback()
            }
            const badge = document.getElementById('vibe-badge');
            badge.innerText = `Atmosphere: ${track.name}`;
            badge.classList.remove('opacity-0');
            const musicStatus = document.getElementById('music-status');
            const musicSourceDisplay = document.getElementById('music-source-display');
            const musicSource = document.getElementById('music-source-select')?.value || 'spotify';
            
            if (musicSource === 'spotify' || state.isUsingSpotify) {
                // Show Spotify track name if available
                if (state.currentSpotifyTrack) {
                    musicStatus.innerText = `${state.currentSpotifyTrack.name}`;
                    if (musicSourceDisplay) musicSourceDisplay.innerText = `Source: Spotify`;
                } else {
                    musicStatus.innerText = track.name;
                    if (musicSourceDisplay) musicSourceDisplay.innerText = `Source: Default`;
                }
            } else if (musicSource === 'local') {
                musicStatus.innerText = track.name;
                if (musicSourceDisplay) musicSourceDisplay.innerText = `Source: Local Files`;
            } else if (musicSource === 'youtube') {
                musicStatus.innerText = track.name;
                if (musicSourceDisplay) musicSourceDisplay.innerText = `Source: YouTube`;
            } else {
                musicStatus.innerText = track.name;
                if (musicSourceDisplay) musicSourceDisplay.innerText = `Source: Default`;
            }
            
            document.getElementById('genre-icon').innerText = track.icon;
        }

        async function applyIntelligentScore(proseText, suggestedType) {
            // Analyze prose content to intelligently select music
            const lowerText = proseText.toLowerCase();
            const scores = {};
            
            // Calculate score for each music type based on keyword matching
            for (const [key, track] of Object.entries(SCORE_LIBRARY)) {
                let score = 0;
                for (const keyword of track.keywords) {
                    // Escape special regex characters to prevent injection
                    const escapedKeyword = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(`\\b${escapedKeyword}\\w*\\b`, 'gi');
                    const matches = lowerText.match(regex);
                    score += matches ? matches.length : 0;
                }
                scores[key] = score;
            }
            
            // Find the music type with highest score
            let bestMatch = suggestedType;
            let highestScore = scores[suggestedType] || 0;
            
            for (const [key, score] of Object.entries(scores)) {
                if (score > highestScore) {
                    highestScore = score;
                    bestMatch = key;
                }
            }
            
            // Only change music if we found a strong match (at least MUSIC_SELECTION_MIN_SCORE keyword occurrences)
            // or if this is the first chapter
            if (highestScore >= MUSIC_SELECTION_MIN_SCORE || state.currentMood === null) {
                state.currentMood = bestMatch;
                
                // Try Spotify first if logged in
                if (state.spotifyAccessToken) {
                    const track = await searchSpotifyTracks(bestMatch, state.genre);
                    if (track) {
                        const success = await playSpotifyTrack(track);
                        if (success) {
                            console.log(`Intelligent music selection (Spotify): ${track.name} for mood ${bestMatch} (score: ${highestScore}, suggested: ${suggestedType})`);
                            return;
                        }
                    }
                }
                
                // Fallback to default music
                applyScore(bestMatch);
                console.log(`Intelligent music selection: ${bestMatch} (score: ${highestScore}, suggested: ${suggestedType})`);
            } else {
                // Fall back to suggested type if analysis is weak
                state.currentMood = suggestedType;
                
                // Try Spotify first if logged in
                if (state.spotifyAccessToken) {
                    const track = await searchSpotifyTracks(suggestedType, state.genre);
                    if (track) {
                        const success = await playSpotifyTrack(track);
                        if (success) {
                            console.log(`Using suggested music (Spotify): ${track.name} for ${suggestedType} (analysis score too low: ${highestScore})`);
                            return;
                        }
                    }
                }
                
                // Fallback to default music
                applyScore(suggestedType);
                console.log(`Using suggested music: ${suggestedType} (analysis score too low: ${highestScore})`);
            }
        }

        async function preGenerateChapterImages(chapterData) {
            // Generate images for key visual moments before chapter reading begins
            const visualMoments = chapterData.key_visual_moments || [];
            
            if (visualMoments.length === 0) {
                // Fallback: generate images based on chapter content
                const sentences = chapterData.prose.match(/[^.!?]+[.!?]+(?=\s|$)/g) || [];
                // Generate images for every 4 sentences
                for (let i = 0; i < sentences.length; i += 4) {
                    const context = sentences.slice(i, Math.min(i + 4, sentences.length)).join(' ');
                    visualMoments.push(context);
                }
            }
            
            // Pre-generate first image immediately for display
            if (visualMoments.length > 0) {
                const startIdx = state.chapterStartIndex;
                await generateAndCacheImage(startIdx, visualMoments[0]);
                
                // Display the first image immediately since chapter will start from here
                if (state.imageCache.has(startIdx)) {
                    displayCachedImage(startIdx);
                }
                
                // Queue remaining images for background generation
                for (let i = 1; i < visualMoments.length; i++) {
                    const sentenceIdx = startIdx + (i * 4);
                    state.imageQueue.push({
                        index: sentenceIdx,
                        prompt: visualMoments[i]
                    });
                }
                
                // Start background image generation (don't await to avoid blocking)
                // Check if queue processing is already running to prevent race conditions
                if (!state.isProcessingImageQueue) {
                    processImageQueue();
                }
            }
        }

        async function generateAndCacheImage(sentenceIdx, promptText) {
            if (state.imageCache.has(sentenceIdx)) return;
            
            try {
                // Always use Firebase proxy for image generation
                if (!window.fb || !window.fb.appCheck) {
                    throw new Error('Firebase configuration is required for image generation');
                }
                
                const prompt = `Cinematic professional fantasy art, atmospheric, ${state.genre} style: ${promptText}`;
                const data = await callImageProxy(prompt);
                
                // Validate response structure
                if (!data || !data.candidates || !data.candidates[0] || 
                    !data.candidates[0].content || !data.candidates[0].content.parts || 
                    !data.candidates[0].content.parts[0] || !data.candidates[0].content.parts[0].inlineData) {
                    throw new Error('Invalid API response structure: missing image data');
                }
                
                const imageData = `data:image/png;base64,${data.candidates[0].content.parts[0].inlineData.data}`;
                state.imageCache.set(sentenceIdx, imageData);
                console.log(`Pre-generated image for sentence ${sentenceIdx}`);
            } catch (err) {
                console.error(`Failed to pre-generate image for sentence ${sentenceIdx}:`, err);
            }
        }

        async function processImageQueue() {
            // Prevent multiple concurrent queue processing
            if (state.isProcessingImageQueue) return;
            state.isProcessingImageQueue = true;
            
            try {
                // Process queued images in background, one at a time
                while (state.imageQueue.length > 0) {
                    const { index, prompt } = state.imageQueue.shift();
                    await generateAndCacheImage(index, prompt);
                    // Small delay to avoid overwhelming the API
                    await new Promise(resolve => setTimeout(resolve, IMAGE_QUEUE_DELAY_MS));
                }
            } finally {
                state.isProcessingImageQueue = false;
            }
        }

        function displayCachedImage(sentenceIdx) {
            if (!state.imageCache.has(sentenceIdx)) return;
            
            const img = document.getElementById('scene-image');
            const overlay = document.getElementById('img-overlay');
            
            img.src = state.imageCache.get(sentenceIdx);
            img.onload = () => {
                img.classList.remove('opacity-0');
                overlay.classList.add('opacity-0');
            };
            
            state.lastImageIndex = sentenceIdx;
            console.log(`Displayed cached image for sentence ${sentenceIdx}`);
        }

        async function preloadAudio(idx) {
            if (idx >= state.sentences.length || state.audioBuffer.has(idx)) return;
            const b = await fetchTTS(state.sentences[idx]);
            state.audioBuffer.set(idx, b);
        }

        function preloadNextSentences(currentIdx, count) {
            for (let i = 1; i <= count; i++) {
                const nextIdx = currentIdx + i;
                if (!state.audioBuffer.has(nextIdx)) {
                    preloadAudio(nextIdx).catch(err => console.error('Preload error:', err));
                }
            }
        }

        function togglePlayback() {
            state.isPlaying = !state.isPlaying;
            document.getElementById('icon-play').classList.toggle('hidden', state.isPlaying);
            document.getElementById('icon-pause').classList.toggle('hidden', !state.isPlaying);
            if (state.isPlaying) { 
                // Control music playback based on selected source
                const musicSource = document.getElementById('music-source-select')?.value || 'spotify';
                if (musicSource === 'spotify' || state.isUsingSpotify) {
                    // Use existing Spotify logic
                    state.music.play().catch(err => console.error('Music playback error:', err)); 
                } else {
                    // Use MusicPlayer for local/YouTube
                    if (typeof MusicPlayer !== 'undefined') {
                        MusicPlayer.play();
                        // Sync volume from music volume slider
                        const volControl = document.getElementById('music-vol');
                        if (volControl) {
                            const MUSIC_PLAYER_VOLUME_SCALE = 2; // Scale factor for MusicPlayer volume
                            MusicPlayer.setVolume(parseFloat(volControl.value) * MUSIC_PLAYER_VOLUME_SCALE);
                        }
                    }
                }
                playCycle().catch(err => console.error('Playback cycle error:', err)); 
            } 
            else { 
                if (state.currentAudio) {
                    state.currentAudio.pause();
                }
                // Pause music based on selected source
                const musicSource = document.getElementById('music-source-select')?.value || 'spotify';
                if (musicSource === 'spotify' || state.isUsingSpotify) {
                    state.music.pause(); 
                } else {
                    if (typeof MusicPlayer !== 'undefined') {
                        MusicPlayer.pause();
                    }
                }
            }
        }

        function stopPlayback() {
            // Stop playback
            state.isPlaying = false;
            if (state.currentAudio) {
                state.currentAudio.pause();
            }
            
            // Pause music based on selected source
            const musicSource = document.getElementById('music-source-select')?.value || 'spotify';
            if (musicSource === 'spotify' || state.isUsingSpotify) {
                state.music.pause();
            } else {
                if (typeof MusicPlayer !== 'undefined') {
                    MusicPlayer.pause();
                }
            }
            
            // Update UI to ensure consistency even if already stopped
            document.getElementById('icon-play').classList.remove('hidden');
            document.getElementById('icon-pause').classList.add('hidden');
            
            // Clear word highlighting
            document.querySelectorAll('.word-active').forEach(e => e.classList.remove('word-active'));
            document.getElementById('current-word').innerText = '...';
        }

        function restartPlayback() {
            // Stop current playback
            stopPlayback();
            
            // Reset to beginning
            state.currentIndex = 0;
            
            // Clear all highlighting
            document.querySelectorAll('.sentence-span').forEach(el => {
                el.classList.remove('sentence-active');
            });
            document.querySelectorAll('.word-active').forEach(e => e.classList.remove('word-active'));
            
            // Scroll to top
            const firstSentence = document.getElementById('s-0');
            if (firstSentence) {
                firstSentence.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
            
            // Start playing from beginning
            setTimeout(() => {
                togglePlayback();
            }, RESTART_PLAYBACK_DELAY_MS);
        }

        async function changeVoice(selectedVoice) {
            const wasPlaying = state.isPlaying;
            const currentPosition = state.currentIndex;
            
            // Pause playback if currently playing
            if (wasPlaying) {
                state.isPlaying = false;
                state.currentAudio.pause();
            }
            
            // Update voice configuration
            const voiceConfig = VOICES[selectedVoice];
            if (!voiceConfig) {
                console.error('Invalid voice selection:', selectedVoice);
                return;
            }
            
            state.voice = voiceConfig.name;
            state.accent = voiceConfig.accent;
            
            // Clear audio buffer to force regeneration with new voice
            state.audioBuffer.clear();
            
            // Update both voice selectors to stay in sync
            document.getElementById('voice-select').value = selectedVoice;
            document.getElementById('voice-select-reader').value = selectedVoice;
            
            // Preload next few sentences with new voice
            const preloadPromises = [];
            for (let i = currentPosition; i < Math.min(currentPosition + 3, state.sentences.length); i++) {
                preloadPromises.push(preloadAudio(i));
            }
            await Promise.all(preloadPromises);
            
            // Resume playback if it was playing before
            if (wasPlaying) {
                state.isPlaying = true;
                playCycle().catch(err => console.error('Playback cycle error:', err));
                state.music.play().catch(err => console.error('Music playback error:', err));
            }
        }

        function switchView(v) {
            document.getElementById('view-home').classList.toggle('hidden', v !== 'home');
            document.getElementById('view-reader').classList.toggle('hidden', v !== 'reader');
            document.getElementById('control-panel').classList.toggle('hidden', v !== 'reader');
            
            // Update reader playlist display when switching to reader view
            if (v === 'reader') {
                updateReaderPlaylistDisplay();
            }
        }
        
        function updateMusicDisplayForSource(source) {
            const musicStatus = document.getElementById('music-status');
            const musicSourceDisplay = document.getElementById('music-source-display');
            
            if (!musicStatus || !musicSourceDisplay) return;
            
            // Get info from MusicPlayer about what's loaded
            if (source === 'local' && typeof MusicPlayer !== 'undefined') {
                const debugState = MusicPlayer._debugState();
                if (debugState.localTracks && debugState.localTracks.length > 0) {
                    const idx = debugState.localIndex;
                    // Validate index is within bounds
                    if (idx >= 0 && idx < debugState.localTracks.length) {
                        const currentTrack = debugState.localTracks[idx];
                        musicStatus.textContent = currentTrack ? currentTrack.name : 'Local Files Ready';
                        musicSourceDisplay.textContent = 'Source: Local Files';
                    } else {
                        musicStatus.textContent = 'Local Files Ready';
                        musicSourceDisplay.textContent = 'Source: Local Files';
                    }
                } else {
                    musicStatus.textContent = 'No local files loaded';
                    musicSourceDisplay.textContent = 'Source: Local Files (None Loaded)';
                }
            } else if (source === 'youtube' && typeof MusicPlayer !== 'undefined') {
                const debugState = MusicPlayer._debugState();
                if (debugState.ytQueue && debugState.ytQueue.length > 0) {
                    const idx = debugState.ytIndex || 0;
                    // Validate index is within bounds
                    if (idx >= 0 && idx < debugState.ytQueue.length) {
                        const currentVideoId = debugState.ytQueue[idx];
                        musicStatus.textContent = `Video ID: ${currentVideoId}`;
                        musicSourceDisplay.textContent = 'Source: YouTube';
                    } else {
                        // Fallback to first video if index is invalid
                        musicStatus.textContent = `Video ID: ${debugState.ytQueue[0]}`;
                        musicSourceDisplay.textContent = 'Source: YouTube';
                    }
                } else {
                    // Check if a video was loaded (check YouTube input)
                    const ytInput = document.getElementById('youtube-url-input');
                    if (ytInput && ytInput.value) {
                        musicStatus.textContent = `YouTube: ${ytInput.value}`;
                        musicSourceDisplay.textContent = 'Source: YouTube';
                    } else {
                        musicStatus.textContent = 'No YouTube video loaded';
                        musicSourceDisplay.textContent = 'Source: YouTube (None Loaded)';
                    }
                }
            } else if (source === 'spotify') {
                if (state.spotifyAccessToken && state.currentSpotifyTrack) {
                    musicStatus.textContent = `${state.currentSpotifyTrack.name} - ${state.currentSpotifyTrack.artists[0].name}`;
                    musicSourceDisplay.textContent = 'Source: Spotify';
                } else {
                    musicStatus.textContent = 'Using Default Music Library';
                    musicSourceDisplay.textContent = 'Source: Default';
                }
            }
        }
        
        // Music playback control functions for playlist/queue navigation
        function musicPrev() {
            if (typeof MusicPlayer !== 'undefined') {
                MusicPlayer.prev();
            }
        }
        
        function musicNext() {
            if (typeof MusicPlayer !== 'undefined') {
                MusicPlayer.next();
            }
        }
        
        function musicReplay() {
            if (typeof MusicPlayer !== 'undefined') {
                MusicPlayer.replay();
            }
        }
        
        // Delete current playlist function
        function deleteCurrentPlaylist() {
            const playlistSelect = document.getElementById('playlist-select');
            if (!playlistSelect || !playlistSelect.value) {
                alert('Please select a playlist to delete');
                return;
            }
            
            if (confirm('Are you sure you want to delete this playlist? This cannot be undone.')) {
                if (typeof MusicPlayer !== 'undefined') {
                    MusicPlayer.deletePlaylist(playlistSelect.value);
                }
            }
        }
        
        // Add current track to playlist based on selected music source
        function addCurrentTrackToPlaylist() {
            const playlistSelect = document.getElementById('playlist-select');
            if (!playlistSelect || !playlistSelect.value) {
                alert('Please select or create a playlist first');
                return;
            }
            
            const musicSource = document.getElementById('music-source-select')?.value || 'spotify';
            
            if (musicSource === 'spotify') {
                // Add Spotify track
                if (state.currentSpotifyTrack) {
                    const trackData = {
                        uri: state.currentSpotifyTrack.uri,
                        id: state.currentSpotifyTrack.id,
                        name: state.currentSpotifyTrack.name,
                        artist: state.currentSpotifyTrack.artists[0].name,
                        previewUrl: state.currentSpotifyTrack.preview_url
                    };
                    const trackName = `${trackData.name} - ${trackData.artist}`;
                    MusicPlayer.addToPlaylist(playlistSelect.value, 'spotify', trackData, trackName);
                    alert('Spotify track added to playlist!');
                } else {
                    alert('No Spotify track is currently playing. Please play a track first or connect to Spotify.');
                }
            } else if (musicSource === 'youtube') {
                // Add YouTube video
                const ytInput = document.getElementById('youtube-url-input');
                if (ytInput && ytInput.value.trim()) {
                    // Use MusicPlayer's parseYouTubeId function or extract it ourselves
                    const val = ytInput.value.trim();
                    let id = null;
                    
                    // Simple YouTube ID extraction
                    try {
                        if (val.length === 11 && /^[A-Za-z0-9_-]+$/.test(val)) {
                            id = val;
                        } else {
                            const u = new URL(val);
                            if (u.hostname === 'www.youtube.com' || u.hostname === 'youtube.com' || u.hostname === 'm.youtube.com') {
                                id = u.searchParams.get('v');
                            } else if (u.hostname === 'youtu.be') {
                                id = u.pathname.slice(1);
                            }
                        }
                    } catch (e) {
                        if (val.length === 11) id = val;
                    }
                    
                    if (id) {
                        MusicPlayer.addToPlaylist(playlistSelect.value, 'youtube', id, `YouTube: ${id}`);
                        alert('YouTube video added to playlist!');
                    } else {
                        alert('Please enter a valid YouTube URL or ID first');
                    }
                } else {
                    alert('Please enter a YouTube URL first');
                }
            } else if (musicSource === 'local') {
                // Local files - add metadata note
                alert('Local files are session-only and cannot be permanently saved to playlists. To use local files across sessions, please re-upload them each time.');
            }
        }
        
        // Function to play Spotify track from playlist
        window.playSpotifyTrackFromPlaylist = async function(trackData) {
            if (!state.spotifyAccessToken) {
                alert('Please connect to Spotify first to play this track.');
                return;
            }
            
            // Create a track object compatible with playSpotifyTrack
            const track = {
                uri: trackData.uri,
                id: trackData.id,
                name: trackData.name,
                artists: [{ name: trackData.artist }],
                preview_url: trackData.previewUrl
            };
            
            // Use existing playSpotifyTrack function
            const success = await playSpotifyTrack(track);
            if (!success) {
                console.warn('Failed to play Spotify track from playlist');
            }
        };
        
        // Toggle playlist visibility in reader view
        function toggleReaderPlaylist() {
            const itemsDiv = document.getElementById('reader-playlist-items');
            const icon = document.getElementById('playlist-toggle-icon');
            if (itemsDiv.classList.contains('hidden')) {
                itemsDiv.classList.remove('hidden');
                icon.textContent = '▲';
            } else {
                itemsDiv.classList.add('hidden');
                icon.textContent = '▼';
            }
        }
        
        // Switch active playlist in reader view
        function switchReaderPlaylist(playlistId) {
            if (playlistId && typeof MusicPlayer !== 'undefined') {
                MusicPlayer.loadPlaylist(playlistId);
                updateReaderPlaylistDisplay();
            } else {
                // No playlist selected
                const itemsDiv = document.getElementById('reader-playlist-items');
                itemsDiv.innerHTML = '<div class="text-xs text-slate-400 text-center py-2">No playlist selected</div>';
            }
        }
        
        // Update reader playlist display
        function updateReaderPlaylistDisplay() {
            if (typeof MusicPlayer === 'undefined') return;
            
            const debugState = MusicPlayer._debugState();
            const playlists = MusicPlayer.getPlaylists();
            const activePlaylistId = MusicPlayer.getActivePlaylist();
            
            // Update dropdown
            const select = document.getElementById('reader-playlist-select');
            if (select) {
                select.innerHTML = '<option value="">No Playlist (Manual Control)</option>';
                Object.keys(playlists).forEach(id => {
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = playlists[id].name + ' (' + playlists[id].items.length + ' items)';
                    if (id === activePlaylistId) option.selected = true;
                    select.appendChild(option);
                });
            }
            
            // Update items display
            const itemsDiv = document.getElementById('reader-playlist-items');
            if (!itemsDiv || !activePlaylistId || !playlists[activePlaylistId]) {
                if (itemsDiv) {
                    itemsDiv.innerHTML = '<div class="text-xs text-slate-400 text-center py-2">No playlist selected</div>';
                }
                return;
            }
            
            const playlist = playlists[activePlaylistId];
            const playlistIndex = debugState.playlistIndex || 0;
            itemsDiv.innerHTML = '';
            
            if (playlist.items.length === 0) {
                itemsDiv.innerHTML = '<div class="text-xs text-slate-400 text-center py-2">Playlist is empty</div>';
                return;
            }
            
            playlist.items.forEach((item, index) => {
                const itemEl = document.createElement('div');
                itemEl.className = 'flex items-center justify-between p-2 rounded-lg hover:bg-slate-700/50 transition-colors cursor-pointer';
                
                // Highlight currently playing item
                if (index === playlistIndex && activePlaylistId) {
                    itemEl.className += ' bg-indigo-600/20 border border-indigo-500/30';
                }
                
                // Add icon based on source type
                const iconEl = document.createElement('span');
                iconEl.className = 'text-xs mr-2';
                if (item.type === 'spotify') {
                    iconEl.innerHTML = '🎵';
                } else if (item.type === 'youtube') {
                    iconEl.innerHTML = '▶️';
                } else if (item.type === 'local') {
                    iconEl.innerHTML = '📁';
                }
                
                const nameEl = document.createElement('span');
                nameEl.className = 'text-xs flex-1 truncate';
                nameEl.textContent = item.name;
                
                // Highlight currently playing
                if (index === playlistIndex && activePlaylistId) {
                    nameEl.className += ' text-indigo-300 font-bold';
                } else {
                    nameEl.className += ' text-slate-300';
                }
                
                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'flex items-center flex-1 min-w-0';
                contentWrapper.appendChild(iconEl);
                contentWrapper.appendChild(nameEl);
                
                // Click to play this item
                itemEl.onclick = () => {
                    if (typeof MusicPlayer !== 'undefined' && MusicPlayer._debugState) {
                        // Use the internal playPlaylistItem through the exposed next/prev
                        // Or we can add a new exposed function
                        playPlaylistItemByIndex(index);
                    }
                };
                
                itemEl.appendChild(contentWrapper);
                itemsDiv.appendChild(itemEl);
            });
        }
        
        // Play specific playlist item by index
        function playPlaylistItemByIndex(index) {
            if (typeof MusicPlayer === 'undefined') return;
            
            const debugState = MusicPlayer._debugState();
            const activePlaylistId = MusicPlayer.getActivePlaylist();
            const playlists = MusicPlayer.getPlaylists();
            
            if (!activePlaylistId || !playlists[activePlaylistId]) return;
            
            const playlist = playlists[activePlaylistId];
            if (index < 0 || index >= playlist.items.length) return;
            
            const item = playlist.items[index];
            
            // Handle different source types
            if (item.type === 'youtube') {
                const musicSource = document.getElementById('music-source-select');
                if (musicSource) musicSource.value = 'youtube';
                MusicPlayer.setSource('youtube');
                MusicPlayer.loadYouTubeAndPlay(item.data);
            } else if (item.type === 'spotify') {
                const musicSource = document.getElementById('music-source-select');
                if (musicSource) musicSource.value = 'spotify';
                if (window.playSpotifyTrackFromPlaylist) {
                    window.playSpotifyTrackFromPlaylist(item.data);
                }
            } else if (item.type === 'local') {
                alert('Local files are session-only. Please upload the file again to play it.');
            }
            
            // Update display to show current item
            updateReaderPlaylistDisplay();
        }

        window.onload = () => {
            // Check for file:// protocol and show warning banner
            if (window.location.protocol === 'file:') {
                const warningBanner = document.getElementById('file-protocol-warning');
                if (warningBanner) {
                    warningBanner.classList.remove('hidden');
                }
                
                // Also log to console
                console.warn('⚠️ Running from file:// protocol detected!');
                console.warn('This may cause issues with:');
                console.warn('  • Spotify Web Playback SDK postMessage origin errors');
                console.warn('  • YouTube IFrame API restrictions');
                console.warn('  • API CORS/referrer restrictions');
                console.warn('  • OAuth redirect URIs');
                console.warn('');
                console.warn('Recommended: Serve over HTTP using:');
                console.warn('  python -m http.server 8000');
                console.warn('  Then visit: http://localhost:8000/dreamweaver.html');
            }
            
            const vs = document.getElementById('voice-select');
            const vsReader = document.getElementById('voice-select-reader');
            Object.keys(VOICES).forEach(label => {
                const o = document.createElement('option');
                o.value = label;
                o.textContent = label;
                vs.appendChild(o);
                
                // Also populate reader voice selector
                const oReader = document.createElement('option');
                oReader.value = label;
                oReader.textContent = label;
                vsReader.appendChild(oReader);
            });
            
            // Connect music volume control
            const DEFAULT_VOLUME = 0.15;
            const MAX_VOLUME = 0.5;
            const validateVolume = (value) => {
                const vol = parseFloat(value);
                return isNaN(vol) ? DEFAULT_VOLUME : Math.max(0, Math.min(MAX_VOLUME, vol));
            };
            
            const volControl = document.getElementById('music-vol');
            if (volControl) {
                state.music.volume = validateVolume(volControl.value);
                volControl.addEventListener('input', (e) => {
                    state.music.volume = validateVolume(e.target.value);
                    // Also update MusicPlayer volume if using local/YouTube
                    const musicSource = document.getElementById('music-source-select')?.value || 'spotify';
                    if (musicSource !== 'spotify' && typeof MusicPlayer !== 'undefined') {
                        const MUSIC_PLAYER_VOLUME_SCALE = 2; // Scale factor for MusicPlayer volume
                        MusicPlayer.setVolume(validateVolume(e.target.value) * MUSIC_PLAYER_VOLUME_SCALE);
                    }
                });
            } else {
                state.music.volume = DEFAULT_VOLUME;
            }
            
            // Connect narrator volume control
            const narratorVolControl = document.getElementById('narrator-vol');
            if (narratorVolControl) {
                narratorVolControl.addEventListener('input', (e) => {
                    const volume = parseFloat(e.target.value);
                    const validVolume = isNaN(volume) ? 1 : Math.max(0, Math.min(1, volume));
                    // Only set volume if currentAudio exists
                    if (state.currentAudio) {
                        state.currentAudio.volume = validVolume;
                    }
                });
            }
            
            // Initialize Spotify
            handleSpotifyCallback();
            restoreSpotifySession();
            
            // Setup playlist selector event listener
            const playlistSelect = document.getElementById('playlist-select');
            if (playlistSelect) {
                playlistSelect.addEventListener('change', (e) => {
                    if (e.target.value && typeof MusicPlayer !== 'undefined') {
                        MusicPlayer.loadPlaylist(e.target.value);
                    }
                });
            }
            
            // Display Firebase initialization error banner if there was an error
            if (window.fb && window.fb.firebaseInitError) {
                showTransientBanner('⚠️ ' + window.fb.firebaseInitError, 'error');
            }
        };
    </script>
    
    <!-- Music Player Module -->
    <script src="music-player.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            MusicPlayer.init();
            
            // Synchronize music source selection on app startup
            const musicSourceSelect = document.getElementById('music-source-select');
            if (musicSourceSelect) {
                // Initialize state.musicSource from the select element
                state.musicSource = musicSourceSelect.value || 'spotify';
                
                // Apply initial source to MusicPlayer using shared helper function
                syncMusicSourceToPlayer(state.musicSource);
                
                // Add change listener to keep state.musicSource and MusicPlayer synchronized
                musicSourceSelect.addEventListener('change', (e) => {
                    state.musicSource = e.target.value;
                    syncMusicSourceToPlayer(state.musicSource);
                });
            }
            
            // Note: Play/pause buttons for the story narration are handled separately
            // The music-player.js controls background music only and does not interfere
            // with the main story playback controls (togglePlayback, etc.)
        });
    </script>
    
    <!-- Starfield generation script -->
    <script>
        // Generate stars for the background
        (function generateStarfield() {
            const starfield = document.getElementById('starfield');
            if (!starfield) return;
            
            // Predefined classes for performance
            const sizes = ['star-size-small', 'star-size-medium', 'star-size-large'];
            const speeds = ['star-slow', 'star-medium', 'star-fast'];
            const delays = ['star-delay-1', 'star-delay-2', 'star-delay-3', 'star-delay-4'];
            
            // Create regular stars
            const starCount = 200;
            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                
                // Random position
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                
                // Add random predefined classes
                star.classList.add(sizes[Math.floor(Math.random() * sizes.length)]);
                star.classList.add(speeds[Math.floor(Math.random() * speeds.length)]);
                star.classList.add(delays[Math.floor(Math.random() * delays.length)]);
                
                starfield.appendChild(star);
            }
            
            // Create shooting stars
            const shootingStarCount = 5;
            const shootSpeeds = ['shoot-slow', 'shoot-medium', 'shoot-fast'];
            const shootDelays = ['shoot-delay-1', 'shoot-delay-2', 'shoot-delay-3', 'shoot-delay-4', 'shoot-delay-5'];
            const shootWidths = ['shoot-width-small', 'shoot-width-medium', 'shoot-width-large'];
            
            for (let i = 0; i < shootingStarCount; i++) {
                const shootingStar = document.createElement('div');
                shootingStar.className = 'shooting-star';
                
                // Random starting position
                shootingStar.style.left = Math.random() * 50 + '%';
                shootingStar.style.top = Math.random() * 50 + '%';
                
                // Add predefined classes for performance
                shootingStar.classList.add(shootWidths[Math.floor(Math.random() * shootWidths.length)]);
                shootingStar.classList.add(shootSpeeds[Math.floor(Math.random() * shootSpeeds.length)]);
                shootingStar.classList.add(shootDelays[i % shootDelays.length]); // Distribute delays sequentially for consistent spacing
                
                starfield.appendChild(shootingStar);
            }
        })();
    </script>
</body>

</html>
